{
  "doc/UI设计规范/UI元素使用规范.html": {
    "href": "doc/UI设计规范/UI元素使用规范.html",
    "title": "界面UI元素-使用规范",
    "keywords": "界面UI元素-使用规范 版次：2022年4月21日 第1版 类型：程序文件 作者：软件部 上海维宏电子科技股份有限公司 版权所有 目的 编写本规范的目的是为了统一公司软件的界面UI标准，提高软件界面UI元素的一致性、可维护性，从而提高软件的质量。 适用范围 本规范适用于公司PC端产品的UI设计，自本规范实施之日起，以后新的UI设计或者UI调整均应执行本规范。 术语和定义 下列术语和定义适用于本规范。 ** 规则：**进行UI设计或UI调整时必须遵守的规定。 ** 原则：**设计时指导性的约定。 ** 说明：**对此规则或原则的必要解释。 ** 正例：**对此规则给出正确例子。 ** 反例：**对此规则给出反面例子。 ** 例外：**对此规则给出例外的说明。 基本原则 略 UI元素使用规范 通用类UI元素规范 按钮 按钮是一种基础命令，可发起一个即时操作。不同类型的的操作需要不同的按钮，同时按钮的状态也有明确的规定。 一般动作按钮 1.基本规则： 1. 不可违反规格 ，具体规格为： 【边框：1px】【圆角：4px】【文字：推荐14pt】【颜色：根据主题自定义】【左右固定边距：16px、上下固定边距：8px】 2.按钮内只有两个文字时，此时按钮为最小尺寸（64px），字数再减少时，按钮长度也不再减少。 2.正/反例、应用场景： 正例【必须使用】 反例【禁止使用】 1.默认规格： <img src=./images/an1_yb_z1.jpg style=\"zoom: 50%;\" /> 2.固定间距： <img src=./images/an1_yb_z2.jpg alt=\"an1_yb_z2\" style=\"zoom: 50%;\" /> 3.最小长度： <img src=./images/an1_yb_z3.png alt=\"an1_yb_z3\" style=\"zoom: 50%;\" /> 1.违反规格参数： <img src=./images/an1_yb_f1.png alt=\"an1_yb_f1\" style=\"zoom: 50%;\" /> 1.违反固定间距： <img src=./images/an1_yb_f2.png alt=\"an1_yb_f2\" style=\"zoom: 50%;\" /> 2.违反最小长度： <img src=./images/an1_yb_f3.jpg alt=\"an1_yb_f3\" style=\"zoom: 50%;\" /> 界面内应用 弹窗内应用 <img src=./images/an1_yb_pt1.jpg style=\"zoom: 67%;\" /> <img src=./images/an1_yb_pt2.jpg alt=\"an1_yb_pt2\" style=\"zoom:67%;\" /> 方向按钮： 1.基本规则： 1. 不可违反规格 ，具体规格为： 【边框：1px】【圆角：4px】【颜色：根据主题自定义】【字号：建议14pt】【最小间距：四周最小边距8px、序号左侧与上侧固定边距：4px】 2.按钮必须保持等边矩形比例。 3.按钮内容整体必须居中显示。 2.正/反例、应用场景： 正例【必须使用】 反例【禁止使用】 1.默认规格： <img src=./images/an2_fx_z1.png alt=\"an2_fx_z1\" style=\"zoom: 50%;\" /> 2.间距规则： <img src=./images/an2_fx_z2.png alt=\"an2_fx_z2\" style=\"zoom: 50%;\" /> 3.显示规则： <img src=./images/an2_fx_z3.png alt=\"an2_fx_z3\" style=\"zoom: 50%;\" /> 1.违反规格： <img src=./images/an2_fx_f1.png style=\"zoom: 50%;\" /> 2.违反间距： <img src=./images/an2_fx_f2.png alt=\"an2_fx_f2\" style=\"zoom: 50%;\" /> 3.违反显示规则： <img src=./images/an2_fx_f3.png alt=\"an2_fx_f3\" style=\"zoom: 50%;\" /> 界面内应用1 界面内应用2 <img src=./images/an2_fx_pt1.jpg style=\"zoom:67%;\" /> <img src=./images/an2_fx_pt2.jpg style=\"zoom:67%;\" /> 带状态按钮： 1.基本规则： 1. 不可违反规格 ，具体规格为： 【边框：1px】【圆角：4px】【颜色：根据主题自定义】【字号：建议14pt】【最小间距：四周最小边距2px/、状态灯左侧与上侧固定边距：4px】 2.允许自定义高度与宽度，也不限制长宽比例，但注意按钮文字不能超过最小间距。 3.按钮文字必须在按钮内居中显示。 2.正/反例、应用场景： 正例【必须使用】 反例【禁止使用】 1.默认规格： <img src=./images/an3_zt_z1.png style=\"zoom:50%;\" /> 2.间距规则： <img src=./images/an3_zt_z2.png alt=\"an3_zt_z2\" style=\"zoom:50%;\" /> 3.显示规则： <img src=./images/an3_zt_z3.png alt=\"an3_zt_z3\" style=\"zoom:50%;\" /> 1.违反规格： <img src=./images/an3_zt_f1.png alt=\"an3_zt_f1\" style=\"zoom:50%;\" /> 2.违反间距： <img src=./images/an3_zt_f2.png alt=\"an3_zt_f2\" style=\"zoom:50%;\" /> 3.违反显示规则： <img src=./images/an3_zt_f3.png alt=\"an3_zt_f3\" style=\"zoom:50%;\" /> 界面内应用1 界面内应用2 <img src=./images/an3_zt_pt1.jpg style=\"zoom:67%;\" /> <img src=./images/an3_zt_pt2.jpg style=\"zoom:67%;\" /> 切换按钮： 1.基本规则： 1. 不可违反规格 ，具体规格为： 【边框：1px】【圆角：4px】【颜色：根据主题自定义】【字号：建议14pt】【左右最小边距：16px、上下固定边距：8px】 2.按钮可以在不违反最小间距的情况下，自由调整宽度。 3.按钮的每个部分必须保持统一宽高。 2.正/反例、应用场景： 正例【必须使用】 反例【禁止使用】 1.默认规格： <img src=./images/an4_qh_z1.png alt=\"an4_qh_z1\" style=\"zoom:50%;\" /> 2.间距规则： <img src=./images/an4_qh_z1.jpg alt=\"an4_qh_z1\" style=\"zoom:50%;\" /> 1.违反规格： <img src=./images/an4_qh_f1.png style=\"zoom:50%;\" /> 2.违反间距： <img src=./images/an4_qh_f2.png style=\"zoom:50%;\" /> 界面内应用 <img src=./images/an4_qh_pt1.jpg alt=\"an4_qh_pt1\" style=\"zoom: 67%;\" /> 通栏按钮（大）： 1.基本规则： 1.1. 不可违反规格 ，具体规格为： 【边框：1px】【圆角：4px】【颜色：根据主题自定义】【字号：推荐32pt/粗体】【左右最小边距：28px、上下最小边距：10px、展开icon左右固定间距：8px】 2.按钮可以在不违反最小间距的情况下，自由调整尺寸。 3.按钮icon与文字组合，必须在按钮内居中显示。 4.多个按钮排列时，按钮之间不可留空隙。 2.正/反例、应用场景： 正例【必须使用】 反例【禁止使用】 1.默认规格： <img src=./images/an5_td_z1.jpg alt=\"an5_td_z1\" style=\"zoom:50%;\" /> 2.间距规则： <img src=./images/an5_td_z2.jpg alt=\"an5_td_z2\" style=\"zoom:50%;\" /> 3.显示规则： <img src=./images/an5_td_z3.jpg alt=\"an5_td_z3\" style=\"zoom:50%;\" /> 4.排列规则： <img src=./images/an5_td_z4.jpg alt=\"an5_td_z4\" style=\"zoom:50%;\" /> 1.违反规格： <img src=./images/an5_td_f1.jpg style=\"zoom:40%;\" /> 2.违反间距： <img src=./images/an5_td_f2.jpg style=\"zoom:40%;\" /> 3.违反显示规则： <img src=./images/an5_td_f3.jpg style=\"zoom:40%;\" /> 4.违反排列规则： <img src=./images/an5_td_f4.jpg style=\"zoom:40%;\" /> 界面内应用 <img src=./images/an5_td_pt1.jpg style=\"zoom:67%;\" /> 通栏按钮（小）： 1.基本规则： 1.1. 不可违反规格 ，具体规格为： 【边框：1px】【圆角：4px】【颜色：根据主题自定义】【字号：推荐32pt/粗体】【左右最小边距：28px、上下最小边距：10px、展开icon左右固定间距：8px】 2.按钮可以在不违反最小间距的情况下，自由调整尺寸。 2.正/反例、应用场景： 正例【必须使用】 反例【禁止使用】 1.默认规格： <img src=./images/an6_tx_z1.jpg alt=\"Group 914\" style=\"zoom:50%;\" /> 2.间距规则： <img src=./images/an6_tx_z2.jpg alt=\"Group 913\" style=\"zoom:50%;\" /> 3.排列规则： <img src=./images/an6_tx_z3.jpg alt=\"Group 912\" style=\"zoom:50%;\" /> 1.违反规格： <img src=./images/an6_tx_f1.jpg alt=\"Group 915\" style=\"zoom:50%;\" /> 2.违反间距： <img src=./images/an6_tx_f2.jpg alt=\"Group 916\" style=\"zoom:50%;\" /> 3.违反排列规则： <img src=./images/an6_tx_f3.jpg alt=\"Group 917\" style=\"zoom:50%;\" /> 弹窗内应用 <img src=./images/an6_tx_pt1.jpg alt=\"an6_tx_pt1\" style=\"zoom:67%;\" /> 辅助按钮 1.基本规则： 1. 2. 2.正/反例、应用场景： 正例【必须使用】 反例【禁止使用】 1.默认规格： <img src=./images/an7_f_z1.jpg style=\"zoom:50%;\" /> 2.间距规则： <img src=./images/an7_f_z2.jpg style=\"zoom:50%;\" /> 3.延展规则： <img src=./images/an7_f_z3.jpg style=\"zoom:50%;\" /> 1.违反规格： <img src=./images/an7_f_f1.jpg style=\"zoom:50%;\" /> 2.违反间距： <img src=./images/an7_f_f2.jpg style=\"zoom:50%;\" /> ![Rectangle 1039] 界面内应用1 界面内应用2 <img src=./images/an7_f_pt1.jpg alt=\"an7_f_pt1.jpg\" style=\"zoom:67%;\" /> <img src=./images/an7_f_pt2.jpg alt=\"an7_f_pt2.jpg\" style=\"zoom:67%;\" /> 5.1.2 图标 5.1.3 文字排版 5.1.3 色彩应用 5.2 布局规范 5.2.1 主界面布局规范 软件主界面一般包含3-4大板块，板块内功能彼此独立，每个板块的必须边界清晰，易于辨认。 主界面板块分布 板块说明 <img src=./images/bj_pt1.jpg style=\"zoom: 50%;\" /> 1.\"头部操作区\"包含全局信息的显示（警告、机床状态等）、参数展示与调整，或者为工具分类与具体工具 2.\"综合功能区\"包含CNC或CAD，部分软件可以通过 tab切换至其他功能。 3.\"侧边操作区\"包含相关数值显示与输入，包含机床操控按钮。 4.\"底部操作区\"包含快捷操作按钮，或者全局信息显示（警告、报错等），相关参数显示与操作 5.2.1.1板块边界 1.基本规则： 1.板块边界清晰 2.板块分割语言必须保持一致 2.正/反例： 正例【必须使用】 反例【禁止使用】 1.模块分割清晰，视觉逻辑清晰： <img src=./images/bj1_mk_z1.jpg alt=\"模块分割正例\" style=\"zoom: 50%;\" /> 模块分割不清，视觉逻辑混乱： <img src=./images/bj1_mk_f1.jpg alt=\"模块分割反例\" style=\"zoom:50%;\" /> 5.2.1.2通用间距 1.基本规则： 1.初始边距维持固定值内，同时保证在适配不同设备时，内容不被侵吞。 2.CNC、CAD控件，通栏按钮等顶边控件，不受基本间距的约束。 2.正/反例： 正例【必须使用】 反例【禁止使用】 全局边距两侧统一： <img src=./images/bj2_bj_z1.jpg style=\"zoom:50%;\" /> 多种边距，全局边距不统一： <img src=./images/bj2_bj_f1.jpg alt=\"边距反例\" style=\"zoom:50%;\" /> 5.2.1.3分割线 1.基本规则： 1.主界面内所有分割语言必须保持一致 2.CNC、CAD控件，通栏按钮等顶边控件，不受基本间距的约束。 2.正/反例： 正例【必须使用】 反例【禁止使用】 各功能分割线均保持统一规格： <img src=./images/bj3_fg_z1.jpg alt=\"分割线正例\" style=\"zoom:50%;\" /> 多重分割线规格： <img src=./images/bj3_fg_f1.jpg alt=\"分割线反例\" style=\"zoom:50%;\" /> 5.2.1.4叠加视图规则 1.基本规则： 1.所有对话框叠加在主界面时，必须遵循统一的阴影规格。 2. 2.正/反例： 正例【必须使用】 反例【禁止使用】 所有叠加的视图均采用同一阴影规格： <img src=./images/bj4_dj_z1.jpg alt=\"叠加视图正例\" style=\"zoom:50%;\" /> 违反阴影规格： <img src=./images/bj4_dj_f1.jpg alt=\"叠加视图反例\" style=\"zoom:50%;\" /> 5.2.2对话框布局规范 5.2.2.1基本元素 1.基本规则： 1.略 2.正/反例： 正例【必须使用】 反例【禁止使用】 5.2.2.2通用间距 1.基本规则： 1.略 2.正/反例： 正例【必须使用】 反例【禁止使用】 5.2.2.3对齐规则 1.基本规则： 1.略 2.正/反例： 正例【必须使用】 反例【禁止使用】 5.3信息展示类UI元素规范 5.3.1切换tab 1.基本规则： 1. 2.正/反例、应用场景： 正例【必须使用】 反例【禁止使用】 1.默认规格： <img src=./images/zs1_qh_z1.png style=\"zoom:50%;\" /> 2.间距规则： <img src=./images/zs1_qh_z2.png alt=\"Group 866\" style=\"zoom:50%;\" /> 1.违反规格： <img src=./images/zs1_qh_f1.png alt=\"Group 862\" style=\"zoom:50%;\" /> 2.违反间距： <img src=./images/zs1_qh_f2.png style=\"zoom:50%;\" /> 界面内应用 <img src=./images/zs1_qh_pt1.jpg alt=\"切换2\" style=\"zoom:67%;\" /> 5.3.2综合信息框 1.基本规则： 1. 2.正/反例、应用场景： 正例【必须使用】 反例【禁止使用】 1.默认规格： <img src=./images/zs2_zh_z1.png style=\"zoom:50%;\" /> 2.间距/显示规则： <img src=./images/zs2_zh_z2.png alt=\"Group 872 (1)\" style=\"zoom:50%;\" /> 1.违反规格： <img src=./images/zs2_zh_f1.png alt=\"Group 868\" style=\"zoom:50%;\" /> 2.违反间距/显示规则： <img src=./images/zs2_zh_f1.png alt=\"Group 869\" style=\"zoom:50%;\" /> 界面内应用 <img src=./images/zs2_zh_pt1.jpg alt=\"文本框\" style=\"zoom:67%;\" /> 表格 分页 树菜单 空状态 5.4信息输入类UI元素规范 输入框 滑动选择器 复选框 单选框 开关 5.5文本规范"
  },
  "doc/UI设计规范/信息展示.html": {
    "href": "doc/UI设计规范/信息展示.html",
    "title": "信息展示",
    "keywords": "信息展示 展示分类 TAB切换，类似于网页端的Tab，即可以在同一个窗口显示不同的界面。 综合信息框，显示某块区域的信息，包括标题和正文。 表格，通过行列的形式直观显示相似类型的各个属性信息，主要用于参数界面。 分页，分页控件分为四部分，信息汇总（左）、页面显示（以【末页】按钮结束）（中）、页码输入框（右一）、按钮（右二），由于数据信息比较多，需要通过分页的形式呈现，主要用于日志的显示。 树菜单，通过层级的方式显示信息，老版本软件用于参数显示，新的phx软件较少使用该控件。 设计原则 具体设计 TAB 切换 必须遵守 用户使用频繁、功能重要等级比较高的功能界面，推荐通过TAB切换控件在主界面展示。 动作按钮的边框、圆角、左右&上下固定边距、最小边距等按照组件库设计，不可随意修改，若需要修改需要提交软件部UI设计评审。 边框：1px；圆角：4px；左右最小边距：10px；上下最小边距：4px。需要缩小按钮规格时，请注意不要突破最小边距。 \"选中\"/“未选中”的TAB颜色必须区分。 可自定义 文字大小和颜色根据页面设计定义，一般情况下文字不小于12pt。 正/反例&应用场景 正例【必须使用】 反例【禁止使用】 1.默认规格： 1.违反规格，选中未选中颜色近似： 2.间距规则： 2.违反间距规则，突破最小间距： 界面内应用 组件库链接 待更新。 综合信息框 必须遵守 动作按钮的边框、圆角、左右&上下固定边距、标题距左边框边距、内容距左边框边距及文本对齐方式等按照组件库设计，不可随意修改，若需要修改需要提交软件部UI设计评审。 边框：1px；圆角：4px；左右最小边距：10px；上下最小边距：4px；标题距左边框边距：7px；内容距左边框最小间距：24px；内容距标题最小间距：16px；内容对齐方式：左对齐/居中对齐均可。 可自定义 文字大小和颜色根据页面设计定义，一般情况下推荐文字大小16pt。 信息框内容的对其方式允许选择左对齐/或居中对齐，但请不要突破最小边距。 在标题位置保证左侧间距的同时，与边框顶边垂直。 正/反例&应用场景 正例【必须使用】 反例【禁止使用】 1.默认规格： 1.违反规格，边框线宽与圆角错误： 2.间距/显示规则： 2.违反间距，标题和内容均突破规定间距： 界面内应用 组件库链接 待更新。 表格 必须遵守 表格分割线、表格文字和分割线间距按照组件库设计，不可随意修改，若需要修改需要提交软件部UI设计评审。 分割线：1px；表格文字和分割线间距：16px； 可自定义 表格文字颜色、标题栏底色根据页面整体设计自定义，但必须保持标题栏和正文颜色的差异性。一般情况下推荐文字大小14pt，标题需要加粗。 标题和内容文本对齐方式：左对齐/居中，但请不要突破最小边距。 在标题位置保证左侧间距的同时，与边框顶边垂直。 表格宽高根据界面设计自定义。 不同操作状态下的显示色彩有明显区分。 正/反例&应用场景 正例【必须使用】 反例【禁止使用】 1.默认规则： 1.分割线过粗、标题字体未加粗、标题颜色与内容颜色未区分： 2.间距与对齐规则： 2.突破最小间距、多种对齐方式： 3.色彩区分： 3.不同操作状态的下的色彩区分不明显： 界面内应用 组件库链接 待更新。 分页 必须遵守 界面需要呈现比较多的信息，可以采用分页，但该控件在数控软件并不常用，且请慎用该控件。 分页控件的输入框、常规按钮、文字按钮等规格需保持和其它同类按钮一致，不可以随意修改。 页码间距保持一致，具体间距根据设计。 分页控件信息汇总（左）对齐方式：居左，其余信息对齐方式：居右。 【末页】控件和【页码输入框】控件最小间距：16px；【页码输入框】控件和【按钮】控件最小间距：10px。 【页码】按钮为文字按钮，即需带下划线标识。 当前页码文字需和其它页码区分，保证字号相同，字体粗体。 可自定义 文字颜色根据页面整体设计自定义，一般情况下推荐文字大小14pt，重点文字可以加粗。 正/反例&应用场景 正例【必须使用】 反例【禁止使用】 1.默认规格： 1.文字按钮没有添加下划线、输入框与常规按钮规格异常： 2.间距规则： 2.对齐方式错误、间距错乱 ： 弹窗内应用 组件库链接 待更新。 树 必须遵守 使用场景需更新。 树形控件的文字、标题等规格需保持和其它正文保持一致，不可以随意修改。 标题文字必须为粗体。 菜单层级不可超过三级。 到达页面右侧的规定间距自动换行，不要突破间距。 可自定义 文字颜色根据页面整体设计自定义，一般情况下推荐文字大小14pt，最大16pt，重点文字可以加粗。 正/反例&应用场景 正例【必须使用】 反例【禁止使用】 1.默认规格： 1.字号过小、层级过多、长文本未准确换行： 2.间距规则： 2.左右、上下间距均违反规则： 界面内应用 组件库链接 待更新。"
  },
  "doc/UI设计规范/信息输入.html": {
    "href": "doc/UI设计规范/信息输入.html",
    "title": "信息输入",
    "keywords": "信息输入 用户通过信息输入框和系统进行交互，实现新增、修改、删除和查询的功能。 输入分类 信息输入包括以下几种类型： 文本输入 常规输入，最基本的、用户普遍使用的可直接在内部编辑输入数据的控件。 前后缀文本输入，一般前后缀文本和输入数据有关联性，比如用户需要提交带单位的输入。 带icon输入，用于标识使用频率比较高、需要引起重视的输入框以及可以弹出控件进行输入的情况，比如搜索框带图标。 选择输入 单选框，只可以选择一个输入，比如只能选择一种安装类型。 复选框，可以选择多个输入，比如可以多个安装后行为。 状态切换，通过切换两种状态达到开关该选项的功能，比如启用/禁用某选项。 数值滑动条，通过选定及拖动滚动条icon选择不同的数值，比如选择进给倍率。 日期控件选择，通过在日期控件上选择进行输入。 下拉列表，通过下列列表的形式进行单项或多项选择的输入，比如XXX。 双列选择表，通过在一列选择，另外一列取消进行单项或者多项输入的选择，比如XXX。 文件上传，通过文件输入窗口选择文件，比如文件加载、文件导入。 设计原则 所有的信息输入控件都应该有直观的描述性信息，引导用户通过直接输入或选择的方式达到预期的目标。 输入控件的选择应考虑用户操作的便宜性、引导性、效率、容错性和保密安全性。 设计信息输入控件及提示文本要简单、清晰、无歧义，避免用户猜测或误导用户操作。 具体设计 常规输入框 必须遵守 需要根据用户意愿直接输入信息反馈给系统的，必须使用常规输入框或前后缀文本输入框，比如文字搜索、设置机床各种参数值等情况。 输入框的边框、圆角、内部文字距离输入框上下&左右间距及文字对齐方式必须按照组件库设计，不可随意修改，若需要修改需要提交软件部UI设计评审。 边框：1px；圆角：4px；内部文字距离输入框左右最小间距：10px；上下最小间距：6px； 可自定义 文字大小和颜色根据软件整体布局和页面设计进行自定义，推荐普通版文字大小：14pt。自定义输入框尺寸较大时，可以增大字号。 输入文字内容和输入提示信息内容颜色要区分，可根据主题自定义。 遵守最小间距的前提下，可以自定义宽高。 正/反例&应用场景 正例【必须使用】 反例【禁止使用】 1.默认规格： 1.边框规格/圆角规格错误： 2.间距与适配规则： 2.突破最小间距要求： 界面内应用 组件库链接 待更新 前后缀文本输入框 必须遵守 需要根据用户意愿直接输入信息反馈给系统的，必须使用常规输入框或前后缀文本输入框，比如文字搜索、设置机床各种参数值等情况。 输入框的边框、圆角、内部文字距离输入框上下&左右间距及文字对齐方式必须按照组件库设计，不可随意修改，若需要修改需要提交软件部UI设计评审。 边框：1px；圆角：4px；内部文字距离输入框左右最小间距：10px；上下最小间距：6px； 可自定义 文字大小和颜色根据软件整体布局和页面设计进行自定义，推荐普通版文字大小：14pt。自定义输入框尺寸较大时，可以增大字号。 输入文字内容和输入提示信息内容颜色要区分，和附带文本区域底色一样，可根据主题自定义。 遵守最小间距的前提下，可以自定义宽高。 正/反例&应用场景 正例【必须使用】 反例【禁止使用】 1.默认规格： 1.规格错误/附带文本区底色错误： 2.间距与适配规则： 2.间距错误： 界面内应用 组件库链接 待更新 带icon输入框 必须遵守 需要根据用户意愿直接输入信息反馈给系统的，必须使用常规输入框或前后缀文本输入框，比如文字搜索、设置机床各种参数值等情况。 输入框的边框、圆角、内部文字距离输入框上下&左右间距及文字对齐方式必须按照组件库设计，不可随意修改，若需要修改需要提交软件部UI设计评审。 边框：1px；圆角：4px；内部文字距离输入框左右最小间距：10px；上下最小间距：6px； 可自定义 文字大小和颜色根据软件整体布局和页面设计进行自定义，推荐普通版文字大小：14pt。自定义输入框尺寸较大时，可以增大字号。 输入文字内容和输入提示信息内容颜色要区分，和附带文本区域底色一样，可根据主题自定义。 遵守最小间距的前提下，可以自定义宽高。 正/反例&应用场景 正例【必须使用】 反例【禁止使用】 1.默认规格： 1.边框/圆角/图标规格错误： 2.间距与适配规则： 2.突破最小间距要求： 界面内应用 组件库链接 待更新 下拉选项框 必须遵守 需要根据用户意愿直接输入信息反馈给系统的，必须使用常规输入框或前后缀文本输入框，比如文字搜索、设置机床各种参数值等情况。 输入框的边框、圆角、内部文字距离输入框上下&左右间距及文字对齐方式必须按照组件库设计，不可随意修改，若需要修改需要提交软件部UI设计评审。 边框：1px；圆角：4px；内部文字距离输入框左右最小间距：10px；上下最小间距：6px； 可自定义 文字大小和颜色根据软件整体布局和页面设计进行自定义，推荐普通版文字大小：14pt。自定义输入框尺寸较大时，可以增大字号。 输入文字内容和输入提示信息内容颜色要区分，和附带文本区域底色一样，可根据主题自定义。 遵守最小间距的前提下，可以自定义宽高。 正/反例&应用场景 正例【必须使用】 反例【禁止使用】 1.默认规格： 1.边框/圆角/图标规格错误： 2.间距与适配规则： 2.突破最小间距要求： 界面内应用 组件库链接 待更新 开关 必须遵守 需要根据当前功能及其工艺需要，由用户选择性开启。必须有一种选择，且确保默认选择为最安全或用户默认需要的情况。 开关输入框仅边框必须按照组件库设计，不可随意修改，若需要修改需要提交软件部UI设计评审。 边框：1px； 可自定义 打开/关闭状态的底色和字体颜色不同，推荐字号：12px，也可根据界面整体设计自定义。 遵守最小间距的前提下，可以自定义宽高。 开关圆角可根据高度取最大值。 正/反例&应用场景 正例【必须使用】 反例【禁止使用】 1.默认规格： 1.边框、文字规格错误： 2.间距规则： 2.突破最小间距： 界面内应用 组件库链接 待更新。 数值滑动条 必须遵守 数值滚动条使用场景比较少，目前仅倍率控制使用该控件。 开关输入框仅边框必须按照组件库设计，不可随意修改，若需要修改需要提交软件部UI设计评审。 边框：1px；圆角：2px 可自定义 滚动条已进程/未进程颜色需有强烈反差，可根据界面整体设计自定义。 遵守最小间距的前提下，可以自定义宽高。 文字与控件之间不要突破最小间距，注意两者之间的对齐方式与间距。 可自定义尺寸。 什么的尺寸？是宽高尺寸可以自定义吗？ 正/反例&应用场景 正例【必须使用】 反例【禁止使用】 1.默认规格： 1.颜色反差太小： 2.间距规则： 2.间距错误，文字与控件两端未对齐： 界面内应用 组件库链接 待更新。 复选框 必须遵守 复选框使用频率比较高。 复选框边框及“选中”内容与边距必须按照组件库设计，不可随意修改，若需要修改需要提交软件部UI设计评审。 未选中”边框1px/“选中”无边框；“选中”内部内容与边距需留固定间距：2px。 可自定义 选中/未选中两种颜色需有强烈反差，可根据界面整体设计自定义。 正/反例&应用场景 正例【必须使用】 反例【禁止使用】 1.默认规格： 1.颜色反差太小： 2.间距规则： 2.间距错误，文字与控件两端未对齐： 界面内应用 单选框 必须遵守 单选框使用频率比较高。 单选框仅边框及“选中”内部内容与边距必须按照组件库设计，不可随意修改，若需要修改需要提交软件部UI设计评审。 边框：1px；“选中”内部内容与边距需留固定间距：2px。 可自定义 选中/未选中两种颜色需有强烈反差，可根据界面整体设计自定义。 正/反例&应用场景 正例【必须使用】 反例【禁止使用】 1.默认规格： 1.反占位文本： 2.间距规则： 2.反占位文本： 界面内应用 下面应该还有很多 下拉列表 Transer 文件选择"
  },
  "doc/UI设计规范/布局规范.html": {
    "href": "doc/UI设计规范/布局规范.html",
    "title": "布局规范",
    "keywords": "布局规范 主界面布局 软件主界面一般包含3-4大板块，板块内功能彼此独立，每个板块的边界应该清晰，易于辨认。 主界面板块分布 板块说明 1.\"头部操作区\"包含全局信息的显示（警告、机床状态等）、参数展示与调整，或者为工具分类与具体工具 2.\"综合功能区\"包含CNC或CAD，部分软件可以通过 tab切换至其他功能。 3.\"侧边操作区\"包含相关数值显示与输入，包含机床操控按钮。 4.\"底部操作区\"包含快捷操作按钮，或者全局信息显示（警告、报错等），相关参数显示与操作 板块边界 必须遵守 板块边界必须清晰，通过一致的分割线进行标识。 正/反例 正例【必须使用】 反例【禁止使用】 1.模块分割清晰，视觉逻辑清晰： 模块分割不清，视觉逻辑混乱： 通用间距 必须遵守 初始边距维持固定值内，同时保证在适配不同设备时，内容不被侵吞。 例外：CNC、CAD控件，通栏按钮等顶边控件，不受基本间距的约束。 正/反例 正例【必须使用】 反例【禁止使用】 全局边距两侧统一： 多种边距，全局边距不统一： 分割线 必须遵守 主界面内通过一致的分割线进行标识。 正/反例 正例【必须使用】 反例【禁止使用】 各功能分割线均保持统一规格： 多重分割线规格： 叠加视图 必须遵守 所有对话框叠加在主界面时，必须遵循统一的阴影规格。 正/反例 正例【必须使用】 反例【禁止使用】 所有叠加的视图均采用同一阴影规格： 违反阴影规格： 对话框布局 必须遵守 对话框必须包含以下基本元素，不可缺失。 对话框名称 最大/最小化 取消/确定 “取消/确定”按钮的名称和形态，可以根据弹窗内容而改变，特殊情况下允许只出现其一。 正/反例 正例【必须使用】 反例【禁止使用】 1.元素齐全： 1.常规情况下，元素缺失 通用间距 必须遵守 两侧边距必须保持一致。 边距只保留最小距离，内容可自定义分布，不突破最小间距即可。 以上描述不是很明白？ 正/反例 正例【必须使用】 反例【禁止使用】 1.正占位文本： 1.反占位文本： 对齐规则 不是很明白？正占位，反占位？ 正/反例 正例【必须使用】 反例【禁止使用】 1.正占位文本： 1.反占位文本："
  },
  "doc/UI设计规范/引言/引言.html": {
    "href": "doc/UI设计规范/引言/引言.html",
    "title": "引言",
    "keywords": "引言 目的 首先，为更好的保证软件产品界面视觉质量及其一致性，并确保产品在后期的升级、迭代过程中维持统一的视觉标准，提升用户体验。 其次，沉淀设计规范及组件设计资产，避免重复造轮子，保证设计质量的前提下，减少设计成本，提高测试效率。 同时通过明确规范，也可以降低不同设计师、开发工程师、测试工程师之间的沟通成本，提高协同工作效率。 本文档阅读者及阅读建议 开发工程师 通过该规范文档，可以查阅通用组件规格和样式（包含且不限于：色彩、字体、按钮、分割线、通用图标等），正确套用组件规格和样式，可以保证产品最终视觉效果的同时，也可以进一步减轻开发工作负荷。 UI设计师/产品经理 UI设计师通过优化以往界面、日常设计总结等方式，收集可通用的设计元素，形成设计组件集合，利用该组件集合归纳和编写设计规范，形成设计源文件。源文件将通过转发和在线文件形式，方便其他设计师和开发查阅文件内容。 测试工程师 参考该规范进行UI测试用例设计及用户验收测试。 适用范围 本规范适用于公司研发体系和产品体系PC端产品的UI设计，自本规范实施之日起，以后新的UI设计或者UI调整均应执行本规范。 本规范主要关注UI元素设计，包括以下几个方面： 通用元素规范，主要包括按钮、字体、色彩相关规范和设计原则。 布局规范，主要定义了主要界面布局及其规格。 信息输入，主要定义了信息输入的各种控件使用场景及规格，包括常规输入框、列表、单复选框等。 信息展示，主要定义了信息展示的各种形式，包括TAB、表格、分页等。 目前包括如上内容，后续会持续优化，批注日期：2022-5 使用原则 本规范针对各种UI元素的规范分为必须遵守和可自定义两个等级，具体要求如下： 必须遵守 UI设计有一个基本的原则，少即是多(less is more)，用尽可能少的样式来实现设计目标，例如按钮提供三种尺寸即可，在适应不同场景需求的同时保证体验的一致性；另一方面，保持克制的设计规范可以进一步减少设计师的决策时间，提高设计效率。UI设计规范里面标识 必须遵守 的规范，即对特定的控件及其部分规格进行严格的要求，该规格不可随意修改，测试工程师将按照该控件规范进行UI层面的验收测试。 若实施过程出现和规范不一致且无法按照规范执行的情况，可提交软件部UI设计团队进行评审。 可自定义 可根据界面整体设计进行自定义。 反馈及建议 如果在使用过程中有任何的建议和意见，欢迎积极反馈。也可以直接提交到github资源库。 链接： https://github.com/weihong-phoenix/UI_DesignRules/tree/main/doc/UI%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"
  },
  "doc/UI设计规范/文案规范.html": {
    "href": "doc/UI设计规范/文案规范.html",
    "title": "文案规范",
    "keywords": "文案规范 文案是产品与用户交流的最基础的工具，产品的文案一般存在以下问题： 相似内容表达不一致，比如同样是操作提示框，提示框按钮的文案描述不一致。 文案信息没有重点，或过于啰嗦，甚至晦涩难懂，用户很难知道下一步如何操作。 不注重细节，影响产品的声誉，给用户感觉缺少专业性，比如大小写错误，缺少标点符号或者标点符合使用不当。 因此，规范文案的使用和编写，可以避免用户操作时产生歧义而误操作或影响使用效率，降低用户体验，而精确、一致的文案设计，则可以减少用户使用产品的成本和效率，提升用户体验。 文案类型 本章节暂从参数命名及描述、标点符号和大小写几种类型进行描述。 参数命名及描述 BOOL型，参数类型为BOOL型的，选项只有两种情况。比如圆弧限速，选项仅为是/否的情况。 值枚型，参数类型为枚举型，选项有多种情况。比如插补算法，选项有加速度直线型、加速度三角形、加速度梯形、高速梯形、LSC、HSS。 标点符号 冒号 引号，表示引用的文本需使用引号。 括号 单书名号 加载符号，表示加载或进程的文本末需用3个循环出现的点作为后缀，如“软件启动中…”、“正在调机…”等。 英文大小写 首句字母大写 独立词语首字母大写 全部大写，全部大写是指每个字母都使用大写。一般适用于以下情况：通用缩写，文件格式（或类型），坐标轴等。 小写 设计原则 准确，文字描述特别是操作提示信息，必须精确。 正反例 简洁，文字避免啰嗦，无重点。 正反例 站在用户的角度描述。 正反例 具体设计 参数命名与描述 BOOL型 必须遵守 参数名称中不可出现“是否”。 ｜ ｜ 选择应使用单选按钮列举选项。 ｜ ｜ 值枚举型 必须遵守 选项与对应的数值之间用冒号“：”，不得使用“表示/为/是”等字眼。 相邻选项之间用分号“；”隔开。 标点符号 必须遵守 中文标点符号可直接使用，英文标点符号输入后需加一个空格。 冒号 必须遵守 冒号必须使用英文半角模式下的“冒号”。 如果冒号与后面的内容在同一个控件上，需在冒号后加一个空格。 引号 必须遵守 中文版本使用中文半角引号，英文版本使用英文半角引号加空格。 括号 表示补充说明、快捷键或数值范围的文本需使用括号。 必须遵守 中英文版本均使用英文半角括号。 表示范围时，如果临界值可以取到，需用英文半角中括号： 单书名号 必须遵守 引用某个参数或按键上的名称时，应使用单书名号，使用规范同“括号”。 加载符号 必须遵守 中英文版本均使用英文半角句号或数字键盘中的点“.”。 英文大小写规范 句首字母大写 必须遵守 告警或提示符号的首字母必须大写。如：Error，Warnning，Tips等。 完整句子首个单词首字母必须大写。如：状态栏弹出提示、操作提示或说明、参数解释或描述等。 列表中的描述性信息首字母必须大写。 单词首字母大写 必须遵守 单个词语或短语中的每个单词首字母必须大写。 单选或复选的选项为一个完整的句子时，仅句首字母大写。 标识为常显状态或模式的文字首字母必须大写。 菜单及菜单选项的首字母必须大写。 全部大写 必须遵守 坐标轴都需要大写：X，Y，Z，…… 通用缩写都需要大写：IO（Input/Output） ，MFR（Multi-frequency Receiver），HW（Hand Wheel），USB（Universal Serial Bus），…… 文件格式描述都需要大写：PLT，DXF，ENG，…… 小写 必须遵守 控件上的短语中，介词（如of，by，to，in，on，at，for，as等）或连词（如and，or，with等）一般需小写，如“Set as Default”中“as”需小写。 通用短语“Save As…（存储为…）”中的“As”首字母需要大写。"
  },
  "doc/UI设计规范/通用类元素规范/按钮.html": {
    "href": "doc/UI设计规范/通用类元素规范/按钮.html",
    "title": "按钮",
    "keywords": "按钮 按钮是一种基础控件，操作按钮用户可以得到即时响应。而不同操作需要不同类型的按钮，同时按钮的状态信息对用户体验起着重要的作用。 按钮分类 根据维宏产品的业务形态，按钮的分类主要基于产品功能进行分类，包括以下几种类型： 常规按钮 和数控行业关联性比较弱的，属于功能的新增、删除、修改、搜索及其它和业务关联性相对比较弱的按钮（也有相关的），按钮一般比较独立，按钮+文字进行标识。 一般操作 选项卡 选项卡按钮，用于模式切换、各种功能界面可以同时在主界面快捷展示，而不需要通过菜单或者翻页及窗口跳转去展示功能。 通栏操作 包括通栏操作大&小按钮，通栏操作大按钮标识进入某个功能界面的按钮，类似于菜单入口，属于快捷入口，位于软件布局的最底层位置。比如装载、仿真、清零等按钮。通栏操作小按钮，和通栏大按钮不同之处在于，按钮较多的情况下或者归属于某个功能下的子功能入口，位于弹窗布局的最底层位置。比如文件编辑功能界面的通栏按钮。 主控按钮 用于机床运动控制，按钮一般通过图标（icon）+文字进行标识，主控按钮仅包括开始、停止、暂停、断点继续四个按钮。 辅控按钮 用于机床运动前、后的就绪功能按钮，按钮一般通过图标（icon）+文字进行标识，辅控按钮一般有多个，位置比较集中，形成群组。一般包括回机械原点、回工件原点、仿真、空运行等按 钮。 机床辅助 工艺控制 用于启闭工艺及显示工艺状态的按钮，通过实时控制输入、输出端口信号及显示端口状态标识启停工艺及显示其状态。按钮一般通过状态图标（icon）+文字进行标识，工艺控制按钮一般有多个，位置比较集中，形成群组。一般包括冷却、润滑、吹气等按钮。 # 手动区按钮 用于控制机床各个轴的运动方向、前进/后退，按钮一般通过方向图标（icon）进行标识，方向按钮位置集中，形成群组。一般包括XYZ轴及旋转轴正、反方向移动或旋转。 轴方向 轴方向按钮，用于控制机床各个轴的运动方向，按钮一般通过方向图标（icon）进行标识，方向按钮位置集中，形成群组。一般包括XYZ轴及旋转轴正、反方向移动或旋转。 前进/后退 快捷功能按钮 ribbon按钮 包括ribbon大/小按钮。 软件设定 通栏快捷 功能入口按钮-大/小图标，用来标识功能或常用工艺的入口，一般在激光软件中普遍应用。比如文件操作的快捷按钮、分中标记、跨棱微调等按钮。 纯图标按钮，适合于一些比较通用的功能，并且仅仅通过图标即可让用户读懂，比如保存按钮、撤销按钮等。 特殊按钮，以上除外的功能快捷入口，在界面相应位置显示。 建议：此处可以添加一个图，把各种类型的按钮展示出来，放在一起，可以看到其差别性。 设计原则 按钮设计应该自带指导性，能够有效引导用户完成预期的行为。 按钮设计应该能够标识唯一性，避免引起歧义引起用户操作失误。 具体设计 常规按钮 必须遵守 无特别说明，界面大部分按钮都是常规按钮。 常规按钮的边框、圆角、左右&上下固定边距、最小长度、文字或图标对齐方式等按照组件库设计，不可随意修改，若需要修改需要提交软件部UI设计评审。 边框：1px；圆角：4px；最小间距：四周最小边距8px；左侧与上侧固定边距：4px；文字或图标对齐方式：居中对齐 可自定义 文字大小和颜色根据软件整体布局和页面设计进行自定义，推荐普通版文字大小：14pt。 正/反例&应用场景 正例【必须使用】 反例【禁止使用】 1.默认规格： 1.违反规格参数： 2.固定间距： 2.违反固定间距： 3.最小长度： 3.违反最小长度： 界面内应用 弹窗内应用 组件库链接 主控按钮 必须遵守 用于机床运动控制，包括开始、停止、暂停、断点继续四个按钮。 四个按钮都带图标（icon）和文字，且图标保持一致。 主控按钮的边框、圆角、左右&上下固定边距、最小长度、文字或图标对齐方式等按照组件库设计，不可随意修改，若需要修改需要提交软件部UI设计评审。 边框：1px；圆角：4px；最小间距：四周最小边距8px；左侧与上侧固定边距：4px；文字或图标对齐方式：居中对齐 可自定义 文字大小和颜色根据软件整体布局和页面设计进行自定义。 正/反例&应用场景 正例【必须使用】 反例【禁止使用】 1.默认规格： 1.违反规格参数： 2.最小间距： 2.违反最小间距： 3.显示规则： 3.违反显示规则： 界面内应用 组件库链接 待更新 辅控按钮 必须遵守 用于机床运动前、后的就绪功能按钮，一般包括回机械原点、回工件原点、仿真、空运行等按钮。激光应用和家装制造、金属切销有差别（参见通栏大按钮、通栏小按钮）。 按钮的边框、左右&上下最小边距、文字对齐方式等按照组件库设计，不可随意修改，若需要修改需要提交软件部UI设计评审。 边框：1px；上下最小边距：2px；左右最小边距：2px。 比例：等边矩形 可自定义 文字大小和颜色、图标根据软件整体布局和页面设计进行自定义，推荐普通版文字大小：14pt，推荐普通图标大小：32px 按钮可以在不违反最小间距的情况下，自由调整尺寸。 正/反例&应用场景 正例【必须使用】 反例【禁止使用】 1.默认规格： 1.违反规格： 2.间距规则： 2.违反间距： 界面内应用1 组件库链接 待更新 方向按钮 必须遵守 仅 手动模式 界面使用方向按钮。 方向按钮的边框、圆角、左右&上下固定边距、最小长度、文字或图标对齐方式等按照组件库设计，不可随意修改，若需要修改需要提交软件部UI设计评审。 边框：1px；圆角：4px；最小边距：8px；左侧与上侧固定边距：4px；按钮等边矩形比例；文字或图标对齐方式：居中。 可自定义 文字大小和颜色根据软件整体布局和页面设计进行自定义，推荐普通版文字大小：14pt。 正/反例&应用场景 正例【必须使用】 反例【禁止使用】 1.默认规格： 1.违反规格： 2.间距规则： 2.违反间距： 3.显示规则： 3.违反显示规则： 界面内应用1 界面内应用2 组件库链接 待更新 工艺控制按钮 必须遵守 仅用来标识工艺启停及当前状态。 状态按钮的边框、圆角、左右&上下最小边距、最小长度、文字或图标对齐方式等按照组件库设计，不可随意修改，若需要修改需要提交软件部UI设计评审。 边框：1px；圆角：4px；左右&上下最小边距：4px；状态灯左侧与上侧固定边距：4px；文字或图标对齐方式：居中。 可自定义 允许自定义高度与宽度，也不限制长宽比例，但注意按钮文字不能超过最小间距。 文字大小和颜色根据软件整体布局和页面设计进行自定义，推荐普通版文字大小：14pt。 正/反例&应用场景 正例【必须使用】 反例【禁止使用】 1.默认规格： 1.违反规格： 2.间距规则： 2.违反间距： 3.显示规则： 3.违反显示规则： 界面内应用1 界面内应用2 组件库链接 待更新 工艺控制按钮（带图标） 必须遵守 仅用来标识工艺启停及当前状态。 状态按钮的边框、圆角、左右&上下最小边距、最小长度、文字或图标对齐方式等按照组件库设计，不可随意修改，若需要修改需要提交软件部UI设计评审。 边框：1px；圆角：4px；状态灯左右与上侧固定边距：4px；文字与图标上下固定间距：2px；文字与图标整体在按钮内居中显示，与按钮上下左右最小边距：4px。 可自定义 允许自定义高度与宽度，也不限制长宽比例，但注意按钮文字不能超过最小间距。 文字大小和颜色根据软件整体布局和页面设计进行自定义，推荐普通版文字大小：12pt。 正/反例&应用场景 正例【必须使用】 反例【禁止使用】 1.默认规格： 1.违反规格： 2.间距规则： 2.违反间距： 3.显示规则： 3.违反显示规则： 组件库链接 待更新 选项卡按钮 必须遵守 模式切换必须使用选项卡按钮。 选项卡按钮的边框、圆角、左右&上下最小边距、文字对齐方式等按照组件库设计，不可随意修改，若需要修改需要提交软件部UI设计评审。 边框：1px；圆角：4px；最小边距：8px；左右最小边距：16px；上下最小边距：8px；文字对齐方式：居中。 模式切换按钮排列必须按照自动、手动和参考点顺序进行排列，不可随意修改，若需要修改需要提交软件部UI设计评审。 可自定义 文字大小和颜色根据软件整体布局和页面设计进行自定义，推荐普通版文字大小：14pt。 正/反例&应用场景： 正例【必须使用】 反例【禁止使用】 1.默认规格： 1.违反规格： 2.间距规则： 2.违反间距： 界面内应用 组件库链接 待更新。 通栏大按钮 必须遵守 只有主界面、XX界面才使用通栏大按钮。 通栏大按钮的边框、圆角、左右&上下最小边距、文字对齐方式等按照组件库设计，不可随意修改，若需要修改需要提交软件部UI设计评审。 边框：1px；圆角：4px；最小边距：8px；左右最小边距：28px；上下最小边距：10px。 展开icon左右固定间距：8px；文字对齐方式：居中。 按钮icon与文字组合时，文字必须和icon垂直居中。 多个按钮排列时，按钮之间不可留空隙。 可自定义 文字大小和颜色根据软件整体布局和页面设计进行自定义，推荐普通版文字大小：32pt/粗体。 按钮可以在不违反最小间距的情况下，自由调整尺寸。 通栏按钮排列顺序不做要求，可以根据需要进行调整，原则上参考已发布的大客户使用的最新版本。 正/反例&应用场景 正例【必须使用】 反例【禁止使用】 1.默认规格： 1.违反规格： 2.间距规则： 2.违反间距： 3.显示规则： 3.违反显示规则： 4.排列规则： 4.违反排列规则： 界面内应用 组件库链接 待更新 通栏小按钮 必须遵守 功能弹窗的快捷按钮、子功能快捷入口、分页按钮允许使用通栏小按钮。 通栏小按钮的边框、圆角、左右&上下最小边距、文字对齐方式等按照组件库设计，不可随意修改，若需要修改需要提交软件部UI设计评审。 边框：1px；圆角：4px；左右最小边距：16px；上下最小边距：10px。 展开icon左右固定间距：8px；文字对齐方式：居中。 多个按钮排列时，按钮之间不可留空隙。 可自定义 文字大小和颜色根据软件整体布局和页面设计进行自定义，推荐普通版文字大小：32pt/粗体。 按钮可以在不违反最小间距的情况下，自由调整尺寸。 通栏按钮排列顺序不做要求，可以根据需要进行调整，原则上参考已发布的大客户使用的最新版本。 正/反例&应用场景 正例【必须使用】 反例【禁止使用】 1.默认规格： 1.违反规格： 2.间距规则： 2.违反间距： 3.排列规则： 3.违反排列规则： 弹窗内应用 组件库链接 待更新。 功能入口按钮-大图标 必须遵守 主要应用在软件工具栏处，主要功能使用此类按钮。图标和文本是构成按钮的必要元素，缺一不可。 按钮的边框、左右&上下最小边距、文字对齐方式等按照组件库设计，不可随意修改，若需要修改需要提交软件部UI设计评审。 点击状态下：边框：1px；上下最小边距：2px；左右最小边距：2px；图标大小：32px 未点击状态下：图标大小：32px 可自定义 文字大小和颜色根据软件整体布局和页面设计进行自定义，推荐普通版文字大小：12pt。 按钮可以在不违反最小间距的情况下，自由调整尺寸。 正/反例&应用场景 正例【必须使用】 反例【禁止使用】 1.默认规格： 1.违反规格： 2.间距规则： 2.违反间距： 界面内应用1 组件库链接 待更新 功能入口按钮-小图标 必须遵守 软件功能-大图标按钮主要应用在软件工具栏处，次要功能使用此类按钮。图标和文本是构成按钮的必要元素，缺一不可。 按钮的边框、左右&上下最小边距、文字对齐方式等按照组件库设计，不可随意修改，若需要修改需要提交软件部UI设计评审。 边框：1px；上下最小边距：2px；左右最小边距：2px。 可自定义 文字大小和颜色根据软件整体布局和页面设计进行自定义，推荐普通版文字大小：12pt。 按钮可以在不违反最小间距的情况下，自由调整尺寸。 正/反例&应用场景 正例【必须使用】 反例【禁止使用】 1.默认规格： 1.违反规格： 2.间距规则： 2.违反间距： 界面内应用1 组件库链接 待更新 纯图标按钮 必须遵守 软件设置-图标按钮主要应用在软件菜单栏，用于控制基本文件操作，一般情况下只有单个图标元素。 按钮的边框、左右&上下最小边距、文字对齐方式等按照组件库设计，不可随意修改，若需要修改需要提交软件部UI设计评审。 边框：1px；上下最小边距：2px；左右最小边距：2px。 可自定义 颜色根据软件整体布局和页面设计进行自定义；推荐图标尺寸：16px。 按钮可以在不违反最小间距的情况下，自由调整尺寸。 正/反例&应用场景 正例【必须使用】 反例【禁止使用】 1.默认规格： 1.违反规格： 2.间距规则： 2.违反间距： 界面内应用1 组件库链接 辅助按钮 必须遵守 辅助按钮尽量少用，若需要新增需要提交软件部UI设计评审。 辅助按钮的边框、左右&上下最小边距、文字对齐方式等按照组件库设计，不可随意修改，若需要修改需要提交软件部UI设计评审。 边框：1px；上下最小边距：4px；左右最小边距：8px。 可自定义 文字大小和颜色根据软件整体布局和页面设计进行自定义，推荐普通版文字大小：12pt。 按钮可以在不违反最小间距的情况下，自由调整尺寸。 正/反例&应用场景 正例【必须使用】 反例【禁止使用】 1.默认规格： 1.违反规格： 2.间距规则： 2.违反间距： 3.延展规则： 界面内应用1 界面内应用2 组件库链接 待更新 待沟通确认，5-25，以下先暂时保留，祁彩云 1.就按钮元素来说，虽然类型不同，但是其有些通用的内容，比如以下 边框像素 圆角 颜色（边框色+底色+字体颜色） 最小长度、最小高度 左右边距，上下边距 内部图标/文字的对齐方式 按钮所在界面或者弹窗的位置 按钮文字内容描述和图标的设计要求 特殊情况，根据类型不同，会有不同，单独来写 带状态按钮的icon位置、上下左右边距 多个按钮组合的分布 有图标+文字内容的间距和对齐方式"
  },
  "doc/UI设计规范/通用类元素规范/文字.html": {
    "href": "doc/UI设计规范/通用类元素规范/文字.html",
    "title": "文字",
    "keywords": "文字 文字是界面内的基础元素之一，是用户了解软件和完成操作的重要渠道，保持文字系统的一致和稳定，能更好的划分页面功能逻辑，提升用户体验和使用。 字体类型 文字定义了以下几种类型，从字体，字重，字号，行高、颜色五个属性明确规格。 常规文字，包括以下四种： 标题-普通，界面复合控件或弹窗的主题类型的文字，比如主界面标识自动&空闲状态的字体，比如坐标控件的轴名称和坐标类型的文字。 正文-普通，主界面菜单、复合控件或弹窗的正文文字，比如加工统计控件的文字，参数界面的参数具体名称及描述文字。 正文-强调，主界面、弹窗及各种控件内需要重点强调，引起用户重视的文字，比如坐标轴信息，紧停文字。 正文-次级，部分产品的主界面菜单、二级界面菜单、功能入口等由于受设计版面限制的文字。 特殊文字 标题-特殊，特殊的告警类文字，比如日志控件的警告标识。 正文-特殊，特殊按钮的文字，比如快捷键按钮如仿真加工按钮的文字，标识翻页功能按钮的文字。 文本-按钮，使用文本按钮的情况，才可以使用，当前仅在翻页文本控件使用，少用或慎用。 以下是现有文字使用情况的划分与说明： 设计原则 即使公司各个产品线的产品形态不同，布局和整体设计不同，但同一产品/系统的文字要保持一致性。 少即是多，遵循极简法则，尽量用极少的风格进行文字的视觉设计，避免使用大量文字类型、比例、颜色和粗细来强调视觉或对比关系。 具体设计 常规文字 【标题-普通 】 主、子界面、弹窗内的常规标题，必须使用该文字类型。 字体：默认使用微软雅黑；字号：14pt；字重：加粗；字重和颜色在特殊情况下允许自定义；行高采用默认值。 应用场景 界面内应用1 界面内应用2 【正文-强调 】 主、子界面、弹窗内的需要重点强调的正文，可使用该字体。 原则上正文少用、慎用该字体，特殊情况下如：重点参数展示、重点结果/操作展示、紧停重要信息可以使用。 字体：默认使用微软雅黑；字号：14pt；字重：加粗；字重和颜色在特殊情况下允许自定义；行高采用默认值。 应用场景 界面内应用1（重点参数展示） 界面内应用2（重点结果/操作展示） 【正文-普通 】 主、子界面、弹窗内的正文，除强调外，必须使用该字体。 字体：默认使用微软雅黑；字号：14pt；字号：常规；字重和颜色在特殊情况下允许自定义；行高采用默认值。 应用场景 界面内应用1 界面内应用2 【正文-次级 】 原则上任何界面的正文，优先要求使用【正文-普通】字体，若该文本优先级低，且受空间限制的情况下，可使用该字体。 字体：默认使用微软雅黑；字号：12pt；字重：常规；字重和颜色在特殊情况下允许自定义；行高采用默认值。 应用场景 界面内应用1（文本优先级稍低） 界面内应用2（空间受限-文本紧密排列） 特殊文字 【标题-特殊】 原则上界面上的常规标题，优先要求使用【标题-普通】文字类型，若该标题需要重点引起重视，可以使用该类型。 当前仅“警告”模块的标题使用该文字，请勿随意使用本类型。 字体：默认使用微软雅黑；字号：20pt；字重：加粗；字重和颜色在特殊情况下允许自定义；行高采用默认值。 应用场景 界面内应用 【正文-特殊 】 原则上界面上的常规，优先要求使用【标题-普通】，若该标题需要重点引起重视，可以使用该类型。 原则上正文少用、慎用该类型，当前仅底部“快捷按钮”的内容使用该类型，请勿随意使用。 字体：默认使用微软雅黑；字号：20pt；字重：常规；字重和颜色在特殊情况下允许自定义；行高采用默认值。 应用场景 界面内应用 【文本按钮】 使用文本按钮的情况，才可以使用，当前仅在翻页文本控件使用，少用或慎用。 字体：默认使用微软雅黑；字号：14pt；字重：常规，文字下方添加下划线；字重和颜色在特殊情况下允许自定义；行高采用默认值。 应用场景 界面内应用"
  },
  "doc/UI设计规范/通用类元素规范/色彩.html": {
    "href": "doc/UI设计规范/通用类元素规范/色彩.html",
    "title": "色彩",
    "keywords": "色彩 颜色不仅仅用来传达品牌风格，还可以给予信息反馈，同时可以通过不同的颜色进行层级分类，状态标识，帮助用户提取有效的信息。 色彩类型 品牌主色，一套产品只有一个品牌主色，是界面中出现最多的颜色，品牌主色定义产品的风格，比如激光黑色为品牌主色，金属切削和木工产品的品牌主色为灰色。 中性色，一般为文字的颜色，中性色还被大量运用在分割线、边框、背景等场景中。 语义色，一般为功能色，给予用户有效反馈信息，比如开始加工按钮的绿色，停止和禁停按钮的红色，不同等级的警告信息采用红、黄、黑等颜色。 设计原则 数控系统色彩风格追求简洁，在进行整体布局设计，避免追求个人的设计风格，尽量减少配色，尽量和已有产品的品牌风格一致。 局部风格要和整体风格一致，文字追求少即是多大原则。 详细设计 品牌主色 主界面及窗口主题色，不同产品主题色不同，目前产品主题有黑色和灰色。 公司Logo必须使用品牌色。 品牌色 灰色也是品牌色？ 中性色 中性色普遍运用在各种通用文字、边框等的基础颜色。 使用场景 文字用色 边框用色 分割用色 背景用色 语义色 必须遵守 标识启动加工、加工停止、禁停或者其他标识状态的必须使用语义色。 除此之外的慎用语义色。 开始-默认使用【标准】 暂停-默认使用【标准】 继续-默认使用【标准】 停止-默认使用【标准】 警告-默认使用【标准】 使用场景 开始- 禁止、标准、按下 暂停- 禁止、标准、按下 停止- 禁止、标准、按下 继续- 禁止、标准、按下 按钮状态色（参考方案） 可参考 此处提供深色和浅色软件界面情况下，按钮的选中、点击、禁用等状态的颜色。 供参考，不做强制要求。 深色界面-蓝色配色方案 应用效果 深色界面-绿色配色方案 应用效果 浅色界面-蓝色配色方案 应用效果 绿色界面-绿色配色方案 应用效果"
  },
  "doc/研发文档编写指南/md文件格式/基本语法.html": {
    "href": "doc/研发文档编写指南/md文件格式/基本语法.html",
    "title": "基本.md语法",
    "keywords": "基本.md语法 markdown语法 Markdown，这是一种简单易用的标记语言，您可以使用它来格式化几乎任何文档。 见链接 https://www.markdownguide.org/ 基本语法 github 链接： https://github.com/mattcone/markdown-guide/tree/master/_basic-syntax 扩展语法 github 链接： https://github.com/mattcone/markdown-guide/tree/master/_extended-syntax DFM DocFX 支持DocFX Flavored Markdown，又名 DFM。它支持所有GitHub Flavored Markdown语法并与 CommonMark 兼容。此外，DFM 添加了新语法以支持其他功能，包括交叉引用和文件包含。 见链接： https://dotnet.github.io/docfx/spec/docfx_flavored_markdown.html"
  },
  "doc/研发文档编写指南/md文件格式/增强可读性语法.html": {
    "href": "doc/研发文档编写指南/md文件格式/增强可读性语法.html",
    "title": "增强可读性语法",
    "keywords": "增强可读性语法 警示信息（Alert） 使用不同的警示信息将会在文档中呈现不同的颜色标记，以此用来区分警示信息的重要程度。Typora编辑器则不能够直接显示预览效果，使用VSCode可以预览效果或者通过Docfx转换后的文档则可以显示。 特别提示 Note 即使是略读也应该关注的特别信息。（Information the user should notice even if skimming.） 小贴士 Tip 想更深入理解文档需要的提示信息。（Optional information to help a user be more successful.） 重要提醒 Important 用户不能够忽略的关键信息。（Essential information required for user success.） 注意事项 Caution 操作失误可能引起的潜在风险。（Negative potential consequences of an action.） 警告 Warning 操作失误将会导致触发风险。（Dangerous certain consequences of an action.） 部分文字强调 粗体 这个文本是 粗体 。 斜体 这个文本是 斜体 。 粗体&斜体 这个文本是 粗体&斜体 。 代码块 CSharp代码块 public static void Log(string message) { _logger.LogInformation(message); } 反斜杠转义 有些字符本身就是markdown的标签，如果文档中需要正常显示该字符，而并非作为标签使用，则可以用反斜杠“\\”来转义该字符。 以下尖括号无需在格式为内联代码的文本中或在代码块中进行转义。使用 \\<script name>，或者 将 <script name> 编码为 &lt;script name&gt; 以下字符可以通过反斜杠进行转义 \\；`；*；_；{ } ；[ ]；< >；( )；#；+；-；.；!；| 高亮 没有哪一种深度工作习惯上绝对正确的—— ==一种习惯是否合适取决于个人，同时也取决于从事的项目类型。== 没有哪一种深度工作习惯上绝对正确的—— ==一种习惯是否合适取决于个人，同时也取决于从事的项目类型。== 遗留问题：高亮显示为啥不正常？评审时间：2022-5-7 责任人：祁彩云 上标 X^3^ X的3次方，X^3^。 下标 H~2~O 水的化学表达式，H~2~O 遗留问题：上下标显示为啥不正常？评审时间：2022-5-7 责任人：祁彩云 删除线 ~~要在提倡专注还是意外发现之间作出选择，暗示了深度工作（个体努力）无法与创造性洞见（协作努力）相容。~~ 这句话是有缺陷的。 要在提倡专注还是意外发现之间作出选择，暗示了深度工作（个体努力）无法与创造性洞见（协作努力）相容。 这句话是有缺陷的。 扩展列 列应仅包含基本的 Markdown（包括图像）。 不应包含标题、表、选项卡和其他复杂结构。 行不能包含列中没有的任何内容。 :::row::: :::column span=\"2\"::: This is a 2-span column with lots of text. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec vestibulum mollis nunc ornare commodo. Nullam ac metus imperdiet, rutrum justo vel, vulputate leo. Donec rutrum non eros eget consectetur. :::column-end::: :::column span=\"\"::: This is a single-span column with an image in it. ![Doc.U.Ment](media/markdown-reference/document.png) :::column-end::: :::row-end::: 遗留问题：为啥显示不正常？评审时间：2022-5-9 责任人：祁彩云 脚注 Facebook当然会为我们的社交生活带来益处，但是这些对我们的社交生活来说都还没有重要到将自己的时间和注意力投入其中的程度。[^1] 关键少数法则-在许多情境中，80%的已知效果源自20%的可能原因。[^bignote] [^1]: 正是基于这种分析，我才没有使用Facebook。我从来没有注册账号，肯定也错过了很多上面总结的小的益处，但是这样做在任何层面上都没有影响我保持积极有益的社交生活。 [^bignote]: 这种理念有很多中形式和名称，包括80/20法则，帕累托法则。 如果想再高级一点，可以将其称作因素系数法制。 Facebook当然会为我们的社交生活带来益处，但是这些对我们的社交生活来说都还没有重要到将自己的时间和注意力投入其中的程度。 ^1 关键少数法则-在许多情境中，80%的已知效果源自20%的可能原因。 ^bignote"
  },
  "doc/研发文档编写指南/仓库及发布工具/Docfx.html": {
    "href": "doc/研发文档编写指南/仓库及发布工具/Docfx.html",
    "title": "Docfx 工具",
    "keywords": "Docfx 工具 简介 DocFx是微软推出的一款一个可扩展和可扩展的静态文档生成器。 它使您可以非常轻松地从各种来源生成具有登录页面、API 参考和概念文档的开发人员中心。 参考 ： https://dotnet.github.io/docfx/ github : https://github.com/dotnet/docfx 使用 具体如何使用请参见官方文档： https://dotnet.github.io/docfx/ 公司的研发文档会结合模板使用， 本文着重说下注意点： docfx.json文件相关 具体模板见： https://github.com/weihong-phoenix/DevDocContribute/blob/main/docfx.json build/template节点：除了添加默认的（default）， 还需要增加我们自定义模板的路径（相对docfx.json文件）。 pdf/template节点： 他的默认模板为pdf.default。 运行相关 前置条件： 安装 choco 工具， 参考这里 Step 1: 安装docfx choco install docfx Step 2: 编译站点 切换当前目录到仓库根目录 docfx build Note 由于mermaid的展示及pdf导出需要使用到plugin， 当您运行docfx build时， 可能会提示目录没有权限。 这时， 需要将终端采用管理员运行即可。 Step 3: 运行web服务 切换当前目录到仓库根目录。 该命令仅仅将_site目录作为web站点发布。 docfx serve _site Step 4: 打开浏览器， 输入： http://localhost:8080/"
  },
  "doc/研发文档编写指南/仓库及发布工具/git&github.html": {
    "href": "doc/研发文档编写指南/仓库及发布工具/git&github.html",
    "title": "git&github",
    "keywords": "git&github 简介 git使用 不了解Git请查看 权威Git书籍 ProGit（中文版） 。 github 详细请参考 github的官方文档 。 快速在线管理github项目文件 之前查看github上的项目文件， 除了一级一级文件点击进去查看外。 github还提供了vs code在线项目查看。 只要在github项目上触发快键键（.)。 更多github键盘快捷键 参考链接"
  },
  "doc/研发文档编写指南/仓库及发布工具/VSCode.html": {
    "href": "doc/研发文档编写指南/仓库及发布工具/VSCode.html",
    "title": "VSCode",
    "keywords": "VSCode 简介 由于公司采用docfx生成研发文档， 推荐采用VS Code编写研发文档， 搭配微软提供的VS Code插件Docs Authoring Pack github链接 . 优势如下： 展示层面： 告警标签与微软官方表现一致（typora不支持） 支持图表（mermaid） 编辑层面 支持快捷键插入告警标签 常用快捷键 Ctrl+K Ctrl+R : 展示vscode 键盘快捷方式参考， 会通过浏览器打开一个pdf， 如下图: F1 或 Ctrl+P: 调用主命令框 Ctrl+K Ctrl+S: 键盘快捷方式 Alt+D P：md预览 (中文输入法下不成功， 建议将快捷键换成Alt+D Alt+P. PS) 使用快捷键Ctrl+D+A， 快速输入Caution标签 输入快捷键Ctrl+K+S, 调出 键盘快捷方式 ， 修改命令Docs:Alert的快捷键绑定。 使用快捷键Ctrl+D+A， 选择Caution选项。 文档中就生成了如下文字： Caution Negative potential consequences of an action VSCode支持粘贴图片 由于之前习惯使用typora， 截屏后直接可以复制截屏图片到文档中， 但VScode自身不支持该操作。 但强大的VScode插件可提供。 推荐 Paste Image , 在扩展中（Ctrl+Shift+X)中搜索。 安装后， 可以在VS code的设置（Ctrl+,)中搜索pasteImage， 设置图片复制的默认路径。"
  },
  "doc/研发文档编写指南/具体文档编写参考/README-编写指导.html": {
    "href": "doc/研发文档编写指南/具体文档编写参考/README-编写指导.html",
    "title": "README-编写指导",
    "keywords": "README-编写指导 关于该文档 根据《软件项目目录及文件管理规范-3.1》文档内容，MSF 在展望历程的关键输出文档远景/范围文件，其包含的内容对于概括性了解整个项目也很重要，因此这些内容就应作为 README.md 的主体而存在。 文档内容 必须有 概述 远景/使命 远景是一份简明的、以商业术语来撰写的全体使命描述。 高层需求 高层需求是将远景界定成可交付产品的一种描述方式。它们都是一些简短的陈述，说明解决方案 该做什么 ，而不是 怎么做 ——那些都将留给后面的实现细节。 撰写需求： 高层需求可以表示为功能性（例如：在保险项目中数据录入表格的新政策），及应用在功能性上的规则和参数（比如保单持有者的每一项特定资产只能有一张保单）。和其他任何需求一样， 高层需求需要做到“ SMART ”，即明确（specific）、可测量（measurable）、可完成（achievable）、 面向结果（result-oriented）、有时间限制（time-bounded）。 用户分类 想要建立用户信息，团队需要确认用户的类别（比如远程用户），用户类别是通过用户的活动及与解决方案互动的类型来区分的。按照技能水平将用户进一步细分可能也是必要的（比如高级会计经理）。如果可能的话，把用户对于解决方案的期望添加进去会有一定的用处。 设计策略 架构设计策略 一个架构设计策略描述解决方案的不同方面如何一同运作。 技术设计策略 技术设计策略描述了实现架构设计策略时可能用到的技术。它是在考虑构建解决方案时可能用到的关键产品和技术的高层描述。 验收标准 验收标准定义了验收人员在签收解决方案时必须满足的条件、状况和准则。它们代表解决方案已经符合原先达成协议的需求与条件。MSF 有 3 类验收标准，分别是： 用户验收标准 一般情况下，从最终用户的角度出发，用户验收标准专注于易用性和功能方面。 运维验收标准 典型的运维验收标准注重运维的准备就绪（比如运维和支持团队的培训），部署和服务质量。 客户验收标准 客户验收标准为客户验收解决方案建立了要满足的条件和状况（例如：成功部署完成后，客户便拥有该解决方案），并确立了在项目结束时期望会有哪些附属产品（比如学到的经验）。 有最好 参考案例 http://tfs.weihong.com:8080/tfs/Wooding/Home_Decoration/_git/BridgeCutter?path=%2FREADME.md&version=GBmaster&_a=preview"
  },
  "doc/研发文档编写指南/具体文档编写参考/risk-编写指导.html": {
    "href": "doc/研发文档编写指南/具体文档编写参考/risk-编写指导.html",
    "title": "risk-编写指导",
    "keywords": "risk-编写指导 关于该文档 根据《MSF 详细活动指导》文档内容，MSF 在展望历程所有风险的确定都要文档化，将其记录在初始的风险评估文档中。这个文档构成了后续风险管理的基础。 文档内容 必须有 着重识别出 3 个最高优先级的风险 参考案例 http://tfs.weihong.com:8080/tfs/Wooding/Home_Decoration/_git/BridgeCutter?path=%2Fpm%2Frisk.md&version=GBmaster&_a=preview"
  },
  "doc/研发文档编写指南/具体文档编写参考/roles-编写指导.html": {
    "href": "doc/研发文档编写指南/具体文档编写参考/roles-编写指导.html",
    "title": "roles-编写指导",
    "keywords": "roles-编写指导 关于该文档 文档内容 必须有 有最好 参考案例 http://tfs.weihong.com:8080/tfs/Wooding/Home_Decoration/_git/BridgeCutter?path=%2Fpm%2Froles.md&version=GBmaster&_a=preview"
  },
  "doc/研发文档编写指南/具体文档编写参考/SRS-编写指导.html": {
    "href": "doc/研发文档编写指南/具体文档编写参考/SRS-编写指导.html",
    "title": "SRS-编写指导",
    "keywords": "SRS-编写指导 关于该文档 根据《MSF详细活动指导-1.0》，srs 前两章需要按照 GBT-9385（2008，计算机软件需求规格说明书规范）标准编写，以下内容给予对该标准的分析，提炼出各个章节的内容概要。 标准内容 因第三章节不同平台及产品线的产品对象及其形态不同，文档编写方式当前较难做到通用，因此本文档暂时仅包括对 GBT-9385 前两章节内容的编写内容指导。 1 引言 1.1 目的（Purpose） 描述 SRS 文档的阅读用户及阅读重点。 概要描述 SRS 文档解决用户什么问题，属于主观愿望。 本章节由产品管理编写或分担其功能领域的角色。 易出现问题：阅读用户和产品使用者混淆，srs 的主要用户是内部研发、测试、UE 和程序管理等团队成员，而不是产品的使用者，请在这里描述阅读者及建议的阅读重点。 1.2 范围（Scope） 精确描述要研发的产品（软件）名称；（后续统一称为产品） 概要描述该产品具备的能力，将做什么或者不做什么； 易出现问题：不做什么容易遗漏，或者会觉得不必要。目前建议尽量去思考下，有的话写上，可以让阅读者更清楚该产品的实现边界。 1.3 定义、缩写和缩略语（Definitions and Acronyms） 解释 SRS 文档用到的术语、简写和略缩语的定义，格式建议：XXXX-XXXX-XXXX，术语/略缩语/简写-描述-参考文献/标准。 1.4 引用文件 提供该 SRS 引用的所有文件的完整清单，格式建议：XXXX-XXXX-XXXX-XXXX-XXXX，名称-描述-版本-更新日期-归属团队。 1.5 综述 概要描述本文档其余各个章节包含的内容及组织方式。 2 总体描述 2.1 产品全景 全景级别的描述产品的结构，推荐使用框图/结构图，描述产品内部组成图、上下文图及外部系统之家的关系。 产品在各种约束条件下如何运行，包括系统接口、用户界面、硬件接口、软件接口、通讯接口、内存、运行条件等，如果该部分内容比较多，可以在下面分章节描述。 以下章节都属于概要性的信息，详细需求会在具体需求里面描述，此处以较高层次对需求进行概括性的总结。 如果如果某些项目该部分确实没有，可以写\"无\"。有些是前期未能够识别的，可以先标注TBD，后期遇到问题再补充。 易出现问题：比较纠结到底写多细才好。这里是产品概述，通过和郑博沟通，我们认为用全景比较合适，是站在一个高度、不要钻到细节层面去描述，系统和系统、子系统和子系统、系统和子系统之间的关系，一般就是用结构图的形式，比较直观的呈现即可。 2.1.1 系统接口 系统接口可以从以下几个维度去思考，用户界面、硬件接口、软件接口、通信接口、内存等等，不同系统各有差异， 常见问题：Q：什么情况需要写？ A：组合的复杂的系统，有多个子系统或者大的软件功能，以及涉及到之间的接口交互，应该对其接口进行描述。 2.1.2 用户界面 定义：用户界面是指用户对界面的图形化方式、屏幕布局、标准按钮、告警显示方式、指示灯等外观视觉特征的要求，并不需要罗列真实的用户界面。 将要采用的图形用户界面（GUI）标准、产品系列的风格。 屏幕布局或解决方案的限制。 快捷键。 错误信息显示标准。如果公司或者团队有“产品级的用户界面标准”，可以直接引用，“产品级的用户界面标准”未描述到个性化的/额外的用户界面要求，可以在此描述。 评审决议：如果该用户界面不是用户直接提出或者经过充分分析确定的最终界面，不要在 SRS 里面呈现，先描述为用户故事。（用户界面某种程度上属于方案。基本步骤：1-先描述用户故事；2-再画原型图；3-最后设计最终的用户界面） 2.1.3 硬件接口 顾名思义，描述系统连接的硬件接口，概要描述即可，比如需要支持二代朗达 LD21E 及 LD21E-04 控制器。 常见问题：Q：什么情况需要写？A：产品不仅仅是软件系统，也包括实现产品功能所需要的硬件系统或组件，则需要对软硬接口进行描述。 2.1.4 软件接口 描述产品涉及到其它软件系统。 常见问题：Q：什么情况需要写？A：产品需要对其他软件产品使用，a）对于使用的其他软件产品，应明确其名称、助记符、编号、版本号、来源等； b）对产品的具体使用的接口应进行定义，包括接口描述、接口目的、格式等，对于已经文件化的接口，可以直接引用即可。 2.1.5 通信接口 定义网络通信接口或协议。 2.1.6 内存 描述本产品对于内存的使用特征和限制。 2.1.7 运行 描述本产品运行所需要的环境等信息。 2.1.8 现场适应性需求等 其它现场环境相关的信息。 2.1.9 其它 除模板里面建议描述的，如果有额外的，可以自行补充，比如操作等。 2.2 产品功能 概要描述产品主要功能、性能指标、软件系统属性（质量属性）、外部接口等，详细内容在[3 具体需求]章节描述，本章节将不涉及功能细节。（高层需求推荐采用用户故事的格式描述）。格式建议：XXXX-XXXX，功能名称-功能概述。 2.3 用户特点 描述使用该产品的不同用户信息及特征，格式建议：XXXX-XXXX，使用用户-特殊说明。 2.4 约束 研发该产品的限制条件，如法规政策、硬件局限、保密安排、技术相关标准（协议）、运行环境等，这些相关的内容是影响产品的障碍和局限，如果不重视则会导致风险。 2.5 假设与依赖关系 描述影响 SRS 规定需求的各个因素，该因素因为存在不确定性，其变更将会影响 SRS 的变更。假设和依赖没有问题，则产品质量或者项目交付时间将可能没有问题；如果假设和依赖有问题，则产品质量或者项目交付时间很大程度有问题。 2.6 需求分配 未来需求。可以填写“无”。 3 具体需求 描述足够详细的需求，使设计人员能够设计系统以满足这些需求，使测试人员能够测试系统以验证满足这些需求。至少应该包括输入、输出及处理输入以达到满足输出的所有逻辑。 输入/输出需要有明确的类型/格式、范围、输入个数。 处理逻辑需要包含正常处理和异常处理。 3.1 外部接口需求 详细描述产品所有的外部输入及输出，同时提供包括用户界面、硬件接口、软件接口、通信接口等的详细描述及基本的用户界面原型。 2.1是概要的描述，这里是详细的描述。 3.2 功能需求 该部分暂不做要求。 参考案例 http://tfs.weihong.com:8080/tfs/Wooding/Home_Decoration/_git/BridgeCutter?path=%2Fdoc%2Fsrs&version=GBmaster&_a=contents"
  },
  "doc/研发文档编写指南/具体文档编写参考/stakeholder-编写指导.html": {
    "href": "doc/研发文档编写指南/具体文档编写参考/stakeholder-编写指导.html",
    "title": "stakeholder-编写指导",
    "keywords": "stakeholder-编写指导 关于该文档 根据《MSF 详细活动指导》文档内容， 文档内容 必须有 种子客户；行业头部客户作为种子客户为佳 有最好 种子客户的沟通计划 参考案例 http://tfs.weihong.com:8080/tfs/Wooding/Home_Decoration/_git/BridgeCutter?path=%2Fpm%2Fstakeholder.md&version=GBmaster&_a=preview"
  },
  "doc/研发文档编写指南/具体文档编写参考/技术方案编写指导.html": {
    "href": "doc/研发文档编写指南/具体文档编写参考/技术方案编写指导.html",
    "title": "",
    "keywords": "TODO"
  },
  "doc/研发文档编写指南/具体文档编写参考/用户手册编写指导.html": {
    "href": "doc/研发文档编写指南/具体文档编写参考/用户手册编写指导.html",
    "title": "",
    "keywords": "TODO"
  },
  "doc/研发文档编写指南/布局及格式/元数据.html": {
    "href": "doc/研发文档编写指南/布局及格式/元数据.html",
    "title": "元数据",
    "keywords": "元数据 元数据用来标识文档的基本信息，诸如文档标题、作者、归属主题或关键字信息，通过该信息可以快速检索到相关文档。建议所有文档都需要标识元数据。 以下是应用在 Markdown 文章的 YAML 扉页中的元数据示例： title:XXXXX # the article title to show on the browser tab description:XXXXX # 115 - 145 character description to show in search results author: {github-id} # the author's GitHub ID - will be auto-populated if set in settings.json ms.author: {ms-alias} # the author's Microsoft alias (if applicable) - will be auto-populated if set in settings.json ms.date: {@date} # the date - will be auto-populated when template is first applied ms.topic: getting-started # the type of article 必须元数据 标题,该文档的标题，用于搜索的重要元数据。 描述，内容摘要，用于搜索结果呈现的重要元数据。 作者，编写人员，为文档的内容质量负责，后续遇到文档相关文档可以咨询，如果该作者离职，应该做人员交接变更，添加新的作者。 日期，文档最新发布日期，标识文档最新状态的时间。 主题，文档类型，描述文档归属，目前包括SRS、用户手册、技术方案。 可选元数据 团队，文档归属团队，作者本人可能不归属于该团队的情况要添加归属团队。 评审者，审阅该文档的评审专家或者团队。"
  },
  "doc/研发文档编写指南/布局及格式/标题.html": {
    "href": "doc/研发文档编写指南/布局及格式/标题.html",
    "title": "标题",
    "keywords": "标题 文档的标题作为文档的内容分类， 可以很好的提示读者。 标题层级 文档中的标题层级严禁 超过四级 。所有文档的标题都必须从 一级标题 开始，逐级递增使用，禁止跳级。 <!--所谓跳级，比如：直接从二级标题开始；一级标题下面直接用三级标题等情况。--> 一级标题：即本.md文档标题。 可以和目录名称一致。 文档中若没有其它层级分类，可仅有一级标题，直接接正文描述。 二级标题：文档正文部分的标题。 二级标题根据文档内容可以有多个，比如描述功能规格的，包括概述、场景、参数等，则同为二级标题。 可仅有一级、二级标题。 三级标题：二级标题下面一级的小标题。 三级标题根据文档内容可以有多个，比如场景描述可以分为正常场景、异常场景，则同为三级标题。 一般文档三级标题即可完成对正文比较逻辑性的描述，不宜采用四级标题。 四级标题：三级标题下面一级的小标题。但特殊情况，可采用四级标题。 除一级标题可以仅存在一个，其它级别的标题至少有两个，即一级标题之后，不能够只有一个二级标题，此种情况直接为正文，其它级别同理。 <!--本文档标题层级按照该要求编写。--> 注意 ： 任何等级标题后面禁止带标点符号。 > 反例：“## 标题的编号：”。 文档名称和标题都禁止编号，若需要编号，可以在配置文件toc.yml中编辑name标签，而内容顺序同样通过toc进行配置即可。 > 反例：“1 引言； 1.1 目的；1.2 范围”。"
  },
  "doc/研发文档编写指南/布局及格式/正文格式.html": {
    "href": "doc/研发文档编写指南/布局及格式/正文格式.html",
    "title": "正文格式",
    "keywords": "正文格式 标题之外，统称为正文。正文通过段落描述文档的具体内容，而在段落中间有些特殊的文字需要标识，突出文本的重点或者需要重视的部分。 段落 段落是根据文档或描述的功能的内容，划分的相对独立的部分。是构成正文的基本单元之一，由多个句子组成。 段落一般要求如下： 一个段落只能有一个主题，或一个中心句子。 段落的中心句子建议放在段首，对全段内容进行概述。后面陈述的句子为核心句服务。 段落的长度没有严格的要求，但是建议尽量不要连续超过3行。 一个段落里避免只有一个句子。如果句子很长，要避免” 一逗到底 ”的情况，合理断句。 段落之间一个回车即可（.md格式），该默认的段落间距已考虑到可读性。 段落的句子语气应该使用陈述和肯定语气，避免使用感叹语气。 技术文档的段落开头不建议缩进，顶格开始即可。 对于技术描述类主题，应考虑先图表，后句子的原则，不要单一地使用段落来陈述主题。 粗体 适用于描述界面的元素，比如：菜单选项、对话框名称和输入字段名称时使用粗体；或者部分词语或者句子需要强调，需要引起读者一定程度的重视等情况。 正例：点击 开始 按钮， 启动自动加工。 斜体 适用于描述以下内容时使用斜体： 带有定义或解释的新术语简介。 文件名称、文件夹名称、路径。 用户输入。 > 正例：将 D:\\Weihong\\NcStudio\\ActiveConfig 复制到优盘中。 告警标签 警告 适用于描述如果错误操作，则可能导致操作人员伤亡或设备损坏。 Warning 尚未建立机械坐标系的情况下，不能正确进行行程极限检查。请在通电后重新建立连接后，执行了回参考点的状态下执行高速程序检测。 注意 适用于描述如果错误操作，则有可能导致操作无法完成。 Caution 在向外部I/O装置存取期间，请勿切断CNC的电源或拆除外部I/O装置。否则将会损坏外部I/O装置。 备注 适用于除警告和注意以外的补充说明。 Note USB存储器的可用空间不多或者文件数量较多时，向USB存储器的文件输入/输出操作有时需要一定的时间。这种情况下，请删除USB存储器中不需要的文件后再度进行操作。 在编写引用及告警标签时， 须保证与后续段落间保持一个空行 。 【】括号 各种规范文档中涉及到的【原则】和【规则】，用中括号标识。 举例：【规则】： 选项与对应的数值之间用冒号“：”，不得使用“表示/为/是”等字眼； 标点符号 段落结尾用句号 “。” 结束，即使是项目符号后的短句子，不能没有标点符号或者用“；”的情况。 举例：斜体适用于描述以下内容时使用斜体： 带有定义或解释的新术语简介。 文件名称、文件夹名称、路径。 用户输入。"
  },
  "doc/研发文档编写指南/布局及格式/过程批注.html": {
    "href": "doc/研发文档编写指南/布局及格式/过程批注.html",
    "title": "过程批注",
    "keywords": "过程批注 文档编写和维护过程中需要添加的一些过程信息，便于文档发布前修改和优化，统称为过程批注。过程批注在文档基线或发布后可以删除。 待讨论话题 若有内容暂不确定，需要进一步的私下沟通、小组讨论等方式进一步的确认，应使用标签 【引用】进行标识，格式要求如下： 待讨论，时间：2022-4-21 责任人：祁彩云 暂未完成 若有内容确定要写，但因优先级低或者其它原因暂未开始或者未完成状态，应使用标签 【引用】进行标识，格式要求如下： TODO，时间：2022-4-24 责任人：祁彩云 评审批注 评审决议 文档经过讨论或者评审后需要根据决议进行相应修改的，应使用【引用】进行标识，格式要求如下： 评审决议：XXXXXXXXX，评审时间：2022-4-23 责任人：祁彩云 评审遗留问题 文档经过讨论或者评审后仍存在一些遗留问题，应使用【引用】进行标识，意味着仍需要进一步的确认和再次的评审，格式要求如下： 遗留问题：XXXXXXXXX，评审时间：2022-4-23 责任人：祁彩云 发现缺陷 文档中发现缺陷，应使用【引用】进行标识，格式要求如下： 缺陷：XXXXXXXXX，发现人：胡凯烽，修改人：祁彩云 其它说明 除以上情况的其它说明，应使用【注释】进行标识，格式要求如下： <!--注释：XXXXXXXXXXXXXXXXXXXXXXXXXX-->"
  },
  "doc/研发文档编写指南/引言/用词说明.html": {
    "href": "doc/研发文档编写指南/引言/用词说明.html",
    "title": "用词说明",
    "keywords": "用词说明 为了便于在执行本标准条文时区别对待，对要求严格程度不同的用词说明如下： 表示很严格，非这样做不可的用词：正面词采用“必须”，反面词采用“严禁”； 表示严格，在正常情况下均应这样做的用词：正面词采用“应”，反面词采用“不应”或“不得”； 表示允许稍有选择，在条件许可时首先应这样做的用词：正面词采用“宜”，反面词采用“不宜”； 表示有选择，在一定条件下可以这样做的用词，采用“可”。 Note 《软件项目目录与文件管理规范-R3.1》文档由软件部维护和发布，请参考当前最新版本。"
  },
  "doc/研发文档编写指南/引言/目的.html": {
    "href": "doc/研发文档编写指南/引言/目的.html",
    "title": "目的",
    "keywords": "目的 为了统一公司文档风格，提高文档的可读性，确保公司对内、外输出的各种类型的研发文档能够一致，便于阅读理解，减少不必要的沟通成本，提高文档的可复用性。 本文档的主要阅读对象如下： 文档编写人员 SRS编写人员（如产品管理、架构、开发及UE） 用户手册、技术方案等文档编写人员 文档使用者及评审人员 参与文档评审的人员（如测试、UE及相关编写人员）"
  },
  "doc/研发文档编写指南/引言/范围.html": {
    "href": "doc/研发文档编写指南/引言/范围.html",
    "title": "范围",
    "keywords": "范围 本指南规范了维宏研发文档的风格和基本编写要求。主要包含以下几个章节进行描述： 目录结构及命名 布局及格式 表达风格 具体章节编写参考 文档格式-Markdown语法 仓库及发布工具 也希望大家在使用过程中多多提出建议，共同持续改进该指南，为公司的文档标准化共同努力。"
  },
  "doc/研发文档编写指南/目录结构及命名/目录命名.html": {
    "href": "doc/研发文档编写指南/目录结构及命名/目录命名.html",
    "title": "目录命名",
    "keywords": "目录命名 不同文档的目录命名不尽相同，当前主要对SRS的目录结构进行约束，后续其它文档诸如用户手册、技术方案等文档待明确后，再根据情况进行说明。 SRS第1&2章节 SRS的前面两个章节，完全和国标的SRS保持一致。每个章节都有独立的.md文件。 +-- 引言/ +-- 目的.md +-- 范围.md +-- 定义、缩写和略缩语.md +-- 引用文件.md +-- 综述.md +-- 总体描述/ +-- 产品全景.md +-- 产品功能.md +-- 用户特点.md +-- 约束.md +-- 假设和依赖关系.md +-- 需求分配.md SRS第3&后续章节 SRS的第3及后续章节暂时不做限制，平台和产品线根据情况自行确定，但是分类要保证具备一定的逻辑性，这样才可以保证功能归属的合理性及无冲突性。 <!--什么是合理性和无冲突性？比如一个功能根据目录分类可以非常明确的只能够归属到某个分类，而不是放到分类1和分类2都觉得可以。--> 举例说明： NK310M第3&后续章节完全参考竞品Funac的连接说明书。 用户手册 本章节暂未提供内容，时间暂不确定。 技术方案 本章节暂未提供内容，时间暂不确定。"
  },
  "doc/研发文档编写指南/目录结构及命名/目录组织.html": {
    "href": "doc/研发文档编写指南/目录结构及命名/目录组织.html",
    "title": "目录组织",
    "keywords": "目录组织 docfx文档需要有个导航栏， 推荐使用toc.yml组织。 本文将介绍toc.yml的一般组织形式。 1.数据模型 数据样例如下： - name: Topic1 href: Topic1.md - name: Topic2 href: Topic2.md - name: Topic3 items: - name: Topic2_1 href: Topic2_1.md Note 注意：属性名大小写敏感。 toc是Table of Content的缩写， 一般指目录。 name: 必须的， 指定TOC 项的标题。 href: 可选的，指定TOC 项的导航路径。如果未指定 href ，则 TOC Item 作为其子 TOC Items 的父容器。推荐使用相对路径。 items: 可选的， 指定当前目录项的子目录项。 参考资料： Table-Of-Content (TOC) Files YAML Ain’t Markup Language (YAML™) version 1.2"
  },
  "doc/研发文档编写指南/目录结构及命名/目录规范.html": {
    "href": "doc/研发文档编写指南/目录结构及命名/目录规范.html",
    "title": "目录规范",
    "keywords": "目录规范 参考文档《软件项目目录与文件管理规范-R3.1》的【目录结构】章节。要求如下： 仓库必须符合本节要求的目录结构 原则 宜采用浅的目录结构，或者称为扁平的目录结构。 可选文件和目录，应等到需要的时候再去建立。 目录和文件名应尽可能采用英文。 请注意，目录和文件名的大小写必须符合规定。这是因为考虑到linux平台的可移植性。 git 服务器端的目录和文件结构 <project-name>/ ; project root dir +-- doc/ +-- srs/ +-- pm/ +-- risk.md +-- roles.md +-- stakeholder.md +-- src/ +-- test/ +-- .editorconfig ; or `.clang-format` +-- .gitattributes +-- .gitignore +-- README.md +-- <project-name>.sln Note 《软件项目目录与文件管理规范-R3.1》文档由软件部维护和发布，请参考当前最新版本。"
  },
  "doc/研发文档编写指南/研发文档编写规范.html": {
    "href": "doc/研发文档编写指南/研发文档编写规范.html",
    "title": "研发文档编写规范1.0",
    "keywords": "研发文档编写规范1.0 目的 为了统一公司文档风格，提高文档的可读性，减少不必要的沟通成本，提高文档的一致性和可复用性。 范围 适用于研发过程中的资产性文档（如软件需求说明书SRS， 即Software Requirement Specification）。 术语和定义 docfx: 微软公司推出的针对研发文档的组织软件。 toc文件：指docfx中组织文档目录的配置文件。 规则：进⾏文档编写时必须遵守的规定，文档内容不符合 规则 ，则评审不通过。 原则：进行文档编写时应该遵守的基本要求， 原则 具备通用适应性，但是允许个案的特殊性。 说明：对此规则或原则的必要解释，确保对于 规则 和 原则 的理解一致。 正例：对此规则给出正确例⼦。 反例：对此规则给出反⾯例⼦。 例外：对此规则给出例外的说明。 具体规范 文档组织 【规则】 文档格式必须统一使用md（markdown）文件。 说明：markdown文档作为纯文本编辑格式，易读易写，其本质是让我们回归到内容本身，注重文章本身的结构，而不是样式，同时可以让文档像代码一样进行版本管理。 【原则】 文档编辑工具建议使用 vs code +插件 Docs Authoring Pack 。 说明：统一工具是为了保证团队工作环境的一致性，且该插件提供了markdown的检查机制，对于不符合格式要求的，则默认会有黄色波浪线提示。 【规则】 文档发布及展示必须统一使用docfx工具，文档目录结构组织统一由docfx的配置文件toc.yml进行控制，因此不对目录进行编号。 说明：为了更好的保证文档的生成及展示，也为了帮助团队对文档形式上统一认识，避免产生在文档形式上的纠结，文档统一通过docfx工具发布及展示。 文档内容 【规则】 标题中禁止使用编号。 说明：编号可以在toc.yml文件中体现， 而无需在文档标题中表现。 文档中的标题已足够能体现文档的结构。 【规则】 所有文档的标题都必须从一级标题开始，逐级递增使用，不允许跳级。 说明：比如不能够直接二级标题开始；一级标题下面不能直接用三级标题。 一级标题：即本.md文档标题，和对应目录名称一致。 二级标题：文档正文部分的标题。 三级标题：二级标题下面一级的小标题。 四级标题：三级标题下面一级的小标题。内文不超过 四级 标题。 【原则】 为了让读者对段落中的个别内容引起充分的重视，应该添加 告警类 标签进行明示，约定以下 告警类 标签。 警告：适用于描述如果错误操作，则可能导致操作人员伤亡或设备损坏。 > [!WARNING] > 尚未建立机械坐标系的情况下，不能正确进行行程极限检查。请在通电后重新建立连接后，执行了回参考点的状态下执行高速程序检测。 注意：适用于描述如果错误操作，则有可能导致操作无法完成。 > [!CAUTION] > 在向外部I/O装置存取期间，请勿切断CNC的电源或拆除外部I/O装置。否则将会损坏外部I/O装置。 备注：适用于除警告和注意以外的补充说明。 > [!NOTE] > USB存储器的可用空间不多或者文件数量较多时，向USB存储器的文件输入/输出操作有时需要一定的时间。这种情况下，请删除USB存储器中不需要的文件后再度进行操作。 【规则】 符合 告警类 标签约定情况的正文内容应在文档中添加相关标签进行明示。 说明：根据上一原则对于告警类标签的定义，告警类特别是 警告 标签，如果不进行明示，则阅读者或者操作人员则容易忽略，忽略导致的后果比较严重，因此要求一定要通过告警类标签明示，以提示使用者进行重视。 【原则】 对于图表类的展示， 宜采用mermaid编写。 说明：mermaid对各种图表支持较为丰富，并且从工具集的考量，目前 vs code +插件 Docs Authoring Pack 对mermaid的支持较好。"
  },
  "doc/研发文档编写指南/表达风格/注意细节.html": {
    "href": "doc/研发文档编写指南/表达风格/注意细节.html",
    "title": "注意细节",
    "keywords": "注意细节 标题如何描述 标题一般包括以下几种描述方式： 名词词组，比如：范围、产品全景、概述、场景。 主题词+动词，比如：编码器锁存、仿真加工、圆盘对刀、台面编辑。 动词+主题词，比如：回参考点、加工向导、设定坐标系。 标题描述的设计并无严格的模板，只要遵循以下几个原则即可： 标题能够概括反映本章节的主题思想。 标题简洁扼要、涵义明确。 同级别的标题尽量使用相同的结构。 使用标题的注意事项 下级标题禁止重复上一级标题的内容。 不建议标题以标点符号（如句号或问号）结尾。 不建议在标题中解释缩略语。 标题与标题之间应该有引导介绍性的句子。例如，一级标题和二级标题之间应有引言内容，二级标题和三级标题之间应有正文内容。 标题要避免孤立编号（即同级标题只有一个），正文不要有孤立的三级标题和四级标题。 项目列表是最小编号单位，因此项目列表下禁止嵌套任何级别的标题。 减少表格 尽量不使用表格。 标点符号 TBD"
  },
  "doc/研发文档编写指南/表达风格/表达原则.html": {
    "href": "doc/研发文档编写指南/表达风格/表达原则.html",
    "title": "表达原则",
    "keywords": "表达原则 关注阅读者 文档作者及评审人员都应该尽量站在阅读者的角度思考问题，编写出满足用户需求的文档才可以称为高质量的文档。 可以从以下几个方面考虑： 文档的阅读者可能是不同的角色，不同角色对于文档的信息需求不同，不能够只是单一到考虑某个角色。 文档的阅读者的技术水平分布不同，对技术的理解深度不同，尽可能全面、清晰地将技术信息普及给阅读者。 对于操作型技术文档，除语言审校外，建议继续进行“文档可用性测试”——由一位无技术背景的测试人员参照该文档进行完整操作，如操作顺利成功，则该文档可用性测试通过；如失败，则需要继续修改完善文档。 对于操作型技术文档，不仅要准确描述操作步骤，还应设身处地考虑用户可能面临的问题，提供进一步的详细信息。例如，对于需要输入的信息，提供输入格式等详细要求；对于报错信息，提供解决报错的可选操作；为方便用户排查错误，提供详细的错误码速查列表等等。 语言简洁、直达观点 技术文档中应使用精练的语言。 建议作者在完成初稿后再通篇读一遍文档 ，将文中所有对表达意思没有明显作用的字、词、句删去，在不影响表达效果的前提下把文案长度减到最短。具体要求有： 禁止啰嗦冗长。 反例： 正例： 禁止逻辑混乱。 反例： 正例： 同一文档中勿重复表达同一事物。 尽量用 主动时态 ，尤其要 阐述清楚主语和宾语 。 反例： 正例： 不需额外解释 如果文档呈现的内容还需要额外的解释才可以让阅读者理解，则该文档不符合要求，需要继续采用文字或者图形的方式进行描述说明。"
  },
  "doc/研发管理制度规范/Bug严重级别处理规范.html": {
    "href": "doc/研发管理制度规范/Bug严重级别处理规范.html",
    "title": "Bug 严重级别处理规范",
    "keywords": "Bug 严重级别处理规范 版次：2021年3月16日 第4版 类型：程序文件 部门：软件部 上海维宏电子科技股份有限公司 版权所有 文件版本 修改前文件版本 主要修订内容和原因 修订人 修订日期 R2 R1 1. 修改范例。 汪腾霞 2018/11/8 R3 R2 1. 重新划分 Bug 严重级别，增加“致命”、“建议”，并对所有级别重新定义。 2. 根据新定义修改【范例】内容。 谷艳艳 2020/4/15 R4 R3 1. 标题从《Bug 严重级别处理说明》修改为《Bug 严重级别处理规范》。 2. Bug 严重级别重新定义；去掉“轻微”级别。 3. 增加目的、适用范围。 4. 更新【范例】内容。 余晓霞 2021/3/16 目的 合理的定义 Bug 严重级别有助于修复者确认该 Bug 的重要性，帮助修复团队更合理的安排时间进行修复。 使 Bug 严重级别的定义在部门内达成统一共识，减少 Bug 严重级别定义产生的歧义。 合理的定义 Bug 严重级别可以为产品的质量分析提供合理可靠的事实数据。 适用范围 适用公司研发体系所有软件产品的 Bug 严重级别定义。 Bug 严重级别定义 Bug 严重级别（Severity）是指该 Bug 在多大程度上影响产品的正常使用。Bug 的严重级别分为四个等级，从高到低依次为：致命、严重、一般、建议。 原则：所有bug的严重等级判断都是从高到低判断， 优先匹配高等级。 致命 【定义】该类 Bug 可能导致安全问题、设备损坏、软件异常关闭、无法正常加工和非临时数据损坏或丢失。 【要求】该类 Bug 需立即安排修复。 【范例】 导致人员安全和软件信息安全的问题，如：紧停无效、抱闸无效、主轴开启/关闭不受控制、越权操作等。 导致设备（横梁、刀具、切割头等）损坏。如： 校平分中Z轴上台不够导致撞切割头。 固件升级之后，Z轴异常下扎。 正常加工时频繁出现的机床震动。 由于偏位，造成设备损坏。 加工时出现乱跑现象。 导致软件异常关闭。如： 操作系统崩溃，例如：被测软件导致操作系统死机、蓝屏等。 软件崩溃、卡死（不可恢复正常使用）等。 导致客户无法正常加工。如： 偏位等造成加工轨迹不正确。 导致非临时数据损坏或丢失。非临时数据是指软件自身运行的依赖文件及用户加工依赖的文件，如：端口配置文件、lua 脚本、用户加工文件等文件被损坏和丢失。 严重 【定义】该类 Bug 导致无法完成功能（操作和输入数据正确的情况下）、动态数据损坏或丢失。 【要求】该类 Bug 需排在高优先级修复。 【范例】 输入正确的数据，无法完成功能，如： 对外提供的函数、接口不可用或实现错误，例如：通过平台函数 access.TryGetOwnerObject(out object obj)，获取不到obj对象。 输入有效的数据，无法完成功能，例如：滤波输入的数据类型是正整数，输入5，提交保存失败。 操作正常，无法完成功能，如： 设备通信问题，例如：软件正常重启或断电重启之后，设备连接不上。 加工操作时或加工过程，直接抛出代码异常信息，例如：操作开始、停止或断点继续时，抛出代码异常信息。 当加工期间，由于过程结果不符合预期，即使最后可完成加工，也可称之为错误的输出，例如：加工过程出现卡顿，之后可以自恢复。 无法完成业务功能。例如：完成对刀过程，禁止暂停抬刀功能失效。 操作正常， 出现性能问题， 如： 低于功能规格中约定的性能。 低于之前版本的性能（除非该性能指标通过研发评审会确认）。 无功能规格及无之前版本情况下， 由于性能问题严重影响用户使用软件的。 导致动态数据损坏或丢失。动态数据是指软件运行过程中产生的数据，这里的动态数据仅限于客户关心的数据和恢复正常加工的必需数据。例如：重启之后，加工任务列表中的加工任务状态错误；或加工工件数量被清零。 一般 【定义】该类 Bug 在非常规操作或输入数据不正确时导致功能失效或不影响功能的显示性缺陷。 【要求】该类Bug建议在正式发布版前修复。 【范例】 输入数据不正确，导致功能失效，如： 当端口映射表中存在错误或无效、空端口时，在拓扑配置中替换朗达控制器会产生未处理的异常。 由于用户特定操作系统等环境因素导致软件功能失效。 例如：客户安装过程过程，被某杀毒软件拦截。 非常规操作，导致功能失效，如： 苛刻或极端的特定条件下，造成软件功能出错，例如：软件连续重启2661次后，重启失败。 不影响功能的显示性缺陷，如： 界面出现不影响功能的界面设计类问题，例如：样式差异、错别字、显示值不统一、操作控件定位不准确等。 功能的完成需要长时间处理， 而期间未给出合理提示。 建议 【定义】该类 Bug 是对产品功能提出的建议或意见，使其向更加良好、积极的方向发展。 【要求】该建议可根据组内安排进行优化。 【范例】 提示信息优化，更加友好且有指导性；例如：对于复杂的功能操作，每一步都有明确的提示信息。 产品功能设计不易于测试人员和开发人员测试。 编制：汪腾霞 审核：胡凯烽、陈豫 批准：郑之开 审批链接："
  },
  "doc/研发管理制度规范/Bug基本属性定义-R1.html": {
    "href": "doc/研发管理制度规范/Bug基本属性定义-R1.html",
    "title": "Bug 基本属性定义",
    "keywords": "Bug 基本属性定义 版次：2021年1月6日 第1版 类型：技术文件 部门：软件部 上海维宏电子科技股份有限公司 版权所有 基本属性 TFS对应字段 前置条件 分类 定义 Bug状态 State 活动的 指Bug处于等待部署或开发活动中。 已解决 指开发已处理完成，等待测试验证。 已关闭 指测试验证通过，或无效、重复、不处理的Bug。 原因 Reason State：活动的 新的 新建Bug。 State：活动动->已解决 已修复 已过时 保留原样 无法重现 重复提交 已推迟 无效Bug 已解决->已关闭 测试通过 Bug修复并验证通过。 已确认 测试与开发对于Bug的处理意见一致。 已解决->活动的 测试不通过 Bug验证不通过。 已拒绝 不同意开发对于Bug的处理原因 已关闭->活动的 重新激活 错误关闭 严重级别 Severity Bug严重级别处理规范 Bug类型 Bug Type 需求-需求缺陷 TFS 工具使用指导书 - 4.2章节 需求-需求变更 规格-功能规格缺陷 规格-非功能规格缺陷 方案-功能模块设计缺陷 方案-兼容性设计缺陷 方案-约束性设计缺陷 方案-算法设计缺陷 编码-编码错误 编码-自测问题 编码-第三方库问题 发行-代码签入问题 发行-编译/发行问题 发现阶段 The Dis. Phase 1.需求阶段 需求分析阶段发现的需求不合理或漏考虑项。 2.设计阶段 方案设计阶段或测试设计阶段发现的需求不合理、错误、漏考虑的Bug。 3.编码阶段 编码阶段发现的Bug，一般是需求、设计阶段引入的Bug，开发人员在编码时发现的问题。 4.冒烟测试 5.第一次测试 6.回归测试 7.发布后 软件发布后在软件中发现的Bug，包括客户反馈、公司内部其他团队反馈、本团队内部反馈（非本次维护的功能）。 引入者 Imported by 引入Bug的人员。 来源 From 开发 开发人员发现的本团队产品中的Bug。 测试 软件测试人员或产品应用测试发现的本团队产品中的Bug。 客户 市场人员或客户反馈的Bug。 其他 不属于以上三类的其他人员发的Bug，如其他软件团队人员发现的本团队的Bug。 创建时间 Created Date 新建Bug的时间。 关闭时间 Closed Date Bug关闭的时间。 漏测者 Omited By 漏测Bug的人员（仅针对于外部反馈的 Bug）。 漏测原因 Omittance Cause 01.需求了解不透彻 02.用户场景测试设计遗漏 03.用例粗犷，描述不清晰 04.黑河测试难以覆盖 05.未按用例执行 06.回归测试策略问题 07.测试环境未能模拟真实环境 08.测试资源限制，导致场景未覆盖 09.内部Bug未处理 10.未进测试流程 11.历史Bug 12.第三方库引入 激活次数 Activate No. Bug由“已解决”或“已关闭”变为“活动的”的次数。 优先级 Priority 1 高 2 中 3 低 Bug引入原因 Root Cause 由各团队自定义 引入Bug的根本原因 团队 Team Bug归属团队 项目 Project 非项目 Project 项目 漏测分析和预防 Analysis And Precaution 漏测Bug的原因分析和预防。 测试评审意见 Tester Review Opinion 对漏测Bug的原因和预防措施的审核意见。 原因分析和解决措施 Analysis And Correction 开发人员对Bug引入原因分析及解决措施。 预防措施 Prevention Measures 开发预防措施。 开发评审意见 Dev. Review Opinion 迭代路径 Iteration De-grade De-grade 是 因为修改、添加功能，将已有功能改坏而引入的Bug 否 引入版本 Imported Ver. 引入Bug的软件\\模块版本号 截止日期 Deadline 截止日期 编制：谷艳艳 审核：胡凯烽"
  },
  "doc/研发管理制度规范/CAD迭代工作流程-R4.html": {
    "href": "doc/研发管理制度规范/CAD迭代工作流程-R4.html",
    "title": "CAD 迭代工作流程",
    "keywords": "CAD 迭代工作流程 版次：2021年11月01日 第4版 类型：程序文件 作者：CAD组 上海维宏电子科技股份有限公司 修改历史 文件版本 修改前文件版本 主要修订内容和原因 修订人 修订日期 R1 新增文档 CADCAM 组 2013-3-5 R2 R1 修改完善迭代会议安排 朱延晓 2019-7-2 R3 R2 按照最新代码管理方式更新部分开发过程以及调整文件格式 朱延晓 2019-9-19 R3.3 R3 变更迭代周期，同时增加要求 张艳丽 2021-1-29 R4 R3.3 添加发布准出条件，更新迭代变更内容注意事项（已标为红色） 杨梅 2021-11-1 1 目的 为规范 CAD 组成员在迭代开发工作中的行为，明确各个环节实施人员的相应责任，提高研发产品质量，特制订本工作流程。 CAD 组实行敏捷开发的方式，每月为一个迭代周期（紧急 BUG 除外），每个周期的关键活动又分为一些子活动和具体要求，大致包含以下内容： 迭代负责人确定。 迭代范围和目标的确认。 迭代计划制定（每月计划表）。 迭代方案评审（个人评审+团队评审）。 编码及代码审核。 迭代测试、代码合并和迭代验收。 迭代计划跟进（迭代开始前会议以及每周一次例会）。 迭代发布。 迭代变更。 迭代回顾总结会议。 2 迭代负责人选定 每次迭代开始前首先确定迭代负责人 （在月度计划时指定迭代负责人）。 迭代负责人采用轮流制，主要的职责有： 迭代前的准备，内容包括： 检查迭代周期的工作内容是否已经创建了工作项（由工作项的开发人员或是质量保证团队责任人创建），并且工作项能够在当前迭代周期检索到。 迭代开发分支的确定（原则是减少迭代分支，解决发布版本过多的问题。） 关于分支确定的原则： 原则上新增功能在独立分支上开发； 一个迭代周期的 BUG 在同一个分支上解决，目前一般为 DEV1 分支专门用来解决 BUG （如果 BUG 导致代码变的多且复杂，则需单独在另外一个分支上解决）； 新增功能和 BUG 需要在分支上验证通过后再签入主干验证，但并不是所有的分支修改都需要提交测试版本； 代码评审人员和迭代负责人评估确定是否需要发布分支版； 开发人员要对自己的代码以及功能负责，充分自测验证以及进行自动化测试，不要仅仅为了心里安慰而所有分支功能都发给质量保证团队测试。 迭代计划的跟进，每周组织一次迭代例会，当进度和质量出现问题时，及时组织评审。 迭代计划测试版和正式版的发行时间确定和跟进 迭代验收后问题的跟进。 迭代回顾与总结等 3 迭代范围和目标的确认 3.1 迭代范围确认前期准备 迭代负责人： 检查本迭代周期计划解决的事情，是否都按要求创建了 Task 或 Bug； 注意： 工作项的难度、开发人员的能力、工作项的优先级等，特别是优先级的定义要明确。优先级划分建议如下：P1 为迭代必须发布的；P2 为根据后期的开发进度评估是否可以在本次迭代发布的；P3 为可以从本次迭代移除的。 根据优先级以及工作的饱和情况，修改 TFS 对应的 Iteration 以及优先级字段，详细的填写要求见《CADCAM 组工作流程简述.docx》以及《CADCAM 组 TFS 填写规范.docx》。 确定迭代目标，一般有以下几类： 调研任务： 调研类的产出是调研报告（调研报告需要进行竞品分析，现在主要参考柏楚、FastCam、大族激光、Camworks 或其他）； 方案预研： 方案预研的需要有方案分析报告或是总结； 规格文档： 需要按照规格模板，输出规格文档。 所有任务或 BUG 都必须有规格文档，对于 BUG 工作项，在维护代码的同时，开发人员需要同步维护规格文档，不能出现代码维护了，但规格文档未维护的问题。 方案设计： 按照方案设计文档的模板，输出方案设计文档（必须明确设计目标）。 所有的 Task 必须有方案设计文档，BUG 超过 2 天编码工作量的，必须上报评审（以沟通清楚方案为主要目的，不需要出具具体的方案设计文档）；BUG 解决工作量超过 5 天的，必须有设计方案文档；外部 BUG 解决方案必须上报评审。 发行软件： 紧急的或是优先级高的，需要在本次迭代发行软件。 组内发行软件时，针对功能和优先级不高的 Bug，原则上一月一个迭代发行，特殊情况时，需要迭代负责人说明原因，避免中间紧急发行软件的情况。 3.2 召开迭代范围确认会议 主要内容为对已筛选的 Task 和 bug 进行确认。 迭代负责人提前一天进行会议安排（需要有投影仪的会议室以及能够连接 TFS），并通知相关人员；主要目的是明确任务安排。 迭代会议参与人：开发人员、质量保证团队，必要时邀请业务线相关人员等。 4 迭代计划制定 每月月初前 3 个工作日内，各组负责人完成迭代计划表的编制。迭代计划中包括开发任务以及测试相关任务。 迭代范围确认会议后，各工作项负责人在迭代确认会议第二日下班前，填写 TFS 工作项中的时间安排（工作项对应的开发人员为工作项的责任人，需要主动找测试协商测试时间，必须发行软件的，需要有明确的测试版发行时间、代码合并时间、正式版交付时间）。 计划时间安排填写要求有： 开发需要与 CAD 组测试负责人沟通测试时间； 本次迭代发布软件的工作计划需包含需求分析、需求审核、方案审核、编码、自测、代码审核、测试版发行、测试、代码合并、回归测试、正式版发行； 最大颗粒度：2 天，超过两天的工作量需要拆分，工期计量单位以天计算； 预留 10% 的时间作为风险时间。 如根据业务线要求以及总工评估后，需要变更迭代范围，则应及时告知相关责任人修改迭代计划。 迭代周期内，迭代负责人根据上述计划安排，确定迭代周期内的测试版发行要求： 为保证验收的及时性，原则上 5 天左右发布一个测试版，控制发布分支测试版在 3 个； 并不是所有的分支修改都需要提交测试版本。代码评审人员可以和迭代负责人员评估确定是否需要发布分支版； 制定迭代测试版发行计划时，可以初步确定分支发布的日期，包含以下内容： 如迭代周期：7.15~7.26 日期 分支提测版本 计划包含内容 7.18 dev-xxxx Task-xxxxxxxxxx 7.23 7.26 软件发行由迭代负责人指定专门人员发行，并填写相关信息，解决发行人员过多，发行信息混乱，遗漏问题。 原则上采取每5天发布一个测试版的方法，避免内部版本数太多。代负责人根据迭代计划中大家给出的发布软件时间，跟进发布测试版的情况。 迭代结束前5天，dev签入代码锁定，不允许再签入到dev（可放到下个迭代开始时签入） （除特殊情况外，比如业务线已经明确答应客户，或是P1级的工作，但是特殊情况不允许成为例行） 5 迭代规格、方案设计、测试方案与评审 Task 和 BUG 工作项必须有规格文档、方案设计文档、自测报告（规格中的所有内容需要验证、需要补充自动化测试的，自动化编码必须完成，已有自动化测试的，自动化测试必须通过）、Checklist 完成文档。 测试要求：单功能测试必须覆盖测试模板和标准测试方案中的测试点。 凡是工作量超过 5 天的任务和 BUG，必须召开团队评审，团队对规格、设计方案、测试方案进行评审，由任务负责人主动安排。如果编码工作量超过 3 周的，在方案确定后的第一周，需对代码进行团队评审。 6 编码及代码审核 因为 CAD 组使用分支方式管理代码，所以要求做到尽可能早的审核代码，保证代码及时审核，及时发现问题，及时修正，最晚审核时间为软件发测试之前。代码审核需要通过代码审核工具，并留下审核意见。没有代码审核记录的，质量保证团队拒绝测试，特殊情况需要上报对应负责人。 为统一大家代码审核的标准，CAD 组每月会举行 1~2 次代码评审分享（团队评审时分享）。 代码评审要求包括： 编码过程中需要代码互评，并将评审记录保留； 审核人员需要同时审核测试范围是否存在问题； 已有库需要保证通过 cppcheck 以及编译器的检查，无任何 error 和 warning，并且通过库的功能自动化测试；编译器的 output 无内存泄露相关提示（若存在但并非自己模块的请及时通知相关模块负责人以及总工）；如果是新增加的库，必须有对应的自动化测试模块。计算类的库，必须进行相关性能测试（自动化）。 凡是编码工作量超过 5 天的，需每周评审一次（个人评审），便于及时发现问题，进行修正。 7 代码合并和迭代验收 代码管理的要求： 代码与变更集关联的相关性和独立性 每个变更集必须与特定的 BUG 工作项或对应 Task 关联； 如果代码是解决 BUG 的，此时变更集需要同时关联 Task 和 BUG 工作项，不能只与 Task 关联或是与不相关工作项关联，且需要每个变更集对应单独的 BUG ，不能几个 BUG 修改后签入在一个变更集中。 分支和主干的关系 修改 NcEditor 的代码，默认情况采用分支上开发，经过验证后再合并到主干的方式，且在发布测试版本前，必须经过代码审核； Libs 下的各个库因为修改频率较低，且不存在同时多人修改的情况，所以不采用分支的方式开发，但如果修改周期大于 10 天，采用分支开发的方式。 分支和主干的同步、合并操作 每次迭代开始前以及分支发行测试版本时，分支代码需要将 Dev 代码同步至开发分支代码（Dev->Devx）； 分支测试版本通过后，发行正式版时，需进行分支->主干的合并操作，合并需要在本地解决冲突（冲突手工解决，不可以自动解决冲突）、再提交服务器，然后发行正式版。 代码签入时，请先签入代码，再签入 readme 或 publish.log，保证签入变更集与填写内容一致。 迭代验收分为两个部分，一是分支测试版本的测试，二是主干正式版的验收。开发在发行测试版本时，需要按照发行要求填写。 测试准入条件： 开发自测必须覆盖功能基本场景、典型异常场景以及边界等情景，需提供开发自测报告， 详见测试报告模板，路径：$/cadcam/V15/Doc/01规范制度/02开发工作流程与规范； 符合《软件测试流程&过程规范》中给出的准入条件； 8 迭代发布 迭代发布日期一旦确定，必须在迭代发布日期前（含发布日期）发布，如发现无法准时发布，迭代负责人需及时上报。 测试环节验收时，如发现严重问题，可能会影响发布，需及时反馈。 迭代验收通过后，由质量保证团队进行发布通知的填写，将发布记录上传 Wiki，并发布通知，同时通知到业务线。 现在业务线修改的 CAD 所属功能必须由 CAM 组验收，质量保证团队需要对这部分工作项增加发布说明以及影响范围。详细信息见： http://172.16.10.17:86/#!CamTest/05 发布说明 发布准出条件： 所有的 task 均验收测试通过，所有用例执行通过， task 下不存在未处理的 bug，拖迟处理的必须开发调查过，并与 质量保证团队负责人 确认可以延后处理。 发布之前所有功能的自动化测试全部测试通过。 如果是手工打包，需要保证人工测试界面上所有功能的基本流测试通过。 软件系统测试必须测试通过，测试范围见对应项目的系统测试方案。 发布当天，测试迭代负责人，需要再梳理一遍 Bug，严重的 bug 必须全部解决，确保修复的 Bug 均验收通过。 以上若在发布日期之前达不到，则必须向上反馈。 开发工作流程图如下： 详细流程图具体路径为： \\\\file01.weihong.com\\02.各部门受限\\12.CAD 平台\\20.CADCAM 组\\01.cadcam 组开发过程\\CADCAM 开发流程图-R1.2.vsd 迭代发布之后，开发人员和质量保证团队进行相关文档的整理，并将文档上传至 168 服务器 CAM 源代码管理：Dev\\Doc 目录。 持续集成与包管理注意事项的相关内容见以下路径：[\\\\file01.weihong.com\\02.各部门受限\\12.CAD 平台\\20.CADCAM 组\\01.cadcam 组开发过程\\ NcEditor 开发注意事项-R2.docx](file:///\\172.16.10.66\\NWfile02\\01.安全内网文件夹\\01.研发部文件\\01.各组文件\\20.CADCAM组\\01.cadcam组开发过程\\ NcEditor开发注意事项-R2.docx)。 9 迭代插入和变更 原则上迭代范围确认后，不再变更，但对于 严重或致命 Bug （包括外部反馈以及内部测试发现的发布版本存在的），严重影响客户使用的，需及时响应和修复， 并向质量团队负责人和迭代负责人汇报，质量负责人须要第一时间通知相关各业务线， 明确告知影响范围以及需要业务线暂停止当前的发行，等待问题修复后再继续发行。 由质量保证团队触发对应Release版本和开发迭代负责人确定发布Release时间， 并更新SDK发版计划告知业务线。 根据问题发现的版本，修复有几种情况，但是原则为：优先修复发现问题版本，再同步至其他版本。 如果问题发现在 Release 版，则最先修复 Release 版，然后再同步至 Beta 分支，紧接着从 Beta 分支同步至 Dev 分支。 如果问题发现在 Beta 版，则最先修复 Beta 版，然后再同步至 Release 分支，紧接着从 Beta 分支同步至 Dev 分支。 如果问题发现在 Dev 版，常规情况下：最先修复 Beta 版，然后再同步至 Release 分支，紧接着从 Beta 分支同步至 Release 分支。此时根据影响程度决定，版本修复的顺序。 10 迭代回顾总结会议 迭代周期结束后， 质量保证团队 发起开展回顾会议，回顾会议主要讨论迭代过程中存在的问题（低级 Bug、严重 Bug、代码评审执行情况、开发和测试过程中可以改进的点等），其中： 回顾会议召开之前，开发人员和质量保证团队梳理 Bug 的出现原因，并在回顾会时统一分享，需要按照纠正预防的方式进行总结，从人、机、料、环、法、测几方面分析，确保措施的可执行性； 每次迭代会议时对本次迭代中有突出表现的人员进行表扬和奖励。 回顾会议之后，对于总结措施具体实施要求。 11 工作项的填写要求 详见 CADCAM 组 TFS 填写要求-R4.doc，工作项的具体填写要求参照以下路径：$/cadcam/V15/Doc/01 规范制度/03 测试工作流程与规范 12 原则和约束 1、 本次迭代安排的任务引出的 Bug，需要在本次迭代完成，若本次不修改的，需及时通知负责人，并由负责人决定放在延迟处理或者下个迭代。新创建的 BUG 原则上都要处理，如果调查后任务解决复杂度高，或是影响不大，认为可以不处理的， 需要找负责人沟通，不可以擅自决定不处理，由相关责任人标记是否处理。 如发现开发人员擅自决定不处理 BUG，将根据 BUG 实际造成的影响对开发人员进行惩罚。 2、 迭代版本发行之日，所有迭代相关开发人员、迭代负责人需待版本发行之后，才能下班 ，有特殊情况时，需向迭代负责人请假说明，如出现未请假而提前离开的情况，由提前离开人员，在总结会议时表演一节目。 3、 严格执行 checklist 的检查条目，仔细阅读，对于内容不确定时及时沟通。如 checklist 未执行到位，视具体情况进行相关惩罚。 4、 冒烟测试不通过，视具体情况进行相应的处罚。 5、 出现外部反馈因未按用例执行反馈的 Bug，视具体情况进行处罚。 6、 出现外部反馈因未覆盖测试模板中和标准测试中测试点的 Bug，视具体情况进行处罚。 7、 原则上影响客户加工的外部问题处理优先级最高，迭代计划中的工作优先级高，对内的需求优先级低，如果不能确定事情的优先级，及时找相关负责人进行确认。 8、 开发人员需尽可能的帮助质量保证团队复现一些不能稳定复现的 Bug； 9、 如果出现崩溃、蓝屏、死机的问题，开发必须优先解决； 10、 Bug 的原因尽量描述清楚，可以使用业务语言和代码原因两种描述方式； 11、 变更集跟着 Bug 走，checklist 跟着工作项走。所有 Task 和 BUG 必须都要有 checklist 检查表。 12、 当工作项关闭之后，新增需求不在之前的需求单之内的继续维护，需要重建工作项； 13、 若因需求、时间、方案变更，或发现任务时间预估不够，需要走变更流程。变更流程为：申请人向对应负责人提出申请，同时将变更记录登记在 TFS 工作项中； 14、 关于迭代任务里的 Bug ，如果确实需要延期，需经迭代负责人和质量保证团队负责人同意批准； 15、 Task 引入的 Bug 原则上必须解决，才可以签到 DEV，否则不允许签入 DEV，如需签入需上报总工审批； 16、 如果工作方案不确定，或者对代码不了解，可以通过调研，晚些给出工作计划。 13 其他 非迭代任务的开发流程，开发要求与迭代开发流程要求一致。 编制：CAD组 审核：张艳丽 批准：陈豫"
  },
  "doc/研发管理制度规范/CNC平台-缺陷跟踪流程-R1.html": {
    "href": "doc/研发管理制度规范/CNC平台-缺陷跟踪流程-R1.html",
    "title": "CNC 平台缺陷跟踪流程",
    "keywords": "CNC 平台缺陷跟踪流程 版次：2021年11月16日 第1版 类型：程序文件 上层文件：软件测试流程&过程规范-R2 上海维宏电子科技股份有限公司 版权所有 修改历史 文件版本 修改前文件版本 主要修订内容和原因 修订人 修订日期 R1 新建 李艳 2021.11.16 1 引言 1.1 编写目的 为规范 CNC 平台缺陷的提交和跟踪过程，特制定此流程。 1.2 读者对象 维宏电子科技股份有限公司 CNC 平台从事产品软件测试及相关人员。 1.3 引用标准 无。 2 术语/定义 2.1 缺陷术语解析 为了统一认识，此处给出公司关于测试过程中，相关术语的定义。 编号 名称 定义 1 缺陷 所谓缺陷，就是产品（包含程序、数据、文档、硬件）中不符合用户需求的问题，通常又叫 Bug。 经过一步或多步操作后，软件实际运行结果与预期结果不符合，即定义为 一个 Bug。若已知不同 Bug 现象产生的本质原因相同可归类为一个 Bug。 2 缺陷跟踪 从缺陷提交至缺陷关闭的整个过程的跟踪，包括缺陷提交、评估、指派、 修复、 验证、关闭。 3 外部缺陷 非 CNC 平台人员在使用过程中发现的 Bug，称之为外部缺陷或外部 Bug。 表格 1 缺陷术语 2.2 缺陷基本属性解析 字段 解释 规则 标题 Bug 一般分为外部 Bug 以及内部 Bug，主要包括 Bug 现象、存在范围的简述，如哪个产线、功能， Bug 主要现象等。 外部反馈的缺陷需要记录反馈人。 外部缺陷格式： 外部反馈-【产线】 -【Jira 编号】 -Bug 简 述-反馈人 例：外部反馈-【产品 I 部】 -【CNC-3352】 -通道 1 自动 化运行至手动连续脚本过程中偶现崩溃-李荣楠 内部缺陷格式： 测试类型-【功能名】 -Bug 简述 测试类型：组件测试/固件测试/集成测试/自动化测试 例： 组件测试-【动态调整加加速度】 -动态调整开关对限 速曲线动态加加速度调整不生效 通用 Bug 和历史 Bug 怎么体现-在标记中体现 Bug 类型 Bug 所属类型。 1. 需求-需求变更： 因需求的获取、转换、变更导致的缺陷 2. 需求-需求缺陷： 因需求的理解、设计不全或错误导致的缺陷 3. 方案-功能模块设计缺陷： 需求正确，因功能模块设计方案不足或错误导致的缺陷 4. 方案-兼容性设计缺陷： 需求正确，因兼容性设计方案不足或错误导致的缺陷 5. 方案-算法设计缺陷： 需求正确，因算法设计方案不足或错误导致的缺陷 6. 方案-约束性设计缺陷： 需求正确， 因约束性 设计方案不足或错误导致的缺陷 7. 规格-非功能规格缺陷： 需求正确，因兼容性/性能/可靠性/本地化等功能规格缺失/错误导致的缺陷 8. 规格-功能规格缺陷： 需求正确，因功能性规格缺失/ 错误导致的缺陷 9. 编码/集成-编码错误： 需求、方案正确，因编码错误导致的缺陷 10. 编码/集成-第三方库问题： 需求、方案正确，因第三方库局限性或者错误导致的缺陷 11. 编码/集成-自测问题： 需求、方案正确，因未自测导致的缺陷 12. 发行-编译/发行问题： 需求、方案、编码正确，因编译/发行错误导致的问题 13. 发行-代码签入问题： 需求、方案、编码正确，因代 码签入遗漏、多签或错误导致的缺陷 严重级别 Bug 严重级别（Severity）是指该Bug 在多大程度等级，从高到低依次为：Bug 的严重级别分为四个致命、严重、一般、建议。原则：所有bug的严重等上影响产品的正常使用。级判断都是从高到低判断，优先匹配高等级。 1. 致命 【定义】该类 Bug 可能导致安全问题、设备损坏、软件异常关闭、无法正常加工和非临时数据损坏或丢失。 【要求】该类 Bug 需立即安排修复。 【范例】 1) 导致人员安全和软件信息安全的问题，如：紧停无效、抱闸无效、主轴开启/关闭不受控制、越权操作等。 2) 导致设备（横梁、刀具、切割头等）损坏。如： a. 校平分中 Z 轴上台不够导致撞切割头。 b. 固件升级之后，Z 轴异常下扎。 c. 正常加工时频繁出现的机床震动。 d. 由于偏位，造成设备损坏。 e. 加工时出现乱跑现象。 3) 导致软件异常关闭。如： a. 操作系统崩溃，例如：被测软件导致操作系统死机、蓝屏等。 b. 软件崩溃、卡死（不可恢复正常使用）等。 4) 导致客户无法正常加工。如： a. 偏位等造成加工轨迹不正确。 5) 导致非临时数据损坏或丢失。非临时数据是指软件自身运行的依赖文件及用户加工依赖的文件，如：端口配置文件、lua 脚本、用户加工文件等文件被损坏和丢失。 2. 严重 【定义】该类 Bug 导致无法完成功能（操作和输入 数据正确的情况下）、动态数据损坏或丢失。 【要求】该类 Bug 需排在高优先级修复。 【范例】 1) 输入正确的数据，无法完成功能，如： a. 对外提供的函数、接口不可用或实现错误，例如：通过平台函数 access.TryGetOwnerObject(out object obj)， 获取不到 obj 对象。 b. 输入有效的数据，无法完成功能，例如：滤波输入的数据类型是正整数，输入 5，提交保存失败。 2) 操作正常，无法完成功能，如： a. 设备通信问题，例如：软件正常重启或断电重启之后，设备连接不上。 b. 加工操作时或加工过程，直接抛出代码异常信息，例如：操作开始、停止或断点继续时， 抛出代码异常信息。 c. 当加工期间，由于过程结果不符合预期，即使最后可完成加工，也可称之为错误的输出，例如：加工过程出现卡顿，之后可以自恢复。 d. 无法完成业务功能。例如：完成对刀过程，禁止暂停抬刀功能失效。 3) 操作正常，出现性能问题，如： a. 低于功能规格中约定的性能。 b. 低于之前版本的性能（除非该性能指标通过研发评审会确认）。 c. 无功能规格及无之前版本情况下，由于性能问题严重影响用户使用软件的。 4) 导致动态数据损坏或丢失。动态数据是指软件运行过程中产生的数据，这里的动态数据仅限于客户关心的数据和恢复正常加工的必需数据。例如：重启之后，加工任务列表中的加工任务状态错误；或加工工件数量被清零。 3. 一般 【定义】该类 Bug 在非常规操作或输入数据不正确时导致功能失效或不影响功能的显示性缺陷。 【要求】该类 Bug 建议在正式发布版前修复。 【范例】 1) 输入数据不正确，导致功能失效，如： a. 当端口映射表中存在错误或无效、空端口时，在拓扑配置中替换朗达控制器会产生未处理的异常。 b. 由于用户特定操作系统等环境因素导致软件功能失效。例如：客户安装过程过程，被某杀毒软件拦截。 2) 非常规操作，导致功能失效，如： a. 苛刻或极端的特定条件下，造成软件功能出错，例如：软件连续重启 2661 次后，重启失败。 3) 不影响功能的显示性缺陷，如： a. 界面出现不影响功能的界面设计类问题，例如：样式差异、错别字、显示值不统一、操作控件定位不准确等。 b. 功能的完成需要长时间处理， 而期间未给出合理提示。 4. 建议 【定义】该类 Bug 是对产品功能提出的建议或意见，使其向更加良好、积极的方向发展。 【要求】该建议可根据组内安排进行优化。 【范例】 1) 提示信息优化，更加友好且有指导性；例如：对于复杂的功能操作，每一步都有明确的提示信息。 2) 产品功能设计不易于测试人员和开发人员测试。 优先级 结合严重级别、风险等级、复现概率等给出的修复优先级 优先级 1： 1 为最高优先级 1) 严重级别为致命或严重；风险等级为高或中；复现概率较高的 Bug 优先级 2： 2 为中等优先级 1) 严重级别为致命或严重；风险等级为中或低；复现概率较低的 Bug 2) 严重级别为一般；风险等级为中或低；复现概率高或必现的 Bug 优先级 3： 3 为最低优先级 1) 严重级别为一般；风险等级为低，复现概率低的 Bug 2) 严重级别为建议的 Bug 以上仅供参考，具体看版本规划以及资源情况 发现版本 Bug 所属组件版本号 发现 Bug 的组件版本号。 例： App 2.712.0.0_alpha5 功能归属 Bug 所属功能模块 Bug 所属功能模块，可与 Bug 标题中的功能名保持一致。 源码仓库 该功能所属源码仓库 一个 Bug 修改多个组件的情况下只填写最为主要或者导致该问题根本原因的源码仓库。 复现概率 Bug 的复现概率 分为必现/概率复现/仅一次，包含尝试次数以及复现次数。描述 Bug 时可通过复现概率/尝试次数/复现次数来量化表示该 Bug 的出现频率。 Bug 描述 记录 Bug 现象、Bug 重现步骤、期望结果、测试环境及分析建议，若 Bug 非每次出现，可补充说明出现的概率。 === 格式要求 ============== 【测试环境】 【Bug 步骤】 1. /* 描述 Bug 重现的详细步骤，尽量保证每步仅做一个操作 /； 2. ...... 【实际结果】 * 【预期结果】 ==== 完毕 ================ 开发分析 通过引入者、引入版本、Bug 类型、原因分析、纠正措施、预防措施来分析该 Bug 产生的原因。 引入者：通过代码分析以及代码的签入者来判断引入者。 引入版本：通过代码分析以及代码签入时间来判断引入版本。 Bug 类型：见上方 Bug 类型详解。 原因分析：分为直接原因分析以及根本原因分析。 直接原因为导致该 Bug 产生的直接技术原因。 根本原因需要结合开发生命周期，使用鱼骨图进行人为/外界原因的探究，详见\\\\172.16.10.88\\02.各部门受限\\13.软件平台测试\\E.质量改进\\01.缺陷分析\\缺陷分析文档\\培训-缺陷分析-内训-软件平台_R3.1.pptx 纠正措施：修复该 Bug 的技术方案。 预防措施：结合引入原因、流出原因、开发生命周期以及 Bug 类型综合考虑可以预防的手段。 测试分析 通过漏测者、漏测原因、 漏测分析、 纠正措施、预防措施来分析该 Bug 漏测的原因。 漏测者：原本测试该功能的人员，不知道的情况下随意填写。 漏测原因： 01. 需求了解不透彻 02. 用户场景测试设计遗漏 03. 用例粗犷，描述不清晰 04. 黑盒测试难以覆盖 05. 未按用例执行 06. 回归测试策略问题 07. 测试环境未能模拟真实环境 08. 测试资源限制，导致场景未覆盖 09. 内部 Bug 未处理 10. 未进测试流程 11. 历史 Bug 12. 第三方库引入 漏测分析：结合漏测原因描述具体情况。 纠正措施：完善导致该 Bug 流出的主要原因。 预防措施：结合引入原因、流出原因、开发生命周期以及 Bug 类型综合考虑可以预防的手段。 表格 2 缺陷基本属性 3 Bug 跟踪流程 结合公司的测试过程， 缺陷跟踪流程分为如下阶段： 1） 缺陷提交 2） 缺陷评估 3） 缺陷指派 4） 缺陷修复 5） 缺陷验证 6） 缺陷关闭 3.1 流程图 3.2 流程详解 3.2.1 缺陷提交 在内部测试、使用、调试、销售产品过程中，对发现的问题在指定缺陷管理系统中进行记录，以上报给相关人。 Bug 提交分为：新建 Bug 与激活已有 Bug。 Bug 新建： Bug 在 Bug 库中不存在，则新建 Bug。 Bug 激活： Bug 在 Bug 库中已经存在且为非活动状态，则重新激活该 Bug，并确定是否需要关联相关任务项。 Bug 以 Bug 工作项形式提交。 具体填写要求可参照具体的项目管理工具，如《TFS 工具使用指导书-Rn.doc》 一个 Bug 一个工作项。 Bug 版本数需要累计填写 比如该 Bug 在多个组件版本或者集成版本出现，则累计填写。 Bug 描述时需要精确，可从以下几个角度方面： 语言尽量简洁，太过冗长时建议分段描述。 尽量量化，使用数字描述。 语言描述不清的内容建议使用截图、录屏等方式。 可以尝试对测试中的变量进行控制分析，记录测试结果。 提交 Bug 时，如果为难复现 Bug，或者步骤复杂的 Bug，建议提供以下内容帮助开发分析： 错误弹窗截图 应用程序日志： NcStudio\\ActiveConfig\\ncstudio.log Windows 事件中心日志：计算机管理\\系统工具\\Windows 日志\\应用程序 当前进程的 dump 文件 C:\\Windows\\Minidump 下 dump 文件 在工作项测试过程中发现的问题，直接在当前工作项的“链接“页面新建 Bug 工作项（链接类型可以视情况选择，一般为“测试方”）； 随机测试发现的 Bug，在对应区域创建 Bug 工作项。 3.2.2 缺陷评估 提交至缺陷管理系统中的缺陷， 需评定其后续的处理措施。 若为外部 Bug， Bug 提交后由测试组长安排人员进行 Bug 重现并记录重现结果。 根据重现结果由产品总工进行评估。 Bug 提交后，若为当前任务项测试出的 Bug，由开发责任人进行评估，否则由产品总工进行评估。 经评估后，在缺陷管理系统中给出该缺陷的处理措施。 3.2.3 缺陷指派 缺陷评估后若需要进行调查、处理，则分配相应人员进入缺陷修复过程。 若为当前任务项测试出的 Bug，则直接由当前开发负责人修复，当前测试人员进行回归，否则由产品总工指派开发负责人，测试组长指派测试负责人。 3.2.4 缺陷修复 由指派的开发责任人对缺陷进行定位分析、修复处理。 Bug 修复后开发人员需进行自测，确保缺陷得以修复。 Bug 修复后开发人员需提交原因分析及处理说明。 缺陷定位分析过程中，发现 Bug 难以修复或影响范围太大，综合 Bug 修改成本、影响程度等原因评估不处理的，重新修改 Bug 处理意见为不处理，进入缺陷关闭阶段。 缺陷定位分析过程中，发现 Bug 修改比较复杂，综合 Bug 影响程度等原因评估暂缓处理的，重新修改 Bug 处理意见为暂缓处理。 3.2.5 缺陷验证 对状态为“已修复”的 Bug 进行回归测试 经验证，当前 Bug 不存在，且未引入新的 Bug，则认为验证通过。 经验证，若原有 Bug 仍然存在，则激活本 Bug； 经验证，原有 Bug 不存在，但引入了新的 Bug，则提交新的 Bug。 回归测试通过后，需确保 Bug 对应用例已更新至对应功能的测试用例中。 3.2.6 缺陷关闭 经分析，不需处理或已修复且验证通过的 Bug 可关闭。 不管缺陷如何处理，缺陷关闭需由测试工程师验证后关闭； 若已指派测试工程师则由当前指派的测试工程师负责，若未指派则由测试组长负责。 编制： 李艳 审核： 祁彩云"
  },
  "doc/研发管理制度规范/CNC平台-软件测试流程&过程规范-R3.html": {
    "href": "doc/研发管理制度规范/CNC平台-软件测试流程&过程规范-R3.html",
    "title": "CNC 平台-软件测试流程&过程规范",
    "keywords": "CNC 平台-软件测试流程&过程规范 版次：2021年08月23日 第3版 类型：程序文件 上海维宏电子科技股份有限公司 版权所有 修改历史 文件版本 修改前文件版本 主要修订内容和原因 修订人 修订日期 R1 新建 汪腾霞 2017-07-10 R2 R1 1） 加入测试任务提前审核的相关要求； 2） 准入、准出准则直接放在各活动后面， 冒烟测试准出单独定义； 3） 对部分要求过细的规则，进行修调或删减， 以便更合理实施。 4） 增加“通用测试制定原则”章节。 汪腾霞 2018-12-23 R3 R2 5） 基于软件部之前定义的版本， 在此基础上 更新了 CNC 平台当前的流程及要求。 祁彩云 2021-08-23 1 引言 1.1 编写目的 测试作为公司产品开发的重要环节， 明确的测试过程、 规范的测试行为， 可以提高软件开发工作的质量和效率。 1.2 读者对象 CNC 软件平台的测试团队。 2 术语/定义 为了统一认识，此处给出公司内部关于测试过程中的相关术语的定义。 编号 名称 定义 1 测试流程 从接收任务到任务测试结束经历的一系列有序的测试活动，即为测试流程。包括测试需求分析&计划、测试设计、测试准备、测试执行、测试评估、测试结束，部分活动可能会交替、反复。 2 测试执行阶段 指在成型的产品上， 按一定的输入/操作要求进行执行，以比对实际结果与预期结果是否一致的过程。 3 输入 开展特定测试活动需要的程序、文档、数据、软件、硬件。 4 输出 某一测试活动结束需提供的产出。 5 输入准则 测试活动的输入， 需满足的条件。 6 输出准则 标记特定测试活动完成的条件。 7 测试点 根据测试范围以相对抽象的形式描述测试思路和预期。不要求提供详细的操作步骤或操作细节。常以 Excel 表格的形式呈现。 8 测试用例 如果说测试点比较抽象，那测试用例就明确规定了测试的前提条件、操作步骤、输入数据以及预期结果。不同的人根据同一测试用例执行结果应该能达到 80% 的相同效果。 9 测试执行记录 测试用例/测试点在实际的软件上执行的结果记录。 10 通用测试 即软件中常用/基本业务功能的正向操作测试，或典型异常操作测试，通常外发类软件版本都需要进行此项测试。 11 用户情景 TFS 里面的一个模板，团队内容用来管理版本范围。 3 测试流程 3.1 流程图 3.2 过程详解 编号 过程名 描述 负责人 审核人 备注 1 测试计划 & 需 求 分 析 1. 根据 CNC 客户月度发布计划与优先级清单 ，协同开发规划组件发布版本，并在 TFS 内创建 [用户情景]进行版本的范围管 理。 2. 测试计划主要基于组件发布计划、组件复杂度、当前资源情况、人员能力、设备等各方面综合进行测试资源安排和时间计划，并更新到[月度资源看板]。 3. 测试需求分析需根据用户原始需求和开发提供的规格文档，澄清&挖掘需求和应用场景，输出测试需求分析&设计思维导图。 测试计划： 测试主管 测 试 需 求 分 析： 测试工程师 - 测试需求分析见《软件测试需求分解指导 书-R1.doc》 2 测试设计 1. 根据测试需求分析&设计思维导图进行测试点编写或测试用例设计。 2. 完成后提交测试评审，评审参与人包括相关开发、测试，必要情况下邀请产线需求或者验收人员参与。 测试工程师 测试主管 详见《软件测试用例设计指导书-R1.doc》 3 测试准备 1. 搭建测试环境，尽可能模拟真实工作环境。 2. 对开发提交的待测软件进行冒烟测试。 测试工程师 测试责任人 4 测试执行 1. 提测需满足提 测准入准则 ，已经在 TFS Checklist 落实。 2. 所有提测版本必须先进行冒烟测试（Phx 组件同步执行自动化测试）。 3. 所有 Bug 一律通过 TFS 中 Bug 工作项进行跟踪。 测试工程师 测试责任人 提测准入准则参见 Wiki Bug 提交跟踪 详见《缺陷跟踪流程-R1.doc》 5 测试评估 1. 测试完毕后提交质量评估表，评审通过后方可发布。 2. 评审不通过需补充测试，或者按照评审要求修订后再次评审。 测试主管 - 平台质量保证- 组件质量评估表 （模板） -R1.0.xlsx 6 测试结束 1. 评估通过，则测试任务完成。 2. 归档本次测试相关资料，以便后续查证或使用，相关准出已经在 TFS Checklist 落实。 3. 对测试环境进行检查和必要复位。 测试工程师 - 归档路径 表格 1 测试过程释义 4 测试过程规范细则 4.1 测试需求分析&计划 输入： CNC 客户月度发布计划与优先级清单 、TFS[用户情景]管理的版本范围清单、TFS 工作项、用户/开发需求分析（/+规格书、/+设计方案、/+修改说明） 等。 输出： 测试需求分析&设计思维导图、月度资源看板。 输出准则： 1） 项目类型的测试任务，需提供测试方案&测试计划，可参见 《测试计划&方案-项目名-模板-R1.doc》 。 2） TFS 中标记需要测试评审的工作项需组织测试设计评审。 4.2 测试设计 输入： 测试需求分析&设计思维导图。 输出： 测试用例/测试点。 输出准则： 1） 本次新增功能，需提供可复用测试用例。 2） 已存在可复用测试用例的功能变更后，需维护已存的测试用例。 3） TFS 中标记需要测试评审的工作项需组织测试用例评审。 4.3 测试准备 输入： 开发提交的待测组件/固件、冒烟测试用例。 输出： 测试环境（手工+自动化测试环境）、冒烟测试通过的组件/固件。 输出准则： 1） 待测版软件冒烟测试不通过则退回。 2） 冒烟测试不通过的 Bug 标记为低级 Bug。 4.4 测试执行 输入： 测试用例、冒烟测试通过的组件/固件。 输出： 测试执行记录、TFS 中的工作项记录。 输出准则： 1） 按照 发布准出 完成执行工作（TFS 准出 Checklist）。 2） 按照 CNC-发布标准 完成执行工作。 4.5 测试评估 输入： 测试执行记录、缺陷记录、测试通过的软件、组件发布质量评估表、发布公告。 输出： 固件发布质量评估表、发布准则符合度评估。（固件有缺失，目前开发负责发布） 输出准则： 组件发布质量评估表通过测试主管评审。 4.6 测试结束 输入： 所有过程文档。 输出： 发布公告通知、过程文档归档。 编制： 祁彩云 审核： CNC 测试团队"
  },
  "doc/研发管理制度规范/CodeReview指南.html": {
    "href": "doc/研发管理制度规范/CodeReview指南.html",
    "title": "Code Review 指南",
    "keywords": "Code Review 指南 1 综述 在评审之前请先了解评审的目的 不同类型的代码评审具有不同的目的。项目成员的代码评审应关注代码怎样才能符合项目标准，以及代码是否正确地解决了问题。我们希望熟悉代码库的人，能对项目代码进行更详细的审查。用于年度审查的代码评审，应侧重于一些更大的创意和最佳实践。这些类型的评审应该能发现可以改进的实践模式。 所有开发人员都可以参与评审 所有开发人员都可以审核代码，不单单是有经验的开发人员。 评审的频率要高 代码评审与其他技能一样，收益来源于实践。要常用检查清单进行代码评审，还要注意收集关于评审质量的一些反馈：评审有帮助吗？评审的全面吗？会不会有些吹毛求疵呢？评审符合目的吗？评审的方式可以吗？ 最好有两位评审人参与评审 评审人不一定越多越好，但是可以从多个角度看待这个问题。每个人都有自己的优势和观点，一个人可能发现其他人没有发现的问题。所以如果是核心代码，可能需要四个评审人参与评审，但一般也不要超过四个。 2 角色 2.1 评审人 首先关注正确性，然后才是可读性和可理解性 代码是否解决了正确的问题？是否有不用修改代码就能解决问题的方法？这段代码是否正确的解决了问题？在确定代码正确无误后，看一下现在的实现方式是否可读和可理解。是否有更简洁明了的方法？ 代码背景不仅包括特殊的技术要求（开发代码时所遵循的约束），还包括时间、截止日期、团队能力以及未来的规划 对于代码中明显的错误可以直接指出，但如果不确定是不是错误时，最好是先问一下：为什么要这么写呢？是否考虑过<插入“正确”的选项>？ 鼓励使用工具 理想情况下，代码分析工具可以检查的内容是不需要再进行评审的。但如果发现代码中还存在问题，那应该先解决工具使用问题。 善于使用检查清单 不要每次评审代码时都临时准备检查清单。即使没有书面清单，在心理上也应该有一个可以参考的检查清单。建议使用我们提供的评审清单。 提供可行的改进方法 评审时不要一味的批评，还要给出可行的修改方案。 不要以你的做事风格去要求别人，因为它并不是标准 代码评审不是要检查代码是否与你的想法一致，而是要检查代码是否正确，是否符合目标和所有的“性能”（可读性，可维护性等）要求。 解决问题的方法有很多，你提出的观点会有一定帮助，但不代表被评审人的方法就是错误的，他只是用另一种实现方式解决了问题。 再次强调要互相学习：使用不同的实现方式解决问题，在提升被评审人思维的同时，也可以提升你自己的。 评审没发现问题也很正常 评审时要注意细节，但不要挑刺。如果实在没有发现可改进的地方，那就只给出正面的评价。 不要仅仅评审代码，还要提升开发人员的技能 开发人员所做的不只是编码，我们也希望大家全部的技能都有所提升。 不要私下随意谈论评审内容 在代码评审中发生的事情，就让它们停留在代码评审中吧。 一般来说，你发现的那些问题是你和被评审人之间的隐私。你可以在必要时与他人分享，例如需要完成绩效评估，或向项目负责人建议谁更适合某项特殊任务时。但千万不要让那些问题成为办公室随意议论、八卦的话题。 2.2 被评审人 提供代码上下文 协助评审人员了解你的代码是如何嵌入整个程序中的。对于一些特殊的实现方法，要给出说明。还要告诉审核人员一些开发时的约束条件。 写好代码提交注释 好的代码提交注释，可以给将来的读者（包括代码评审人以及将来重新阅读代码的你）提供一些重要信息：代码修改的目的，以及代码上下文说明。 好的注释是既清晰又简洁的：不需要太详细，也不要太简短，不要写成小说或短篇小说。如果感觉以后会需要更多信息，则可以把这些信息记录在README中。 提交评审的代码量不要太多 当使用“Pull Request”方式进行评审时，提交的代码量要尽量少一些。每次评审应该是小而有针对性的，以便可以评审到所有代码。对于那些多次变更的功能分支，在代码质量和集成方面一般都会有问题。 提交量准则：不超过5个文件；300-600行代码；一天的工作量；20-60分钟的代码评审时间。 如果提交代码量超过了以上准则，应该考虑拆分成多次进行评审。 提交评审的代码要完整，并且经过了自测和自检 如果代码还没有成功构建或没有通过自测，请不要提交它进行评审。 不要存在压力或反感情绪 评审你的代码其实是一件好事，可以帮助你变得更好，还能帮助我们为客户提供更好的产品。如果将来你回过头看你现在编写的代码，你也会发现一些可以改进的地方。经验丰富的开发人员可能会发现一些可以进一步改进的问题点，利用他们的经验可以帮助你更快地成长。 保持积极的心态 不要有那种抵抗心理，评审代码的人员其实是在试图帮助你。你不用接受所有的评论，但项目负责人给出的建议你可能不得不接受，这并不意味着一定是你错了。因为即使再优秀的人，偶尔也会固执己见。尽量抛开自我，去了解审核人的想法，尤其当审核人更有经验时。有时显而易见的方法反而会带来陷阱，而只有那些经验丰富的人才知道如何避免。 不要仅提供代码，最好也提供相关资料 如果你有相关的资料，也要提供出来。确保提供了足够的背景信息，以便审核人员可以提供更有价值的反馈。"
  },
  "doc/研发管理制度规范/Commitmessage编写指南-R1.html": {
    "href": "doc/研发管理制度规范/Commitmessage编写指南-R1.html",
    "title": "Commit message 编写指南（TFS 版）",
    "keywords": "Commit message 编写指南（TFS 版） 版次：2020年2月15日 第1.0版 类型：程序文件 作者：Phoenix 架构平台 上海维宏电子科技股份有限公司 版权所有 《软件开发过程要求》规定，每次往服务器上提交代码时，必须填写“提交注释”（以下使用 “Commit message” 表示），否则不允许提交代码。对于 Commit massage 的格式并没有统一的规范，因此大家填写的内容很凌乱。 通常，Commit message 应该清晰明了，说明本次提交代码的目的。目前，社区有多种 Commit message 的写法规范。本文参考 Angular 规范 （目前使用最广的规范），针对 Phoenix 开发过程定义标准的 Commit message 编写指南。 1. Commit message 的作用 格式化的 Commit message 有几个好处： 提供更多的历史信息，方便快速浏览。 对于遵循编写规范的 Commit message， 只需要看首行，就知道某次 Commit 的目的。 可以过滤某些 Commit （比如文档改动），便于快速查找信息。 比如，可以通过对提交信息过滤显示本次发布新增加的功能。 可以直接从 Commit 生成 Change log。 Change log 是发布新版本时，用来说明与上一个版本差异的文档，详见后文。 2. Commit message 的格式 每次提交，Commit message 都包括三个部分： Header、Body 和 Footer。 <type>(<scope>): <subject> // 空一行 <body> // 空一行 <footer> 其中， Header 是必需的 ，Body 和 Footer 可以省略。 为了避免自动换行影响美观，要求每一行的字符数 不超过72个 。 2.1 Header Header 部分只有一行，包括三个字段： type （必需）、 scope （可选）和 subject （必需）。 （1）type type 用于说明 Commit 的类别，只允许使用下面7个标识： - feat: 新功能 （feature） - fix: 修补 bug - docs: 文档（documentation） - style: 格式（不影响代码运行的变动） - refactor: 重构（即不是新增功能，也不是修改 bug 的代码变动） - test: 增加测试 - chore: 构建过程或辅助工具的变动 如果 type 为 feat 和 fix ，则该 Commit 将肯定出现在 Change log 之中。其他情况（ docs 、 chore 、 style 、 refactor 、 test ）则由提交人决定是否放入 Change log中；建议不要放入。 （2）scope scope 用于说明 Commit 影响的范围，比如数据层、控制层、视图层等，视项目不同而不同。 （3）subject subject 是 Commit 目的的简短描述，不超过50个字符。 以动词开头，使用第一人称现在时，比如 change ，而不是 changed 或 changes 第一个字母小写 结尾不加句号（ . ） 2.2 Body Body 部分是对本次 Commit 的详细描述，可以分成多行。下面是一个范例。 More detailed explanatory text, if necessary. Wrap it to about 72 characters or so. Further paragraphs come after blank lines. - Bullet points are okay, too - Use a hanging indent 有两个注意点： （1）使用第一人称现在时，比如使用 change 而不是 changed 或 changes 。 （2）应该说明代码变动的动机，以及与以前行为的对比。 2.3 Footer Footer 部分只用于两种情况： （1）不兼容变动 如果当前代码与上一个版本不兼容，则 Footer 部分以 BREAKING CHANGE 开头，后面是对变动的描述、以及变动理由和迁移方法。 BREAKING CHANGE: 修改过期的 scope bindings 定义. 请参照以下示例要迁移代码： Before: scope: { myAttr: 'attribute', } After: scope: { myAttr: '@', } 移除的属性值已经不在有效，因此不应有代码使用它。 （2）关闭 BUG 如果当前 Commit 是针对某个 bug，那么可以在 Footer 部分关闭这个 bug。 Closes #234 也可以一次关闭多个 bug。 Closes #123, #245, #992 2.4 Revert 还有一种特殊情况，如果当前 Commit 用于撤销以前的 Commit，则必须以 revert 开头，后面跟被撤销 Commit 的 Header。 revert: feat(pencil): add 'graphiteWidth' option reverts Commit 11212 Body 部分的格式是固定的，必须写成 reverts Commit <变更集号>. 。 如果当前 Commit 与被撤销的 Commit，在同一个发布 （release） 里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 Commit，会出现在 Change log 的 Reverts 小标题下面。 2.5 案例 feat 案例： 在案例 body 的序列中有用到 - 或 * ， 目前不做限制。 feat(CsvExproter): print '0' instead of '-' in the CSV report - CsvExporter now prints '0' instead of '-' in the report - Add PrintZeroValuesInContent option in SummaryStyle to control it (by default it is false) - Add tests to cover changed behavior Closes #1168 feat: resolve xref recursively (#4314) * resolve xref recursively * fix test. ParentNode doesn't work as expected... chore 案例： chore: cleanup docs/architecture (#15489) Autocleanup of MD022 and MD009 chore: clenaup docs/fsharp (#15585) Ran `markdownlint --fix \"docs/fsharp/**/*.md\"` to fix MD009 and MD022 Breaking changes 案例： 这个案例没有描述迁移方案，目前待定。 Breaking changes： improvements (#16613) * move winforms breaking changes to compatibility section * update core toc; add link to unsupported apis * add more bookmarks; change title on some include files * fix typo; add horizontal line; toc title change; add contextual toc link to unavailable techs revert 案例： revert \"Improve call counting mechanism (#1457)\" (#30105) * Revert \"Revert \"Disable test based on #129 (#130)\" (#2310)\" This reverts commit 427cd91. * Revert \"Fail FuncEval if slot backpatching lock is held by any thread (#2380)\" This reverts commit fc06054. * Revert \"Improve call counting mechanism (#1457)\" This reverts commit 3a457cb. test 案例： test: add missing test cases for ensure and is-ignored (#987) * test(esnure): add tests for untested code paths * test(is-ignored): add test case for untested code path doc 案例： docs(angular.copy): fix `getter`/`setter` formatting Fix the formatting of `getter`/`setter` in the known limitations section of the `angular.copy()` docs. refactor 案例： refactor: use builtin Object.values instead of lodash/values (#968) * refactor: use builtin Object.values instead of lodash 3. 关于 Commit message 工具 git 世界中有不少撰写合格 Commit message 的工具，如： Commitizen 。 但是，基于 TFS 的辅助工具少之又少，所以在此次编写指南中不建议使用工具，而是需要记住该规范中的内容，作为开发人员编写提交信息的基本能力。 关于 Commit message 内容的校验，前期以人工检查为主，后期会参考行业工具 validate-commit-msg 来定制检查工具。 4. 生成 Change log 如果所有 Commit massage 都符合 Angular 格式，那么发布新版本时，Change log 就可以用脚本自动生成（需要设计脚本）。 生成的文档包括以下三个部分： New features Bug fixes Breaking changes 每个部分都会罗列相关的 Commit， 并且有指向这些 Commit 的链接。当然，生成的文档允许手动修改，所以发布前，还可以添加其他内容。 例如： 3.1.0 (2018-10-22) Bug Fixes work around broken console methods ( 873e4f9 ), closes /github.com/angular/angular.js/pull/16644#issuecomment-407680658 browser: emit 'browsers_change' in collection ( #3183 ) ( 7634e71 ) config: remove phantomjs in favor of chrome headless ( #3175 ) ( 0f8b2b1 ) init: Support ChromeHeadless in validateBrowser ( #3110 ) ( eeadcf2 ) middleware: simplify stripHost. ( #3115 ) ( d65e911 ) runner: Do not persist grep option across runs ( #3121 ) ( c91cb81 ) runner: Make exit code configurable when tests are failing ( #3116 ) ( 74da748 ), closes #1300 test/client: revert const/let changes. ( c097ecf ) Features config: Add config option for browser socket timeout ( #3102 ) ( 11e3a9d ), closes #2927 config: add support for ES modules ( e811adb ) frameworks: report start() errors back to server. ( #3126 ) ( 8257375 ) server: .dom files include HTML tags in page. ( #3178 ) ( 4651524 ) server: Add public API to force a file refresh ( dab8a82 ) server: Add stop method ( #3153 ) ( 6d96d8e ), closes #3149 server: Add support for encoded source files ( #3123 ) ( 68b37d3 ) 3.0.0 (2018-08-09) Bug Fixes config: wait 20s for browser activity. ( #3087 ) ( 88b977f ) config: Wait 30s for browser activity per Travis. ( #3091 ) ( f6d2f0e ) init: add \"ChromeHeadless\" to the browsers' options ( #3096 ) ( 56fda53 ) server: Exit clean on unhandledRejections. ( #3092 ) ( 02f54c6 ), closes #3064 travis: Up the socket timeout 2->20s. ( #3103 ) ( 732396a ), closes #3102 travis: use the value not the key name. ( #3097 ) ( 90f5546 ) travis: validate TRAVIS_Commit if TRAVIS_PULL_REQUEST_SHA is not set. ( #3094 ) ( fba5d36 ) travis: Validate TRAVIS_PULL_REQUEST_SHA rather than TRAVIS_Commit. ( #3093 ) ( a58fa45 ) BREAKING CHANGES Drop Support for Nodejs4 ( #3082 ) 5. 相关文件 《 软件开发过程要求 》 版本信息 版本 日期 修改人 修改内容 1.0 2020/2/15 Phoenix 架构平台 初版建立"
  },
  "doc/研发管理制度规范/includes/设计中.html": {
    "href": "doc/研发管理制度规范/includes/设计中.html",
    "title": "",
    "keywords": "Important 本制度还在更新中， 尚未处于发布中。"
  },
  "doc/研发管理制度规范/MSF团队/MSF团队必读.html": {
    "href": "doc/研发管理制度规范/MSF团队/MSF团队必读.html",
    "title": "MSF团队必读",
    "keywords": "MSF团队必读 引言 目的 2022年内网研发团队将使用MSF开发模型，团队内部需要深入学习MSF，前期软件部组织了首批MSF先锋队学习培训，且部分成员目前已经参与到项目实践中，在此过程中积累了相关的自学、培训和实践经验，本文档基于这些经验，进行复盘总结，形成MSF学习指南，希望可以在大家学习过程中给予引导，能够达到快速学习掌握MSF精髓，并能够结合产品项目特点落实到实践中。 阅读者及阅读建议 本文档为参与或将要参与MSF项目的团队角色，包括产品管理、程序管理、架构设计师、开发工程师、测试工程师、UE角色。 初学者可以按照书籍阅读、MSF培训大纲、制度规范&MSF指导书等循序渐进进行学习，也可以根据自身情况进行调整。 书籍阅读，帮助你系统理解MSF框架，很必要，可以避免在工作中被忽悠，当然get多少知识因人而异。参考《MSF精髓》阅读建议， https://drive.weixin.qq.com/s?k=AKUAEQfRAAw5zTh5ou MSF培训大纲-通识，快速get MSF框架知识。 制度规范&MSF指导书，开展项目实践必读，涉及相关输出及要求，评审范围。 范围 本文主要从培训大纲&资料、制度规范文档、学习实践指导书等方面，提供可以循序渐进的知识库，让MSF团队的各个角色能够快速掌握MSF。 资料仓库 学习&培训资料 企业微信微盘：/软件部学习资料共享/MSF资料汇总 MSF精髓-整理版，MSF先锋队员根据MSF书籍整理的，方便大家进行检索。 MSF培训大纲-通识，快速了解MSF原则、团队模型和历程。 MSF首批培训-先锋队，先锋队培训学习计划、阶段性学习总结。 MSF实践参考，MSF内部项目实践的一些文档，有些已经发布在github.io上。 MSF 案例&书籍等，MSF实践的一些书籍及案例，比如《移山之道》等。 制度规范文件&指导书 文档都在github上，欢迎有问题直接在线编辑。目前包括研发管理制度、研发文档编写指南、UI设计规范三大块内容，本文档涉及到的制度规范都在研发管理制度里面。 发布链接： https://weihong-phoenix.github.io/ 重点知识 MSF框架包括 两个模型、三个准则、五大历程、七个代言群。 两个模型，团队模型、过程模型。 三个准则，项目管理准则、风险管理准则、就绪管理准则 五大历程，展望历程、计划历程、构建历程、稳定历程、部署历程 七个代言群，产品管理、程序管理、架构设计、开发、测试、UE和发布/运维 制度规范&实践指导 资产库管理 该文档定义了MSF项目的资产代码库目录结构、文件管理规范。 文档路径： 软件项目目录与文件管理规范 文档编写规范 该文档定义了研发技术文档编写的基本规范。 文档路径： 研发文档编写规范 实践指导 该文档定义了平台和产线开展MSF项目展望和计划各个历程的关键活动、输出及评审要求。 文档路径： MSF详细活动指导 FAQ 学习、培训及实践中遇到的常见问题、建议解决方案或最佳实践等，供大家参考，如果你有问题和建议，也请及时反馈更新。 MSF框架类 Q：为啥有团队模型呢？ A：团队模型主要是基于专业能力及代言的立场决定的。 团队中有些角色是可以合并， 但有些不行， 具体见《微软研发软件的奥秘：MSF精髓》4.2章节。 Q：能否通俗一点讲清五大历程及管理历程所关心的事？ A：众所周知， 软件研发领域越到研发后期发现的问题， 修复的代价越高， 往往都是指数级的差异。 开发人员最讨厌的事情之一就是需求又变了。 这往往就是前期的工作没了解清楚，过程模型就是希望强调在前期多做些这类工作， 使后期的变化在一定范围内。 管理历程 该MSF解决方案的前期调研， 并发起项目。 指导团队完成五大历程的活动；通过优化流程， 团队组织， 持续提升团队的能力和效率，改进解决方案的质量与流程，使其达到最佳状态。 展望历程 解决的主要问题是， 这个产品主要满足什么样的需求， 团队大概用什么样的产品满足该需求， 从而判断是否值得投入研发。这可能主要要明确产品要做什么， 投入大概多大， 产出可能有多大， 但这些问题其实都很难回答， 判断基本上需要靠团队， 能否说服公司高层对该产品的投入。 计划历程 对产品功能进行细化， 列出产品功能的主要技术困难点， 并形成方案； 然后列出开发计划， 预估可能会有的风险。 构建历程 主要是实现解决方案， 并给出对应的测试用例。 稳定历程 测试及验收。 部署历程 汇总版本发布记录， 并发布软件。 Important 注意：每个历程是可以重叠的， 而不是阶段性的。 Q：远景/范围文件里面的假设是什么? A:需要团队研发人员引起重视的、敏感的约束，模板为通用的模板，如果某些项目该部分确实没 有，可以写\"无\"。有些是前期未能够识别的，可以先标注TBD，后期遇到问题再补充。 Q:远景范围里面需要描述的风险和风险文件里面需要描述的风险是否有重复? A:远景/范围里面的风险可以不写。 Q： 设立一个MSF团队的标准或评估维度有哪些呀？ A： 一个产品型号，一个MSF团队 原则上一个产品一个仓库，如果多个产品共用一个仓库的，其实可以作为一个MSF团队管理 至少需要3个全职的角色来完成 根据项目的复杂度、时间跨度、迭代周期 综合考虑是否需要组件一个MSF团队，如果这件事情只是某一个或者两个角色的工作，不需要组件团队，把这个事情当成任务安排到MSF团队或者是MSF之外的功能团队。 除去MSF团队，也应该有些功能团队 资产管理类 Q：仓库中的doc\\srs下的目录大纲如何组织？ A：目前该问题是在实践团队中碰到较多问题， 团队首先需要规划该srs的目录大纲， 再细化对应的md文件。 文档编写类 Q：项目的约束条件和产品的约束条件的差别？ A：项目的约束条件一般从时间、资源和质量目标等方面进行约束。 产品的约束条件一般从操作系统、硬件、网络通信及其协议、质量特性需求、法规政策等方面的局限。 Q:SRS写到什么程度好? A:可以参考以下基本原则: 如果设计与开发人员需要SRS的作者额外的解释才能理解需求并进行设计和实现，则需要在SRS里面进行细化。 如果测试人员需要SRS的作者额外的解释才能理解需求并进行测试用例的设计，则需要在SRS 里面进行细化。 其它的想法，仅供参考： SRS虽然是国标，是规范，是模板。其实提供了一种思路帮助大家去梳理如何把一个产品级的需求描述清楚，确实能够在研发过程中指导大家，减少不必要的沟通。我们是做产品的，不是短期的项目，文档是比较重要的资产，并且我们的很多产品，相似度比较高，好的SRS增强了复用性，长期来看提高了效率。 SRS其实是【需求分析】之后的输出，任何需求如果没有经过需求分析而直接实践，后期出现实现的功能和用户需要的不同，设计方案评审时发现原来是需求不合理，甚至测试的时候发现是需求问题等等，其实也是变相的在降低效率。既然是 分析 工作，那肯定需要掌握的知识技能比较多，所以开始觉得难，觉得无从下手，个人感觉都比较正常，多看看优秀的案例。 SRS中的功能需求规格部分，重点关注业务逻辑，如果想把业务逻辑描述清楚，文字能力有限，则用原型图。 SRS的编写有一定的方法论，但是关键的还是要站在阅读者的角度去思考如何编写，可能需要大家在实践中慢慢总结和萃取经验。 Q:SRS里面的需要呈现什么样的用户界面？或者说用户界面设计到哪种程度才可以在SRS中呈现？ A:如果该用户界面不是用户直接提出或者经过充分分析确定的最终界面，不要在SRS里面呈现，或者批注下，最好是先描述为用户故事。 （用户最终界面某种程度上属于设计之后到产出。基本经历3个步骤：1-先描述用户故事 2-再画原型图 3-最后设计最终的用户界面） Q：项目的约束条件和产品的约束条件的差别 A：项目的约束条件一般从时间、资源和质量目标等方面进行约束。产品的约束条件一般从操作系统、硬件、网络通信及其协议、质量特性需求、法规政策等方面的局限 Q：SRS和用户手册感觉很像？写了SRS还需要用户手册吗？ A： 阅读对象不同。SRS面向的是研发团队的开发和测试、客户（甲方）或者用户。而用户手册【帮助手册/操作说明书】，面向的是使用者，对象不同。 描述的专业性不同。SRS因为面向研发团队，有一定的专业性，比如描述输入可能用到数据类型，会描述用户比较难看到的异常场景等。用户手册一定要用用户看得懂的语言描述。 作用不同。SRS是整个开发的依据，可以对后期的开发工作起指导作用，是项目计划、验收的依据。也是《用户手册》的依据。《用户手册》是指导用户快速入门，告诉使用者我们有哪些功能，如何使用等。 Q:用户故事、功能规格、SRS之间的关系？ A: 用户故事的描述体现功能的使用角色、能力和价值。 功能规格说明书在描述具体的功能时，功能的概述其实是描述的该功能具备的能力。 功能规格说明书，只是SRS文档里面的子集。 用户故事可以在三个地方进行使用： 1.产品远景文件里面（README.md）描述高层需求。 2.SRS里面的第二章节 总体描述-产品功能描述。 3.功能规格说明书中的功能概述部分。 1.2.3.几乎是层层分解，逐步细化的过程。 Q：功能规格说明书到底写到什么程度才算达标？ A： 和平台两个资深开发沟通，如果提供的SRS给研发团队可以提供80%需要的信息，则这个文档在当前就是成功的，另外的20%可以在渐进明细的过程中获取到。但是反之，如果你只提供了20%的信息，另外的80%需要通过口头不断的沟通，甚至到最后测试的时候发现软件有问题，或者发布后用户反馈不符合需求，那绝对是失败的，不如把后期浪费的时间放在前期。 重点是能够把功能描述清楚，确实可以指导后续的开发、测试、程序管理、UE进行相关的实现、测试计划和用例、项目计划和用户手册的编写。这个完善是个层层递进的工作。建议是计划阶段可以把业务逻辑描述清楚，构建阶段不断优化，确保满足研发团队不同角色的需求。 Important 注意:1. 如果需要产品甲方查询的信息，可以写在SRS里面。2. 需求不能够侵入设计领域。 Q:功能描述以什么形式进行定义，无法写的和SRS模板一样? A:功能需求描述可以采用Use Case、IPO(模板里面用的这个模型)或者其它规范化的模型进行 描述，比如实体-关系图(一般有数据库相关的系统采用)、状态转换图、数据流图、对话图 等。一般涉及到用户操作的功能采用Use Case，API相关的用IPO较多。"
  },
  "doc/研发管理制度规范/Phoenix源码分支工作流-R2.html": {
    "href": "doc/研发管理制度规范/Phoenix源码分支工作流-R2.html",
    "title": "Phoenix 源码分支工作流",
    "keywords": "Phoenix 源码分支工作流 版次：2021年3月25日 第2.0版 类型：技术文件 作者：Phoenix 架构平台 上海维宏电子科技股份有限公司 版权所有 本工作流基于 主干开发，分支发布模式 以及我们组件管理的特点进行定义。 工作方式 历史分支 开发分支 发布分支 发布 fix 版本 示例 创建开发分支 大家开发新功能 小红开始准备发布 小红完成发布 最终用户发现 Bug 该工作流定义了一个围绕着项目发布的严格分支模型。提供了用于一个健壮的管理项目的框架。该工作流为不同的分支分配一个很明确的角色，并定义分支之间如何和什么时候进行交互。 1. 工作方式 工作流仍然以主分支作为交互中心。衍生出开发分支进行开发、发行分支进行测试发行、修复分支进行 bug 修复，一切都围绕着控制一个稳定的主分支并持续改进为本。 注意 ：与第1版有区别，这里的主分支 master 由开发者代码审核、单元测试保证质量。release 分支发布的组件由 CNC 测试组进行功能测试。 1.1 历史分支 该工作流通过多个 release 分支记录项目的历史。 1.2 开发分支 开发新功能与修复Bug时，开发人员开始的时候从 master 分支上拉出 feature 或 bugfix 分支。 在对应的分支上做所有的开发工作，一旦分支完成 feature 或 bugfix 分支不再和 master 交互。 feature 分支 bugfix 分支 常用分支约定： feature 分支的命名为 feature/*-workitem ） bugfix 分支的命名为 bugfix/*-workitem ） * 代表工作项编号 workitem 代表工作简短描述（英文） 1.3 发布分支 一旦 master 分支上有了做一次发布（或者说快到了既定的发布日）的足够功能，就从 master 分支上拉出一个 release 分支。 新建的分支用于开始发布循环，所以从这个时间点开始之后新的功能不能再加到 release 分支上—— 这个分支只应该做 bug 修复、文档生成和其它面向发布任务。 使用一个用于发布准备的专门分支，使得一个团队可以在完善当前的发布版本的同时，另一个团队可以继续开发下个版本的功能。 这也打造定义良好的开发阶段（比如，可以很轻松地说，『这周我们要做准备发布版本4.0』，并且在仓库的目录结构中可以实际看到）。 常用的分支约定： 从 master 拉出 release 分支。 分支的命名为 release-* ， * 代表版本号。 release 分支打好标签。 1.4 发布 fix 版本 当某个已发布的版本发现问题，由于新版本不兼容，或者变更太大无法升级时，需要在原发布分支的基础上进行修正。 2. 示例 下面的示例演示本工作流如何用于管理单个发布循环。假设你已经创建了一个主分支项目。 2.1 准备主分支 第一步由仓库管理员初始化 master 分支，以后这个分支将会包含了项目的全部历史。 2.2 大家开发新功能 在集成源代码管理规则中大多数的开发都是所有人面对同一个开发分支进行开发和提交。 特殊情况下，如果开发过程相对复杂原则上允许对 master 分支继续进行分支开发， 分支出来的功能分支要尽量早点合并，并自行面对多分支情况下管理上的复杂度。 2.3 小红开始准备发布 这个时候小明正在实现他的功能，小红开始准备她的第一个项目正式发布。 像功能开发一样，她用一个新的分支来做发布准备。这一步也确定了发布的版本号： 这个分支是清理发布、执行所有测试、更新文档和其它为下个发布做准备操作的地方，像是一个专门用于改善发布的功能分支。 只要小红创建这个 release 分支并通过测试组验证，这个发布就是功能冻结的。任何不在 release 分支中的新功能都推到下个发布循环中。 2.4 小红完成发布 一旦准备好了对外发布，小红会通知发布团队已就绪，由发布团队集成软件与发布说明，完成发布。 2.5 最终用户发现 Bug 对外发布后，小红回去和小明一起做下个发布的新功能开发，直到有最终用户开了一个 Ticket 抱怨当前版本的一个 Bug 。 为了处理 Bug ，小红（或小明）从 master 分支上拉出了一个 bugfix 分支，提交修改以解决问题，然后直接合并回 master 分支。 然后就可以安全地删除这个分支了。 版本信息 版本 日期 修改人 修改内容 2.0 2021/3/25 Phoenix 架构平台 按照主干开发分支发布模式更新案例； master 作为主工作分支 1.0 2016/7/6 Phoenix 架构平台 初版建立"
  },
  "doc/研发管理制度规范/Phoenix组件发行工作流.html": {
    "href": "doc/研发管理制度规范/Phoenix组件发行工作流.html",
    "title": "Phoenix 组件发行工作流",
    "keywords": "Phoenix 组件发行工作流 版次：2016年9月5日 第1.0版 类型：技术文件 作者：Phoenix 架构平台 上海维宏电子科技股份有限公司 版权所有 此文档是帮助大家做好组件的发布工作，避免出现一些由于发行而给产品或后期维护带来的严重问题。 1. 发行工作流程图 2. 发行检查清单 是否是在分支修改或添加的功能？ 是否把代码全部上传到服务器？ 是否覆盖了单元测试？ 是否把单元测试上传到服务器？ 是否填写的单元测试覆盖表？ 单元测试是否全部通过？ 发布的组件的版本号升级是否符合？[《Phoenix 组件版本管理规则》](Phoenix 组件版本管理规则.md) 是否将此次发布的记录填写到 history.md？ 《Phoenix项目记录规范》 填写的发布内容格式是否标准？ 是否是在服务器生成的组件包？ 发行的代码是否进行加密？ histroy.md 是否包含在组件包里？ 是否将生成的组件包经过集成测试且测试通过？ 功能集成测试是否符合测试用例？ 是否将 API 使用说明书（md）上传至 TFS？ 是否更新发行记录到 markdown上？ 是否将发行不兼容版本组件的使用条件和限制更新到发行记录（markdown）上？ 是否从服务器将发布的组件包上传至 51 服务器？ 是否将源码打标签？ 源码标签是否符合？ 《Phoenix 源代码标签使用规则》 是否发布了发布公告？ 组件的依赖关系是否合理？ 版本信息 版本 日期 修改人 修改内容 1.0 2016/9/5 Phoenix 架构平台 初版建立"
  },
  "doc/研发管理制度规范/Phoenix组件版本管理规则.html": {
    "href": "doc/研发管理制度规范/Phoenix组件版本管理规则.html",
    "title": "Phoenix 组件版本管理规则",
    "keywords": "Phoenix 组件版本管理规则 版次：2018年5月29日 第2.0版 类型：技术文件 作者：Phoenix 架构平台 上海维宏电子科技股份有限公司 版权所有 1. 定义版本号 主版本号.子版本号.修正版本号.保留版本号[-先行版本号[序号]] Major.Minor.Revision.Reserve[-Preview[SerialNo]] 1.1 主版本号 具有相同名称但不同主版本号的 DLL 不可互换。这适用于对产品的大量重写，这些重写使得无法实现向后兼容性进而在架构的级别上对 dll 进行整体升级。 Phoenix 测试版版本号从 0 开始，正式版版本号默认从 1 开始，向后递加 1。 1.2 子版本号 副版本号由百进制数字 100 开始。 100 分为两部分：百进制数的\"1\"和十进制数的\"00\"; 十进制： 范围 【00~~99】 ,表示对组件进行功能添加或修改或者功能的显著增强以及修订内容和范围比较广。十进制版本升级时，组件可以保证向上兼容。 百进制： 范围从 【100~~900】 , 往往标识非常大的版本升级，通常接口会有变化 ， 百进制升级时，组件不保证向上兼容。 百进制升级后，十进制必须从\"00\"开始。 1.3 修订版本号 当做了向下兼容的问题修正时修订版本号更新， 如果修订的内容、范围、影响足够广的话可以对子版本号进行兼容性升级并重置修订版本号。 1.4 预留版本号 预留版本号的原意是适应 构建版本号 或 编译版本号 ， 因在现有 Phoenix 版本管理中语义比较弱，故清理掉以上版本语义用作保留版本号，默认为 0。 说明： 有必要的时候这个版本号要重新启用，如：相同源所作的重新编译。这适合于更改处理器、平台或编译器的情况。 1.5 先行版本号 先行版本号被标注在预留版本号之后，先加上一个连接号在加上特定语义的标识符来修饰。 先行版本的优先级低于相关联的标准版本，被标上先行版本则表示这个版本并非稳定版本而且可能无法达到兼容的需求。 目前支持的先行版本号有： alpha : 开发测试版本号，满足一定功能需求，可以通过 Dev 分支发布。 alpha1-alpha9 : alpha 版本号支持序号升级，目前只支持 1~9 个版本号数量，超过请升级数字版本号。 警告： alpha版本软件 一定不能 用到生产环境。因为它是危险的，不保证质量、完整性、代码追溯，会出现意料不到的问题而没法修复。 补充说明 ： 为什么会有 alpha1-alpha9 ？ 因为在开发阶段 Dev 版本可能会出现持续的 发布-集成-测试 工作，面对开发过程数字版本号的定义意义不大往往有浪费成本，所以 alpha+num 版本号能很好的解决测试问题。 2 项目版本号的设置 2.1 C++项目版本号 以 MCC 项目为例：右键 MCC 项目 - 属性 - 添加 - 资源 - 进入资源选择页面。 在资源选择页面选择 Version 条目 并双击添加版本资源。 选择版本资源后 进入版本编辑界面，修改里面上下两处文件版本信息， 产品版本信息要跟文件版本信息同步。 2.2 C# 项目版本号 定义版本号 如下图所示：右键项目属性 -->在“应用程序页面”下选择“程序集信息”按钮： 然后对公司信息和版本号进行填写： 修改完之后会在文件 AssembyInfo.cs 下面看到以下代码： [assembly: AssemblyVersion(\"1.100.0.0\")] [assembly: AssemblyFileVersion(\"1.100.0.0\")] 3. 关于语义化版本 2.0.0 在软件管理的领域里存在着被称作“依赖地狱”的死亡之谷，系统规模越大，加入的套件越多，你就越有可能在未来的某一天发现自己已深陷绝望之中。 在依赖高的系统中发布新版本套件可能很快会成为恶梦。如果依赖关系过高，可能面临版本控制被锁死的风险（必须对每一个相依套件改版才能完成某次升级）。 而如果依赖关系过于松散，又将无法避免版本的混乱（假设兼容于未来的多个版本已超出了合理数量）。 当你专案的进展因为版本相依被锁死或版本混乱变得不够简便和可靠，就意味着你正处于依赖地狱之中。 作为这个问题的解决方案之一，我提议用一组简单的规则及条件来约束版本号的配置和增长。这些规则是根据（但不局限于）已经被各种封闭、开放源码软件所广泛使用的惯例所设计。 为了让这套理论运作，你必须先有定义好的公共 API 。这可以透过文件定义或代码强制要求来实现。无论如何，这套 API 的清楚明了是十分重要的。 一旦你定义了公共 API，你就可以透过修改相应的版本号来向大家说明你的修改。考虑使用这样的版本号格式：XYZ （ 主版本号.次版本号.修订号 ）修复问题但不影响 API 时，递增修订号； API 保持向下兼容的新增及修改时，递增次版本号；进行不向下兼容的修改时，递增主版本号。 我称这套系统为“语义化的版本控制”，在这套约定下，版本号及其更新方式包含了相邻版本间的底层代码和修改内容的信息。 当前版本号管理规范是基于语义化版本规则 2.0.0 和当前 Phoenix 团队的现状构建的，随着版本的升级会无效靠近语义化版本规则 2.0。 版本信息 版本 日期 修改人 修改内容 2.0 2018/5/29 Phoenix 架构平台 1. 将3,4版本号序列由 <构建.修订> 更新为 <修订.保留> ； 2. 添加先行版本号； 3. 修订对部分版本号不明确的描述； 4. 添加对保留版本号的描述。 1.0 2016/9/5 Phoenix 架构平台 初版建立"
  },
  "doc/研发管理制度规范/产品研发管理制度/MSF详细活动指导-R1.html": {
    "href": "doc/研发管理制度规范/产品研发管理制度/MSF详细活动指导-R1.html",
    "title": "MSF 详细活动指导",
    "keywords": "MSF 详细活动指导 版次：2022年3月3日 第1版 类型：程序文件 部门：软件部 上海维宏电子科技股份有限公司 版权所有 文件版本 修改前文件版本 主要修订内容和原因 修订人 修订日期 R1 新建 胡凯烽 2022.03.3 目的 针对研发平台和产品线的 MSF 实践团队，提供 MSF 各个历程实施指导，明确关键活动及其要求，为团队顺利开展MSF项目实践提供帮助和指导。目前主要涉及两大关键历程，展望历程和计划历程。 阅读者及阅读建议 MSF 团队的各个角色，特别是产品管理、程序管理、架构设计和 UE 四个代言群，重点关注在这两个历程中和所在代言群功能领域直接相关的活动和检查点。 范围 本文档主要涉及到展望历程和计划历程的关键活动、关键输出及评审要求。 历程指导 展望历程 展望历程需要完成的主要活动是组成核心团队和撰写远景/范围文件。勾勒项目远景和辨识项目范围是两种截然不同的活动，但两者都是项目不可或缺的成功关键因素。远景是以无拘无束的方式来思考解决方案未来可能的样子。范围则是在项目的约束条件之下找出远景所要实现的部分。 关键输出物 远景/范围文件，主导代言群：产品管理 项目架构文件，主导代言群：程序管理 初始风险评估，主导代言群：程序管理 关键活动 初始化项目仓库 由程序管理向软件部申请项目仓库， 并按照《软件项目目录及文件管理规范》组织初始目录及文件。 形式要求： 由软件部创建仓库， 团队不得自行创建；软件部须为各团队维护一个仓库列表。 必须按照《软件项目目录及文件管理规范》组织初始目录及文件。 确认利益关系人 由产品管理识别并确认利益关系人。 形式要求： $/pm/stakeholder.md 文件中清晰描述利益关系人。 内容要求： 有种子客户； 行业头部客户作为种子客户尤佳。 有种子客户的沟通计划尤佳。 组建核心团队 由程序管理招募组建核心团队。 形式要求： $/pm/roles.md 文件中描述了团队成员， 及给出初始评估。 内容要求： 至少 3 位全职人员。 保证每个角色均有全职人员参与（除发布运维外）。 远景范围分析 由产品管理起草远景/范围文档并呈现在项目的 README.md 文件中，并同步起草 SRS 一二章节内容。 由 UE 主导定义用户故事的验收标准。 由架构定义设计策略， 并呈现在项目的 README.md 文件中。 SRS 目录是以最终能形成一本书为目标。 形式要求： 按照《软件项目目录及文件管理规范》编写 README.md 文件。 根据《软件项目目录及文件管理规范》及 GBT8325 组织 SRS 文档。 初始风险分析 由程序管理召集团队讨论初始风险， 并汇总。 形式要求： $/pm/risk.md 文件中描述了初始风险。 内容要求: 着重识别出了 3 个最高优先级的风险。 展望历程评审 由程序管理召集展望历程评审， 参加人员包括但不限于研发总监、产品总监、首席架构师、软件部经理、本部门经理。 要求： 评审面向项目代码仓库进行； 软件部对会议评审出的团队评分（形式分及内容分）做记录。 计划历程 计划历程专注于构建的内容、构建的方式、构建每个部件的时间、 交付解决方案需要的支持环境。具体来说就是：团队将展望历程的工作成果转化为能完整描述解决方案的需求；通过功能的规格说明将需求文档化；建立起详细的设计和架构；准备工作计划；估计成本；为计划历程的每个交付成果制订出时间表。同样团队还要定义和构建出交付解决方案必要的支持环境。 关键输出物 功能需求的规格设计 设计方案 主项目计划与时间表 关键活动 规格设计 由架构、UE 对功能需求进行分解与细化。SRS 目录是以最终能形成一本书为目标。 形式要求： 根据《软件项目目录及文件管理规范》及 GBT8325 组织 SRS 文档。 内容要求： 体现功能需求的价值 对功能需求 markdown 文件不做形式上的要求，但要求： 功能需求层次拆分合理 功能需求的说明清晰 一个仓库下功能需求格式一致 方案设计 由架构识别出实现的技术难点，并形成设计方案。 形式要求： 组内评审通过，得到团队成员的认可。 计划构建 由程序管理汇集各角色提交的计划，形成主项目计划。 形式要求： 必须有沟通计划； 必须体现主项目时间表；（管理工具不限） 方案汇报/评审 由程序管理将组内评审过的设计方案，汇报到软件部；专家委员会评审设计方案。 形式要求： 评审过的设计方案， 必须汇报到软件部。 计划历程评审 由团队的程序管理召集计划历程评审， 参加人员包括但不限于研发总监、产品总监、软件部经理、本部门经理。 要求： 评审面向项目代码仓库进行； 软件部对会议评审出的团队评分（形式分及内容分）做记录。 附录- MSF 评审表 MSF 评审_CheckList-R1.xls"
  },
  "doc/研发管理制度规范/产品研发管理制度/产品研发术语.html": {
    "href": "doc/研发管理制度规范/产品研发管理制度/产品研发术语.html",
    "title": "产品研发术语",
    "keywords": "产品研发术语 产品 产品 ：人们通过购买而获得的能够满足某种需求和欲望的物品属性的总和。产品可分为以下四个层次： 核心产品。这是产品最基本的层次，是顾客购买产品的真正动机。如：运动控制，激光平面切割，排样等。 形式产品。指承载核心产品的各种具体形式，也就是通常所说的可独立交付的产品。如：义齿机。 附加产品。指客户购买产品时额外得到的服务或利益。如提供免费送货，售后服务等。 心理产品。指顾客购买产品时的心理感受和体验，如产品的品牌、企业的品牌。 客户、用户、合作伙伴 客户 ：掏钱购买产品的组织或个人。 用户 ：最终使用产品的组织或个人。 合作伙伴 ：公司与终端客户存在的组织或个人。如代理商。 用户和客户可能是同一个主体，也可能不是。 需求 需求是个泛词，很早之前就在经济学领域中广泛使用，通常和“供给”一同出现。 经济学定义：一种商品的需求是指，消费者在一定的时期、在一既定的价格水平下、愿意而且能够购买的商品的数量。 关于此需求的定义，核心点感觉应该是愿意和能够。 愿意——代表着你的主观购买欲望 能够——代表着你的客观支付能力 需求是购买欲望和支付能力的统一，二者缺一不可。 生搬硬套经济学的定义并没有意义，语言是随着时代也不断发展着。我们日常中对于“需求”这个词汇的应用，早已不再仅仅局限于“针对一件商品的购买数量”。而是有了很大程度的延伸。我们先看一下“福特造车”的故事。 100 多年前，福特公司的创始人亨利·福特先生到处跑去问客户：“您需要一个什么样的更好的交通工具？”几乎所有人的答案都是：“我要一匹更快的马”。大部分人听到这个答案，于是立马跑到马场去选马配种，以满足客户的需求。但是福特先生却没有立马往马场跑，而是接着往下问。 福特：“你为什么需要一匹更快的马？” 客户：“因为可以跑得更快！” 福特：“你为什么需要跑得更快？” 客户：“因为这样我就可以更早的到达目的地。” 福特：“所以，你要一匹更快的马的真正用意是？” 客户：“用更短的时间、更快地到达目的地！” 然后福特就发明了汽车，很好的满足了的客户的需求。 从这个例子我们可以看出，需求往往是通过多问一个为什么挖掘出来的。 但其实福特先生应该继续追问下去：你更早的到达目的地是为了什么呢？这个目的能否在你没到达目的地的情况下被解决呢？如果不能，最大的阻力是什么？这些阻力能否被解决呢？ 这个问题延伸下去，可能会产生出更多问题，但也就是因为存在这些问题，创新的机会才会无处不在。 根据以上，我们尝试定义需求： 需求，就是等待着被解决的问题（现实与期望的落差）。 接下来尝试对需求种类及优先级进行分类。 需求种类 需求根据种类可以划分为：市场需求、业务需求、用户需求、产品需求。而我们常说的客户需求就包含了业务需求与用户需求。 市场需求 ：往往是针对具体细分市场而言，综合考虑业务需求、用户需求、竞争环境（竞争对手、替代品、供应商、客户等）及相关环境（政策、法规、技术要求等）需求， 通过市场分析形成的对市场机会的描述， 属于共性需求。 业务需求 ：反映的是客户企业或组织的利益诉求。（描述为什么要开发此软件产品？） 用户需求 ：描述用户使用产品必须要完成什么任务。从用户使用场景，用户角度所提诉求。指用户能通过操作某某动作，达到某某目的。通常可以采用用户故事来描述。（描述软件产品能够帮用户做什么？） 产品需求 ：是一系列功能需求及非功能性需求（如安全、性能、易用等）的总和。 需求优先级 根据 KANO 模型来分析。 必备因素（ 痛点需求 ）：必须具备的功能，用以保证流程能正常进行。功能缺失时，使用者会发现流程不能走通。故这类需求需要优先考虑。 期望因素（ 痒点需求 ）：这类需求通常能节省使用者的时间，提升效率。存在的目的是为了让系统操作起来更流畅。优先级一般没有必备因素高。 魅力因素（ 爽点需求 ）：通常是一些使用者没有想到的功能，能大幅提升使用者效率、优化体验和解决使用者线下难以解决的问题的需求。"
  },
  "doc/研发管理制度规范/产品研发管理制度/产品研发管理制度.html": {
    "href": "doc/研发管理制度规范/产品研发管理制度/产品研发管理制度.html",
    "title": "产品研发管理制度",
    "keywords": "产品研发管理制度 版次：第1版 类型：程序文件 部门：软件部 文件版本 修改前文件版本 主要修订内容和原因 修订人 修订日期 R1 新建 胡凯烽 2022.01.21 Important 本制度还在更新中， 尚未处于发布中。 1 目的 软件产品开发的目标：高效、高质量地开发出让用户满意的产品。有效的研发管理是保证产品质量、提高客户满意度、确保经营效益、提升竞争实力的最基本保障，也是软件开发企业赖以生存和发展的前提。为此，针对我司软件产品开发项目的特点，制定本制度。 2 适用范围 适用于采用 MSF 开发流程的软件平台以及产品线各团队。 3 术语及定义 MSF：即 Microsoft Solution Framework 。 《MSF 精髓》：即《微软软件研发的奥秘- MSF 精髓》。 产品型号：是内部产品研发管理的单元， 保证拥有独立的代码仓库。 4 开发流程 在 MSF 指导下， 强调关键节点与监控。项目实施过程分为五大历程：展望历程，计划历程，构建历程，稳定历程，部署历程。整个开发过程是个迭代过程，并且各历程可互相重叠（详见《 MSF 精髓》第6.3章）。下图描述了各历程的关键活动（包括了验证活动），关键交付成果。 4.1 活动详解 4.1.1 远景/范围分析 远景/范围分析是展望历程中重要活动。远景是以无拘无束的方式来思考解决方案未来可能的样子，范围则是在项目的约束条件之下找出远景所要实现的部分。 输入： 市场需求。 输出： 远景/范围文件 负责人角色： 产品管理。 准出原则： 通过展望历程评审。 说明： 解决方案的远景与范围文件通过审批，需要团队与利益关系人都认可对于问题和机会的描述，并且对概念性解决方案和交付方法达成共识。 4.1.2 就绪管理分析 准备就绪包括两个部分：技术准备就绪和心理准备就绪（比如个人意愿和心理准备）。MSF主要针对的是技术准备就绪。它在解决方案交付中，为评定和获取知识、技能、必要能力提供了指导和流程。它基于MSF基本原则，在整个解决方案生命周期内，指导如何积极地做好准备。 输入： 市场需求。 输出： 项目结构文件。 负责人角色： 程序管理。 准出原则： 通过展望历程评审。 说明： 在这一步骤包括以下几个活动： 评估个人知识、技能和能力； 重新检查准备就绪需求； 确认和分析准备就绪差距； 制订学习计划。 4.1.3 初始风险分析 评估风险开始于项目的初期。每一个可能直接或间接产生风险的决策都要记录在案。实现解决方案的备用方法有什么风险也要予以考虑。项目的权衡取舍也要考虑风险的因素。每一件事都有可能改变风险的等级，并且影响我们所有的决策和计划。 输入： 市场需求。 输出： 风险评估文件。 负责人角色： 程序管理。 准出原则： 通过展望历程评审。 说明： 在展望历程所有风险的确定都要文档化，将其记录在初始的风险评估文档中。这个文档构成了后续风险管理的基础。这个时候也是团队决定如何实现 MSF 风险管理流程的时候。 4.1.4 规格设计 需求规格说明书是详细描述解决方案的样子和行为的文档。它可能是指一份具体的文档，也可能是一系列文档，对功能做详细的说明。 输入： 市场需求。 输出： 需求规格说明书。 负责人角色： 架构。 准出原则： 通过计划历程评审。 4.1.5 方案设计 当解决方案的细节需求获得核准，团队便开始以递增的、系统化的方式来设计解决方案以及其他协助解决方案交付所需的机制（例如测试控制机制）。以展望历程所定义的概念性解决方案以及功能规格中描述的需求和设计目标为起点，MSF 提出了三段式的设计流程：概念设计、逻辑设计以及实体设计。 输入： 需求规格说明书。 输出： 方案设计说明书。 负责人角色： 架构。 准出原则： 通过方案汇报/评审。 说明： 设计流程应该是结构化的，这样，每个设计步骤就能够验证上一个步骤，并且奠定下—个步骤的基础。当团队在进行某个设计流程时，可能需要重新检查先前的设计，由此可能发现之前设计的一些错误、矛盾或遗漏之处。 4.1.6 计划构建 计划如何构建解决方案包含了两条工作流，而其工作内容的依据就是功能规格里面对解决方案的描述。其中一条工作流主要是解决方案设计的演进过程，也就是将展望历程期间所定义的概念解决方案逐渐发展成详细设计，以便在构建历程能够进行实际的构建。另一条工作流则是负责把各项计划整合成主项目计划。 输入： 方案设计说明书。 输出： 主项目计划书。 负责人角色： 程序管理。 准出原则： 通过计划历程评审。 说明： 解决方案的需求文件说明了需要构建哪些东西。解决方案的设计和项目计划则说明了如何构建解决方案。 4.1.7 开发编码 输入： 需求规格说明书。 输出： 软件代码。 负责人角色： 开发。 准入原则： 需求规格说明书已通过评审。 准出原则： 通过单步调试 通过代码评审 通过功能自测 4.1.8 单元测试编码 单元测试是开发人员保证代码正确的有效方式。 输入： 软件代码。 输出： 单元测试代码。 负责人角色： 开发。 准出原则： 单元测试用例全部通过。 4.1.9 测试用例编码 测试用例采用代码化方式管理。 输入： 需求规格说明书。 输出： 测试用例。 负责人角色： 测试。 准出原则： 通过测试用例评审。 4.1.10 用户手册编写 用户手册是指导用户使用和维护产品的指导性文档。 输入： 需求规格说明书。 输出： 用书手册。 负责人角色： UE 。 说明： 尽最大可能提高解决方案的易用性；提高用户就绪水平和成效。 4.1.11 测试执行 按照主项目计划中的系统测试计划执行。 输入： 系统测试计划、测试用例。 输出： 测试报告。 负责人角色： 测试。 准出原则： 按照系统测试计划已执行完毕。 所有通用必测测试用例通过。 所有致命及严重 Bug 已回归通过。 遗留Bug已通过团队评估。 4.1.12 用户验收测试 用户验收测试就是要确保用户认同解决方案已经完全符合先前定义的用户验收标准，并且符合用户和企业的需求。这些测试纯粹是以用户的角度来衡量及验证解决方案的功能和易用性。 输入： 测试报告，待发布软件包。 负责人角色： UE 。 4.1.13 发布 利益关系人和项目团队都同意解决方案的发布已经准备就绪；运维与支持团队也已准备好接手解决方案后续的工作；部署解决方案所需的资源也已经就绪，包括人员、设备、配套设施、工具和部署脚本；部署计划和方法都已经经过审查。将解决方案部署到目标环境的工作可以开始了。 输入： 测试报告。 输出： 发布通知。 负责人角色： 发布/运维。 准出原则： 通过发布审核。 5 管理规范 5.1 就绪管理 目标 建立代码仓库， 约定代码仓库的目录及文件管理规范； 梳理团队成员及确定利益关系人； 内容与职责 明确代码仓库的管理方式及文件管理规范；确保建立核心团队及确定利益关系人。 工作规范 梳理团队成员 程序管理需确定团队的核心成员及人员清单，并给出评估。 确定利益关系人 程序管理及产品管理需确定项目的利益关系人，确保后续的沟通顺畅。 确定代码仓库管理 仓库是研发人员的工作界面， 一致的仓库管理会降低研发人员的熟悉难度。软件部需提供相应的规范文件。 5.2 需求管理 目标 界定明确的项目范围，建立项目实施工作的基础； 完整、准确地描述软件系统的需求规格，作为架构、开发、测试过程中跟踪需求的基础； 根据明确的需求变更管理流程，控制项目的需求变更，保证软件系统的质量，降低项目实施的风险。 内容与职责 清晰界定项目实施软件系统的功能需求规格，是软件系统开发项目项目管理最基本和最关键的工作之一。 工作规范 1.需求规格说明书 产品管理、架构、程序管理需协力通过需求调研和需求分析的工作过程，形成的完整准确地描述软件系统功能需求的项目正式交付文档。 2.需求评审 需求评审是所有软件开发项目实施过程中必须执行的关键工作，是设计、开发及测试实施工作启动的前提条件。 3.需求变更管理 需求变更管理适用于针对软件系统的功能需求规格的变更。有效的需求变更管理是项目工作范围管理、需求管理、进度管理、质量控制、成本管理的有力保障，也是软件系统开发项目中主要挑战之一。 5.3 沟通管理 目标 保证项目相关的事宜（包括项目进度、存在的问题、需要协调的工作等等）能够在公司内部和公司外部得到及时、准确的传递和理解； 使公司、客户、合作伙伴自始至终对项目持有一个正确、合理的期望值，保证合作各方对项目的满意度。 内容与职责 项目实施过程中，不同的项目参与者及相关方都会不同程度地参与到项目的沟通工作之中。在这些沟通中，程序管理首先处于一个中心位置，在众多信息的传递中拥有最核心、最权威的地位；再者，程序管理需要对这些信息的沟通进行管理，以确保这些信息的传递是有秩序的、及时的、准确的、合适的，最终目的是保证这些项目参与者和关注者对项目的实际情况能够产生正确的理解。 工作规范 1. 项目启动沟通 项目实施工作在公司内部的正式启动，以项目立项审核通过为标记。正式启动需具备以下条件： 项目范围已描述清晰。 项目计划已准备完毕。 工作量估算已完成。 团队核心角色已到位，具备足够资源开展工作。 2. 每日站立会议 每日站立会议具体的指导原则： 会议准时开始。 欢迎其他人员参加，但只有团队成员可以发言。 出席者站立开会，注意控制会议时间。 建议控制在15分钟。建议在早上开，内容：1. 昨天完成哪些工作；2.今天打算做什么；3.完成目标存在什么障碍。 会议应在固定地点和每天的同一时间举行。 3. 项目工作周报 项目正式启动后，必须每周分别向外部相关方、内部团队成员及主管领导发送本周工作内容。 4. 故障信息沟通 团队收到外部反馈的故障信息后， 不论故障等级，应立刻响应故障提交者， 告知已经进入故障处理流程， 并通知程序管理及测试， 并在解决故障1小时内向以上相关人员发出故障报告。 5.4 进度管理 目标 根据工作任务分解结构，制定项目实施计划。 跟踪各项工作任务的实际完成情况，真实地汇报项目的实际进度。 及时发现项目进度的延误，以制定必要的补救计划，争取项目进度尽快重回正轨。 内容与职责 项目进度管理指的是对《主项目计划书》的计划和控制，由程序管理负责。 工作规范 1. 计划制定 《主项目计划书》由程序管理在计划历程中负责编写。 2. 进度控制 程序管理应每周更新《项目实施计划》中的每项工作任务的实际完成百分比， 并向公司主管领导提交。 5.5 质量管理 目标 通过对项目实施过程中关键输出物品的质量检查，确保软件系统和项目实施的质量。本节主要针对系统设计和系统测试的关键输出物品（分别为《方案设计说明书》和《集成测试计划》）的质量控制工作提出规范要求。 内容与职责 架构、开发负责《方案设计说明书》（可能有多个功能的方案）；开发根据设计文档编写代码，并编写单元/功能测试，并完成自测。测试负责《集成测试计划》；并按照计划进行测试。 工作规范 1.方案评审 对于技术复杂度高的功能， 需进行方案设计并评审。 方案评审作为系统设计工作的关键质量控制点，并由专家委员会负责评审。 2.测试用例评审 测试用例评审指针对测试用例的评审工作。 测试用例评审作为系统测试工作的关键质量控制点，应该以独立工作任务的形式，在《项目实施计划》中明确地体现，并由程序管理负责协调执行。 3.代码评审 针对代码开发的评审工作，在《软件编码规范》里对代码的编写已提出具体、明确的规范指引。 代码评审作为系统开发工作的关键质量控制点，应该以独立工作任务的形式，在《项目实施计划》中明确地体现，并由程序管理负责协调执行。 6 检查 本着由公司统一编写与修订，各部门负责落实执行和监督的原则。 公司层面：由软件部负责对各部门项目的实施与管理过程以及对应输出依据本制度的要求进行检查或抽查，对不符合项目进行记录并公布。 部门层面：由总工负责对部门内项目的实施与管理过程以及对应输出依据本制度的要求进行检查或抽查，对不符合项目进行记录并公布。 MSF团队层面：由程序管理负责对团队内项目的实施与管理过程以及对应输出依据本制度的要求进行检查或抽查，对不符合项目进行记录并公布。 6.1 检查内容 主要针对第四章描述的关键交付成果。 7 项目齐套清单 序号 名称 负责角色 公司评审 是否必需 支持信息 备注 1 《需求规格说明书》 产品管理、UE、架构、程序管理 是 是 《需求规格说明书模板-R1》 一个产品型号一个文档， 一个发布版本需带有一个文档版本。 2 《项目架构文件》 程序管理 是 是 3 《风险评估文件》 程序管理 是 是 4 《主项目计划书》 程序管理 是 是 5 《项目实施计划》 程序管理 5 《方案设计说明书》 架构 是 6 《用户手册》 UE 是 7 发布公告 程序管理 是"
  },
  "doc/研发管理制度规范/产品研发管理制度/产品研发管理制度指导书.html": {
    "href": "doc/研发管理制度规范/产品研发管理制度/产品研发管理制度指导书.html",
    "title": "产品研发管理制度指导书",
    "keywords": "产品研发管理制度指导书 版次：第1版 类型：程序文件 部门：软件部 文件版本 修改前文件版本 主要修订内容和原因 修订人 修订日期 R1 新建 胡凯烽 2022.01.21 1 目的 软件产品开发的目标：高效、高质量地开发出让用户满意的产品。有效的研发管理是保证产品质量、提高客户满意度、确保经营效益、提升竞争实力的最基本保障，也是软件开发企业赖以生存和发展的前提。为此，针对我司软件产品开发项目的特点，制定本制度。 2 适用范围 适用于采用 MSF 开发流程的软件平台以及产品线各团队。 3 术语及定义 MSF：即 Microsoft Solution Framework 。 《MSF 精髓》：即《微软软件研发的奥秘-MSF 精髓》。 产品型号：是内部产品研发管理的单元， 保证拥有独立的代码仓库。 4 开发流程 在 MSF 指导下， 强调关键节点与监控。项目实施过程分为五大历程：展望历程，计划历程，构建历程，稳定历程，部署历程。整个开发过程是个迭代过程，并且各历程可互相重叠（详见《MSF 精髓》第 6.3 章）。下图描述了各历程的关键活动（包括了验证活动），关键交付成果。 4.1 活动详解 4.1.1 远景/范围分析 远景/范围分析是展望历程中重要活动。远景是以无拘无束的方式来思考解决方案未来可能的样子，范围则是在项目的约束条件之下找出远景所要实现的部分。 输入： 市场需求。 输出： 远景/范围文件 负责人角色： 产品管理。 准出原则： 通过展望历程评审。 说明： 解决方案的远景与范围文件通过审批，需要团队与利益关系人都认可对于问题和机会的描述，并且对概念性解决方案和交付方法达成共识。 4.1.2 就绪管理分析 准备就绪包括两个部分：技术准备就绪和心理准备就绪（比如个人意愿和心理准备）。MSF 主要针对的是技术准备就绪。它在解决方案交付中，为评定和获取知识、技能、必要能力提供了指导和流程。它基于 MSF 基本原则，在整个解决方案生命周期内，指导如何积极地做好准备。 输入： 市场需求。 输出： 项目结构文件。 负责人角色： 程序管理。 准出原则： 通过展望历程评审。 说明： 在这一步骤包括以下几个活动： 评估个人知识、技能和能力； 重新检查准备就绪需求； 确认和分析准备就绪差距； 制订学习计划。 4.1.3 初始风险分析 评估风险开始于项目的初期。每一个可能直接或间接产生风险的决策都要记录在案。实现解决方案的备用方法有什么风险也要予以考虑。项目的权衡取舍也要考虑风险的因素。每一件事都有可能改变风险的等级，并且影响我们所有的决策和计划。 输入： 市场需求。 输出： 风险评估文件。 负责人角色： 程序管理。 准出原则： 通过展望历程评审。 说明： 在展望历程所有风险的确定都要文档化，将其记录在初始的风险评估文档中。这个文档构成了后续风险管理的基础。这个时候也是团队决定如何实现 MSF 风险管理流程的时候。 4.1.4 规格设计 需求规格说明书是详细描述解决方案的样子和行为的文档。它可能是指一份具体的文档，也可能是一系列文档，对功能做详细的说明。 输入： 市场需求。 输出： 需求规格说明书。 负责人角色： 架构。 准出原则： 通过计划历程评审。 4.1.5 方案设计 当解决方案的细节需求获得核准，团队便开始以递增的、系统化的方式来设计解决方案以及其他协助解决方案交付所需的机制（例如测试控制机制）。以展望历程所定义的概念性解决方案以及功能规格中描述的需求和设计目标为起点，MSF 提出了三段式的设计流程：概念设计、逻辑设计以及实体设计。 输入： 需求规格说明书。 输出： 方案设计说明书。 负责人角色： 架构。 准出原则： 通过方案汇报/评审。 说明： 设计流程应该是结构化的，这样，每个设计步骤就能够验证上一个步骤，并且奠定下—个步骤的基础。当团队在进行某个设计流程时，可能需要重新检查先前的设计，由此可能发现之前设计的一些错误、矛盾或遗漏之处。 4.1.6 计划构建 计划如何构建解决方案包含了两条工作流，而其工作内容的依据就是功能规格里面对解决方案的描述。其中一条工作流主要是解决方案设计的演进过程，也就是将展望历程期间所定义的概念解决方案逐渐发展成详细设计，以便在构建历程能够进行实际的构建。另一条工作流则是负责把各项计划整合成主项目计划。 输入： 方案设计说明书。 输出： 主项目计划书。 负责人角色： 程序管理。 准出原则： 通过计划历程评审。 说明： 解决方案的需求文件说明了需要构建哪些东西。解决方案的设计和项目计划则说明了如何构建解决方案。 4.1.7 开发编码 输入： 需求规格说明书。 输出： 软件代码。 负责人角色： 开发。 准入原则： 需求规格说明书已通过评审。 准出原则： 通过单步调试 通过代码评审 通过功能自测 4.1.8 单元测试编码 单元测试是开发人员保证代码正确的有效方式。 输入： 开发编码文件。 输出： 单元测试编码文件。 负责人角色： 开发。 说明： 单元测试用例需全部通过 4.1.9 测试用例编码 测试用例采用代码化方式管理。 输入： 需求规格说明书。 输出： 测试用例。 负责人角色： 测试。 准出原则： 通过测试用例评审。 4.1.10 用户手册编写 用户手册是指导用户使用和维护产品的指导性文档。 输入： 需求规格说明书。 输出： 用书手册。 **负责人角色： ** UE 。 说明： 尽最大可能提高解决方案的易用性；提高用户就绪水平和成效。 4.1.11 测试执行 按照主项目计划中的系统测试计划执行。 输入： 系统测试计划、测试用例 输出： 测试报告。 负责人角色： 测试。 准出原则： 按照系统测试计划已执行完毕。 所有通用必测测试用例通过。 所有致命及严重 Bug 已回归通过。 遗留Bug已通过团队评估。 4.1.12 用户验收测试 用户验收测试就是要确保用户认同解决方案已经完全符合先前定义的用户验收标准，并且符合用户和企业的需求。这些测试纯粹是以用户的角度来衡量及验证解决方案的功能和易用性。 输入： 测试报告，待发布软件包。 负责人角色： UE 。 4.1.13 发布 利益关系人和项目团队都同意解决方案的发布已经准备就绪；运维与支持团队也已准备好接手解决方案后续的工作；部署解决方案所需的资源也已经就绪，包括人员、设备、配套设施、工具和部署脚本；部署计划和方法都已经经过审查。将解决方案部署到目标环境的工作可以开始了。 输入： 测试报告。 输出： 发布通知。 负责人角色： 发布/运维。 准出原则： 通过发布审核。 5 管理规范 5.1 就绪管理 目标 建立代码仓库，约定代码仓库的目录及文件管理规范； 梳理团队成员及确定利益关系人； #### 内容与职责 明确代码仓库的管理方式及文件管理规范；确保建立核心团队及确定利益关系人。 工作规范 梳理团队成员 程序管理需确定团队的核心成员及人员清单，并给出评估。 确定利益关系人 程序管理及产品管理需确定项目的利益关系人，确保后续的沟通顺畅。 确定代码仓库管理 仓库是研发人员的工作界面，一致的仓库管理会降低研发人员的熟悉难度。软件部需提供相应的规范文件。 5.2 需求管理 目标 界定明确的项目范围，建立项目实施工作的基础； 完整、准确地描述软件系统的需求规格，作为架构、开发、测试过程中跟踪需求的基础； 根据明确的需求变更管理流程，控制项目的需求变更，保证软件系统的质量，降低项目实施的风险。 内容与职责 清晰界定项目实施软件系统的功能需求规格，是软件系统开发项目项目管理最基本和最关键的工作之一。 工作规范 1.需求规格说明书 产品管理、架构、程序管理需协力通过需求调研和需求分析的工作过程，形成的完整准确地描述软件系统功能需求的项目正式交付文档。 2.需求评审 需求评审是所有软件开发项目实施过程中必须执行的关键工作，是设计、开发及测试实施工作启动的前提条件。 3.需求变更管理 需求变更管理适用于针对软件系统的功能需求规格的变更。有效的需求变更管理是项目工作范围管理、需求管理、进度管理、质量控制、成本管理的有力保障，也是软件系统开发项目中主要挑战之一。 5.3 沟通管理 目标 保证项目相关的事宜（包括项目进度、存在的问题、需要协调的工作等等）能够在公司内部和公司外部得到及时、准确的传递和理解； 使公司、客户、合作伙伴自始至终对项目持有一个正确、合理的期望值，保证合作各方对项目的满意度。 内容与职责 项目实施过程中，不同的项目参与者及相关方都会不同程度地参与到项目的沟通工作之中。在这些沟通中，程序管理首先处于一个中心位置，在众多信息的传递中拥有最核心、最权威的地位；再者，程序管理需要对这些信息的沟通进行管理，以确保这些信息的传递是有秩序的、及时的、准确的、合适的，最终目的是保证这些项目参与者和关注者对项目的实际情况能够产生正确的理解。 工作规范 1. 项目启动沟通 项目实施工作在公司内部的正式启动，以项目立项审核通过为标记。正式启动需具备以下条件： 项目范围已描述清晰。 项目计划已准备完毕。 工作量估算已完成。 团队核心角色已到位， 具备足够资源开展工作。 2. 每日站立会议 每日站立会议具体的指导原则： 会议准时开始。 欢迎其他人员参加，但只有团队成员可以发言。 出席者站立开会，注意控制会议时间。建议控制在 15 分钟。建议在早上开，内容：1. 昨天完成哪些工作；2.今天打算做什么；3.完成目标存在什么障碍。 会议应在固定地点和每天的同一时间举行。 3. 项目工作周报 项目正式启动后，必须每周分别向外部相关方、内部团队成员及主管领导发送本周工作内容。 4. 故障信息沟通 团队收到外部反馈的故障信息后，不论故障等级，应立刻响应故障提交者，告知已经进入故障处理流程， 并通知程序管理及测试，并在解决故障 1 小时内向以上相关人员发出故障报告。 5.4 进度管理 目标 根据工作任务分解结构，制定项目实施计划。 跟踪各项工作任务的实际完成情况，真实地汇报项目的实际进度。 及时发现项目进度的延误，以制定必要的补救计划，争取项目进度尽快重回正轨。 内容与职责 项目进度管理指的是对《主项目计划书》的计划和控制，由程序管理负责。 工作规范 1. 计划制定 《主项目计划书》由程序管理在计划历程中负责编写。 2. 进度控制 程序管理应每周更新《项目实施计划》中的每项工作任务的实际完成百分比，并向公司主管领导提交。 5.5 质量管理 目标 通过对项目实施过程中关键输出物品的质量检查，确保软件系统和项目实施的质量。本节主要针对系统设计和系统测试的关键输出物品（分别为《方案设计说明书》和《集成测试计划》）的质量控制工作提出规范要求。 内容与职责 架构、开发负责《方案设计说明书》（可能有多个功能的方案）；开发根据设计文档编写代码，并编写单元/功能测试，并完成自测。测试负责《集成测试计划》；并按照计划进行测试。 工作规范 1.方案评审 对于技术复杂度高的功能，需进行方案设计并评审。 方案评审作为系统设计工作的关键质量控制点，并由专家委员会负责评审。 2.测试用例评审 测试用例评审指针对测试用例的评审工作。 测试用例评审作为系统测试工作的关键质量控制点，应该以独立工作任务的形式，在《项目实施计划》中明确地体现，并由程序管理负责协调执行。 3.代码评审 针对代码开发的评审工作，在《软件编码规范》里对代码的编写已提出具体、明确的规范指引。 代码评审作为系统开发工作的关键质量控制点，应该以独立工作任务的形式，在《项目实施计划》中明确地体现，并由程序管理负责协调执行。 6 检查 本着由公司统一编写与修订，各部门负责落实执行和监督的原则。 公司层面：由软件部负责对各部门项目的实施与管理过程以及对应输出依据本制度的要求进行检查或抽查，对不符合项目进行记录并公布。 部门层面：由总工负责对部门内项目的实施与管理过程以及对应输出依据本制度的要求进行检查或抽查，对不符合项目进行记录并公布。 MSF 团队层面：由程序管理负责对团队内项目的实施与管理过程以及对应输出依据本制度的要求进行检查或抽查，对不符合项目进行记录并公布。 6.1 检查内容 主要针对第四章描述的关键交付成果。 7 项目齐套清单 序号 名称 负责角色 公司评审 是否必需 支持信息 备注 1 《需求规格说明书》 产品管理、UE、架构、程序管理 是 是 《需求规格说明书模板-R1》 一个产品型号一个文档， 一个发布版本需带有一个文档版本。 2 《项目架构文件》 程序管理 是 是 3 《风险评估文件》 程序管理 是 是 4 《主项目计划书》 程序管理 是 是 5 《项目实施计划》 程序管理 5 《方案设计说明书》 架构 是 6 《用户手册》 UE 是 7 发布公告 程序管理 是"
  },
  "doc/研发管理制度规范/关于平台软件兼容性问题例外活动流程-R1.html": {
    "href": "doc/研发管理制度规范/关于平台软件兼容性问题例外活动流程-R1.html",
    "title": "关于平台软件兼容性问题例外活动流程",
    "keywords": "关于平台软件兼容性问题例外活动流程 版次：2021年11月18日 第1版 文件类型：程序文件 部门：软件部 上层文件：软件开发工作规范 上海维宏电子科技股份有限公司 版权所有 修改历史 文件版本 修改前文件版本 主要修订内容和原因 修订人 修订日期 R1 新建 胡凯烽 2021/11/18 目的 根据《 软件开发工作规范（草案） ﻿》要求，平台不得破坏发布软件的兼容性。 但平台由于处于优化目的，可能会进行不兼容的设计。为了更好的管理此类例外活动，约定本流程。 适用范围 产品线及软件平台团队。 活动流程 流程图 图 1 平台软件兼容性问题例外活动流程图 流程详解 表 1 功能规格设计活动流程详解 活动名称 活动描述 负责人 备注 情况说明 描述进行不兼容设计及发布的原因， 以及不兼容的影响范围。 平台总工 相关方确认 相关方通过邮件确认达成一致。 1. 不兼容的设计方式； 2. 不兼容的处理方式； 产品总工 审核 审核不兼容设计及处理方式。 研发总监 归档 将兼容性问题说明与相关方同意证据统一归档。 研发助理 归档到软件部 wiki 下。"
  },
  "doc/研发管理制度规范/函数体设计最佳实践.html": {
    "href": "doc/研发管理制度规范/函数体设计最佳实践.html",
    "title": "函数体设计最佳实践-草案",
    "keywords": "函数体设计最佳实践-草案 概述 本文档介绍了函数体设计过程中的最佳实践。 函数体的设计实践可以看做是整个软件设计实践的一部分，建议开发过程遵循这些设计实践。 本文档的愿景是能够指导大家写出高效、高质量的代码出来。 整理最佳实践的过程参考了很多经典的设计书籍，站在巨人的肩上将优秀的设计理念归纳总结出来。 为了让开发人员能够真正的理解这些实践，除了描述规则之外还通过注释或案例的方式向你表述了分析的过程，以便做到知其所以然。 因为是最佳实践，所以一些设计准则应该在实践过程中打磨在提炼，最终通过集体的智慧来完善它。 本文档描述的实践内容以C#作为目标语言，在具体的条目中涉及到了.NET API 的使用， 所以本文档主要面向 .NET 开发人员。 术语 Pascal 命名法： 将标识符的首字母和后面连接的每个单词的首字母都大写。例如： BackColor。 Camel 命名法： 标识符的首字母小写，而每个后面连接的单词的首字母都大写。例如：backColor。 监管程序： 一般的指相对于库程序的应用程序，从调用堆栈上也指一般API的调用方。 函数体命名准则 要 在命名方法时使用 Pascal 大小写风格。 要 在命名参数时使用 Camel 大小写风格。 要用动词或动词词组来命名方法。 public class String { public int CompareTo(...); public string[] Split(...); public string Trim(); } 因为方法是用来执行操作的，因此设计准则要求方法名必须是 动词或动词词组 。它还用来把方法同属性和类型名区分开，属性和类型名是名词或形容词词组。 要使用具有描述性的名字来描述函数或参数。 函数/参数名 应该具备足够的描述性，使得在大多数情况下，用户根据参数的名字和类型就能确定它的意思，不要担心长名称，长而清晰的名字要比短而令人费解的名字好得多。 一个好的名字甚至能够表达出函数的设计目标和设计思路，所以起名字是一个很专业很有挑战性的设计工作。 虽然从技术上看 长度不是问题，但是要节制， 把名字写成了句子就太糟糕了。 考虑根据参数的意思而不是参数的类型来命名参数。 这里主要是强调不应该在 .NET 中使用匈牙利命名法， 强调了参数的语义而不是类型，因为现在的开发工具已经可以很高效的提示类型了。 不要使用缩写或缩写词作为标识符名称的一部分。 例如，使用 GetWindow 而不是 GetWin 。 不要使用未被广泛接受的任何首字母缩写词，仅在必要时才使用. 例如，HTML 是 Hypertext Markup Language 的首字母缩写，它是被广泛接受的。 如果想创造一个缩写词，请保证在整体系统下定义它，并在各个地方保持一致。 构造函数设计准则 .NET 有两种类型的构造函数： 类型构造函数 和 实例构造函数 。 public class Customer{ static Customer() { ... } // 类型构造函数 public Customer() { ... } // 实例构造函数 } 类型构造函数是静态的， CLR 会在使用该类型之前运行它。实例构造函数在创建类型实例时运行； 类型构造函数不能带任何参数，实例构造函数可以。不带任何参数的实例构造函数通常称为默认构造函数。 考虑提供最简单的构造函数，最好是默认构造函数。 简单的构造函数有很少的参数，所有参数都是基本类型，简单构造函数能增强框架的易用性。 如果一个类型对另一个类型有依赖关系，也就是说，如果没有后一个类型的实例，前一个类型实例将无法正常工作，那么应该将后一个类型作为构造函数的参数传递给前一个类型。 因此可以把这类构造函数参数列表看作是一个 依赖关系表 ， 在构造函数上定义依赖可以更好的阻止依赖关系的蔓延。 与此同时再定义一个默认构造函数，并为那些必要的依赖关系提供默认值也是一种很好的做法。 扩展阅读： ASP.NET Core 依赖注入 要在构造函数中做最少的工作。 除了把构造函数中的参数保存下来之外，构造函数不应该执行太多的操作。其他的处理操作应该推迟到真正需要的时候。 两个原因： 不要在执行构造函数时耗费太多时间。 太多的逻辑代表着更大的复杂性，那么如果执行终止，要花精力保证释放代码的的可靠性，否则系统可能会处于不完整的状态。 要谨慎的在构造函数中抛出异常。 和 C++ 编译器相反，在 C# 构造函数中抛出异常，析构函数是会得到执行的。 因为在 CLR 中对象执行构造函数之前已经构建完成并被 GC 监管起来。 所以即便构造函数异常退出， GC 后的析构函数还是会被执行。 即便能调用析构函数，在构造函数中抛出异常也要非常谨慎，要非常小心的处理引用对象和非托管资源（在析构函数和 dispose 函数中不要做任何假设，严格做好资源状态检查） 不要从静态构造函数中抛出异常。 除非整个系统数据被破坏或引发安全问题，否则不要在静态构造函数中引发异常。因为他会在应用程序域的上下文中引发异常。 抛出异常意味着在当前应用程序域中禁用此类型，且抛出的 [TypeInitializationException] 异常，必须通过 InnerException 才能够拿到错误信息。 所以要避免在静态构造函数中出现任何异常（自定义的和系统的），这个时候在代码块中插入 try-catch 块是必要的。 如果需要无参数构造函数，请务必在类中显式声明此类构造函数。 如果未显式声明任何构造函数， CLR 将自动生成一个默认构造函数。 但是！！！： 一旦给类型添加了带参的构造函数， 默认构造将不再自动生成 。 这就可能造成了兼容性危害， 在反射的应用场景下容易出现兼容性 BUG 。 避免在构造函数内部调用虚成员。 public abstract class Base{ public Base(){ Method(); } public abstract void Method(); } public class SubClass : Base{ private string value; public Derived(){ value = \"sub class\"; } public override void Method(){ Console.WriteLine(value); } } } 这个案例中，构建 SubClass 实例时会抛出空引用异常，因为基类构造函数执行 Method 虚函数的时候 派生类的构造尚未完成( value 尚未设置)。 但是这个结果在 SubClass 的角度是不可理解的。 参数设计准则 要用类层次结构中最接近基类的类型来作为参数的类型，同时保证该类型能够提供成员所需要的功能 例如： 设计一个方法遍历集合并打印到控制台。 这样的方法应该以 IEnumerable 为参数，而不应该以其他类型（比如：ArrayList 、IList）为参数。 public void WriteItemsToConsole(IEnumerable collection){ foreach (var item in collection){ Console.WriteLine(itme.ToString()); } } 由于方法内部并不需要使用 IList 的任何一个特定成员，因此用 IEunmerable 作为参数的类型使得用户能够传递只实现了 IEnumerable 但未实现 IList 的集合。 注意：这里并不是绝对的，具体设计上还要根据实际的需求来决定使用哪个类型，如果方法需要一些与线程或安全相关的特性，这些特性需要子类来提供，那么一定在参数类型中反映出这一点。否则功能不能使用就毫无意义。 不要使用保留参数。 如果将来需要更多参数，那么可以增加一个重载成员。 反例： public void Method(SomeOption option, object reserved); 更好的做法是，按需给今后的版本增加一个参数： public void Method(SomeOption option); public void Method(SomeOption option, string path); 枚举 or 布尔 如果参数中包含两个或两个以上的布尔类型，那么请使用枚举。 Stream stream = File.Open(\"foo.txt\", ture, false); // // 这个方法调用没有为代码阅读者提供任何信息来理解true和false背后隐藏的意义。 如果使用枚举的化会容易理解的多。 Stream stream = File.Open(\"foo.txt\", CasingOptions.CaseSensitive, FileMode.Open) 如果函数中有多个布尔参数，如果开发人员不小心将参数搞反，编译器和静态分析工具对此是爱莫能助的。现代编辑环境中提供了智能提示和导航能够一定程度的解决提示问题。 思考：数值常量和布尔常量 因为开发人员不希望使用魔数（magic number），所以会用数值常量或变量来传递数据， 但是却在忽视对布尔类型的使用， 大多数情况下他是作为 字面常量来传递的。 不要使用布尔型参数，除非你完全确信永远不需要两个以上的值。 枚举型让你有空间将来扩展值，但你应了解向枚举添加值所带来的全部影响（比如会有兼容性的风险）。 参数的验证 请验证传递到公共、受保护的函数的参数。 如果验证失败应引发 [System.ArgumentException] 或其子类异常。 public class StringCollection:IList{ int IList.Add(object item){ string str = item as string; if (str == null) throw new ArgumentNullException(...); return Add(str) } } ​ 注意，并非一定要在公共函数或受保护函数中实现验证逻辑，也可以放在更低层的私有函数中。 要点在于所有直接暴漏给最终用户的函数都应该验证参数。 不要忽略枚举参数，请验证它！ 不要认为用户传入的枚举参数一定会在枚举定义的范围内。CLR 允许将任何整数值强制转换为枚举值，即使值未在枚举中定义。 public void PickColor(Color color){ if (color > Color.Black || color < Color.White){ throw new ArgumentOutOfRangeException{....}; } ...... } ​ 为什么强调这一点？ 因为CLR支持数值类型向枚举的转换，所以超出枚举范围的数值是有机会转换为枚举进行传递的，通常不会被报错。 请谨慎将 Enum.IsDefined 用于枚举范围检查。 因为它的开销很大。 参数的传递 不要以引用的方式（ref）传递引用类型。 只有有限的几种情况例外，比如交换引用的方法。 public void Swap<T>(ref T obj1, ref T obj2){ T temp = obj1; obj1 = obj2; obj2 = temp; } 但是，这中例外情况几乎没有看到有价值的应用场景。 对性能极度敏感的 API 中，请谨慎使用 params 关键字，而是提供特定参数的重载。 从实现的角度看 params 关键字会将不定参数转换成临时数组的形式，换言之他只是对数组参数包了一层语法糖而已。 public static string Format(string format, object[] parameters); public static string Format(string format, params object[] parameters); // 以上的定义在编译后的结果是一样的， 下面在调用时享受到了语法糖带来的简单。 String.Format(\"File {0} not found in {1}\",new object[]{filename,directory}); String.Format(\"File {0} not found in {1}\",filename,directory); ​ 对哪些非常低层的函数来说创建临时数组和验证数组的开销会成为很大的负担。 因此要尽可能在调用栈的高处使用params， 也就是说在那些大一些的，做更 多工作的函数中。 如果需要在函数中对不定参数进行修改，请不要使用 params 关键字。 因为编译器会在调用点将params参数放到一个临时数组中，因此数组可能只是一个临时对象，任何对它的修改都会丢失。 要注意传入的 params 数组参数可能是 null 应该在处理之前验证数组不为 null 。 static void Main(){ Sum(1, 2, 3, 4, 5); // result: 15 Sum(null); } static int Sum(params int[] values){ if (values == null) throw AugumentNullException(...); int sum = 0; foreach(var v in values){ sum += v; } return sum; } 指针参数 一般来说，在精心设计的托管代码中不应该出现指针。大多数情况下应该对指针进行封装。 但是在某些情况下，为了支持与其他系统的互操作，使用指针是合适的。 请为任何以指针为参数的函数提供一个替补函数，因为指针不符合 CLS 规范。 [CLSCompliant(false)] public unsafe int GetBytes(char* chars, int charCount, byte* bytes, int byteCount); public int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, int byteCount); 请参考研究 Encoding 成员函数的定义。 方法 or 属性 我们在编写 C# 代码的时候最常面临的选择是把成员设计成属性还是方法？ .NET 团队定义属性的初衷是想提供一个 智能字段 ， 其智能体现在： 能控制访问限制 能够封装字段（面向对象的封装原则，永远不要公开对象的状态-字段） 能够做安全校验 能够灵活的传递状态变更 能够共享内存等等 所以属性还是为了包装字段而存在的，但是往往对属性的使用泛滥了。 一个经验法则： 方法应该表示操作，属性应该表示数据 。 属性造成了大量的误解，看似字段不是字段，如果是我参与.NET 以及编译器的设计，我根本不会提供属性，相反我会让程序老老实实的实现 GetXxx 和 SetXxx 方法 --Jeffrey Richter 如果该成员表示类型的一种逻辑特性。考虑使用属性。 例如：Button.Color 是属性，因为颜色是按钮的一种属性。 在.NET框架设计的早期，微软尝试把所有的 Get 方法都改成了属性，如：Type.GetName->Type.Name ; 但是在 Guid 类中却并非如此，有一个按顺序产生下一个 Guid 的方法 Guid.GetNext() 被改成 Guid.Next 后又被改回了方法，因为 Guid 天生并没有下一个值这样的属性 。 如果属性的值存储在内存中，且提供属性的目的仅仅是为了访问该值，请使用属性而不是方法。 要在下列情况中考虑使用方法而不是属性 该操作比字段访问要慢几个数量级。为了避免线程阻塞，你甚至考虑为此提供一个异步的版本。特别是访问网络或文件系统的操作时（在初始化时只执行一次的除外）。 该操作是转换操作。如：Object.ToString() 方法。 该操作在每次调用时返回不同的结果，即使传入的参数不变。如：Guid.NewGuid()； DateTime.Now 就应该设计为函数 -- Jeffrey Richter 该操作具有严重的、显而易见的副作用。 该操作会返回内部状态的一个副本（不包括栈上值类型的对象副本） 该操作返回一个数组。 这条规格对我们的冲击比较大。 因为大多数情况下我们会很自然的定义数组属性。 那么 .NET 提供属性的目的是啥： 设计数组的初衷是为了满足面向对象的封装性 ，不把内部数据暴露出去（字段）。 而数组属性破坏了这一原则，从经验上看在数组属性中对字段的更新也是无法控制的，以至于我们设计了 ArrayData 属性来代替数组属性。 如果在不破坏封装性的情况下数组属性可以返回一个副本，如下，那么在循环逻辑中这又会造成大量的 GC 垃圾 public int[] DataArray { get{ int[] copy = new int[dataArray.Length]; Array.Copy(intArray, copy, dataArray.Length); return copy; } } private int[] dataArray= new int[32]{0}; 两个方法解决以上问题： 把属性改为函数，通过函数的方式能够让调用方很轻易的识别出这是数据的副本 GetDataArray() 。 将数组属性改为只读集合 ReadOnlyCollection ，以只读的形式访问数据。 public ReadOnlyCollection<string> DataCollection { get{ return dataCollection; } } private List<int> data = new List<int>(); private ReadOnlyCollection<int> dataCollection = new ReadOnlyCollection<int>(data); 注意：其实 ReadOnlyCollection 并不是绝对的只读，其只能保证对集合增删的保护，通过索引的方式可以更新 dataCollection 内部元素，好在这个更新过程可以像属性一个被监控。 这个条目讨论到这里，也并没有完全理清楚对于数组属性的态度， 还需要继续做工作...-- konglinglei. 防御式编程 防御式编程的主要思想是：函数体应该不因传入错误数据而被破坏，哪怕是由其他子程序产生的错误数据。更一般的说，其核心想法是要承认程序都会有问题，这些问题都需要被修正，聪明的程序员应该根据这一点来编程。 [代码大全2.0] 防御式编程的目的是面对不可靠的外部世界，通过各种防御手段避免代码中引入不可控的错误，使系统更加的安全和健壮。 编程中的错误 如果要保护我们的程序免遭破坏，就需要对编程中的错误做出反应。以下对编程中的可能出现的错误归纳分类，然后通过一些关键方法的定义和应用实践来防御。 外部非法输入错误： 外部接口调用（文档、网络、数据库等读写接口）时，通过参数传入的输入错误。 系统异常： 直接或间接触发的操作系统级别异常（如堆栈异常、磁盘异常、网络异常等等）。 编码 BUG： 设计错误或编码错误导致的和预期不一致的输出。 防御技术概述 借助防御式编程技术可以让错误更容易发现和修改、减少错误对产品代码的破坏。本章节试图讲清楚什么是断言，什么错误处理，什么是异常，以及他们之间的关系，同时提供一些基本的设计原则。 断言技术 断言是指在 开发和维护期间 使用的，让程序在运行时根据假定 自检的代码 。用断言来处理绝不应该发生的状况，这些状况通常是 编程中的 BUG ，因为是开发维护阶段，所以一旦发生了断言，应该修正代码并重新编译。 总结：断言，在开发阶段防御编程的 BUG 。 扩展探讨： 断言技术在 .NET 中并不是开发和维护阶段特有的，调试版本提供了 Debug.Assert，发行版本提供了 Trace.Assert；而且从契约式编程的一些技术手段上也看到通过发行版本的 Assert 进行契约描述的场景。所以本节讲到的断言技术的定位是比较常规的实践。在不打破这种常规时间的情况下可以好好思考断言的其他应用场景。 错误处理技术 这是一个比较笼统的名字，除去编码 BUG 之外的所有错误（外部非法输入、系统异常）的处理都归类到错误处理技术中。错误处理是在 生产环境下 用来处理那些 预料中 可能要发生的错误。并对其做出响应。 错误处理技术遵循一个原则： 优先用最稳妥的方式在局部处理错误，在局部没有能力处理时，将控制权交给调用方。 局部处理错误的场景比较复杂，往往是函数功能规格设计的一部分，类似【接口契约】 比如遇到错误的输入时： * 返回中立值 * 换用下一个正确的数据 * 返回前次相同的值 * 返回最近有效值 * 记录日志或警告 * 关闭程序 ... 当函数没有能力处理错误时，通过以下方式将控制权转交给调用方： * 返回错误码 * 抛出异常 选择抛出异常 还是返回错误码？ ----在面型对象的语言中，如果你决定让高层次代码（调用方）来处理错误，低层次代码只需要简单报告错误，那么就要确保 高层次代码真的处理了错误 ！千万不要忽略错误信息。防御式编程的重点就在于防御哪些你未曾预料到的错误。但是实际的情况是错误码很容易被忽略，所以除非有针对性的设计规范，否则优先抛出异常。 错误码：技术上可被忽略的错误反馈，所以经常被忽略！ 隔栏 隔栏 并不是处理错误的手段而是以防御式编程为目的而进行隔离的一种 设计方法 。 其把某些 接口 作为 安全区域 的边界，对穿越安全边界的数据进行合法性校验，当数据非法时做出敏锐反应，与此同时其私有方法可以假定数据都是安全的了。 隔栏的使用使断言和错误处理有了清晰的区分。 隔栏外部的程序应使用错误处理技术，在那里假定任何数据都是不安全的；隔栏内部的程序就应该使用断言技术，因为传进来的数据应该已经在通过隔栏时被清理过了。如果隔栏内部的某个函数检测到了错误的数据，那么这应该是编程的错误（BUG）而不是数据的错误。 隔栏内部检测到了输入错误，说明这是一个编程 BUG！ 健壮性和正确性 正确性意味着永不返回不准确的结果，哪怕不返回结果也要比返回不准确的结果好；健壮性意味着要不断尝试采取某些措施，以保证软件可以持续的运转下去，哪怕有时做出一些不够准确的结果。 人身安全攸关的软件往往更注重正确性而非健壮性。不返回结果也比返回错误的结果要好。比如一些医疗器械软件就是体现这一原则的好例子。消费类应用软件往往更注重健壮性而非正确性。通常返回一些结果要比软件停止运行要强。比如表格处理软件。 防御式编程最佳实践 没有完美的代码 要承认没有完美的代码，所以需要务实的心态，主动对错误进行防御。 用断言检查编程 BUG 用错误处理来处理预期会发生的状况，用断言来处理绝不应该发生的状况。 ​ 错误处理通常用来检查有害的输入，而断言用来检查代码中的 BUG 。所以当程序员喜欢讲\"这件事绝不会发生。。。时，请用断言来覆盖它。 避免把需要执行的代码放入断言中。 将可以在生产环境下执行的函数或逻辑放入到断言中， 会造成很严重的副作用。因为当你关闭断言时，逻辑就不完整了。 // 在发行后，Debug不生效，要确保不会造成逻辑上的不一致。 Debug.Assert (meas(i) != 0 ); // 消除副作用的办法可能只需要一个临时变量。 temp = meas( i ); Debug.Assert ( temp != 0 ); 使用断言来注解并验证前置条件和后置条件。 在符合 契约式设计 的设计中，断言时代替契约注释的比较好的手段。但是断言优先关注私有函数的契约，公开函数的契约通过错误处理的手段来检查。 契约式设计是独立于 防御式编程的另外一套设计方法，其目的是通过契约的方式约束客户和供应商的权利和责任，实施好的契约式编程同样达到了防御的目的，错误处理和断言也是其手段。所以我感觉 契约式编程也是防御式编程的一种设计方法。 在 .NET 中提供了发布时的断言接口 Trace.Assert 来解决在在生产环境下对关键的输入进行断言跟踪的需求， 因为断言是有性能成本的，所以这个接口的使用要谨慎。 那么哪些情况下在生产环境使用断言？ 是否要出一个设计准则？ 异常 or 错误码 尽量不要返回错误码， 特别是在框架层面异常是用来报告错误的主要方式。 往往异常会传递到 监管程序 掌控，错误码是在技术上允许被忽视的方法，所以非常不可靠。 要通过抛出异常的方式来报告 操作失败 。 如果一个函数无法成功完成它名字语义上支持的任务，那么应该认为是操作失败并抛出异常，因为除了抛出异常你不知道该如何处理这个结果。 例如一个名为 ReadByte 的方法，在流程没有数据可读时，应该抛出异常。 同时一个名为 ReadChar 的方法在相同的情况下却不应该抛出异常，这是因为 EOF 是一个有效的字符，在这种情况下可以作为返回值。这样，方法就能够完成他的名字所对应的任务。 不能用异常来推卸责任。 如果某种错误的情况可以在局部处理掉，那就再局部处理掉它。不要把本来可以局部处理的错误或流程当作未捕获的异常抛出去。 例如，用来调用某个成员之前检查前置条件，这样用户编写的代码就不会引发异常。 ICollection<int> collection= ... if (!collection.IsReadOnly){ collection.Add(additionalNumber); } 这属于 tester-doer 模式，如果此模式开销高可以考虑 Try-Parse 模式。 优先稳妥的在局部处理所有错误，局部处理的实践指导需要给出。 抛出异常 在恰当的抽象层次抛出异常。 抛出的异常也是接口的一部分，所以决定将异常传递给调用方时，要确保异常的抽象层次和函数接口的抽象层次一致。 // 反例： class Employee{ public TaxID GetTaxId(){ throw new EOFException(); } } // 正例： class Employee{ public TaxId GetTaxId(){ throw new EmployeeDataNotAvailable(); } } GetTaxId() 把更低层次的 EOFException（文件结束）异常返回给他的调用方，它本身并不拥有这一异常，这会使调用方和更低层次的异常代码耦合，破坏了封装性。 与之相反，代码应抛回一个与其所在类接口相一致的异常，这中封装既没有暴漏实现细节，也充分的保持了接口的抽象性。 ​ 在框架设计层面，这个指导会要求框架设计人员要对异常的定义有一个整体的一致性的规范，并文档化。 避免在构造函数或析构函数中抛出异常，除非你在同一个地方将他们捕获。 在构造中抛出异常会让处理异常的规则变得复杂，而且中断的构造函数在处理后也无法调用析构，会造成潜在的资源泄露。在析构函数中抛出异常也有类似问题。 注意： 在 C++ 语言下这一条比较合适的，托管程序中对象的构建是在构造函数之前完成的，所以析构会得到执行，不过同样要确保对资源状态和依赖关系的检查。相关的讨论在构造函数设计准则下也有。 如果在公开函数中因为违反了契约而抛出异常，请为所有的异常撰写接口文档。（契约式设计） 如果异常是契约的一部分，那么他们不应该随版本而变化（也就是说，要具备兼容性，既不应该改变异常的类型，也不应该增加新的异常）。 API 规格或许应该就是契约的描述？ --konglinglei 必要时，终止进程而不是抛出异常 考虑在代码遇到了严重问题且无法继续安全的执行时，通过调用 System.Environment.FaiFat 来终止进程，而不要抛出异常。系统失败是无法由调用者处理，在这种情况下，关闭进程的最佳方式是调用 Environment.FailFast ，他会将系统状态记录下来，这对诊断问题非常有帮助。 处理异常 对异常处理： 如果 catch 代码块来捕获某个特定异常的异常，并完全理解 catch 代码块之后继续执行对应用程序来说意味着什么，那么我们说这种情况是对异常的处理。例如：试图打开一个配置文件时，如果文件不存在，那么可以捕获 FileNotFoundException ，并在这种情况下使用默认的配置文件。 把异常吞了： 如果捕获的异常具体类型不确定（通常都是如此），并在不完全理解失败的原因或没有对失败做出反应的情况下让应用程序继续执行，那么我们把这种情况称为把异常吞了。 不要在 框架代码 中捕获具体类型不确定的异常（比如：System.Exception 、System.SystemException 等等）时把异常吞了。 try{ File.Open( ... ); }catch(Exception e){ // 在不知道异常原因的情况下，吞掉了所有异常，不要这样做。 } 如果需要把异常转移到另一个线程，那么可以捕获具体类型不确定的异常。 很多时候会发生这种问题(比如 异步编程时，线程池操作时)， 如果把异常转移到另一个线程，这么做就不能算是把异常吞了。 切记：在线程间转移异常时，必须保证已经做好了响应的防护，不会发生把异常漏掉的情况。例如：如果捕获了一个异常并将它放入一个列表中，但却没有别的线程对这个列表检查，那么这等于是把异常吞了。其后果和忽略错误码的后果一样糟糕。 不要在 应用程序 代码中，捕获具体类型不确定的异常（system.exception\\systemexception 等等）时，把异常吞了。 作为框架代码的监管程序，如果要把异常吞掉，继续执行程序，意味着要冒状态不一致的风险。 权衡这种风险可以关注以下两点： 哪个组件抛出的异常，契约是什么（通过契约来约束调用程序）。 异常的抛出点和捕获点之间有完全的调用栈，并且你确定栈中的每个方法已经在返回之前适当的清理了全局状态。 如果不知道以上两点，那么你就不知道一些全局状态是否已经处于 半修改 状态，在这种情况下让程序继续运行可能会导致奇怪的错误。 如：OutOfMemoryException 、StackOverFlowException 或ThreadAbortException，他们可能会发生在许多地方。 不要捕获不应该捕获的异常。通常应该允许异常沿着调用栈向上游传递。 这一点怎么强调都不过分 。这种案例太多，开发人员捕获了不该捕获的异常，而使第一现场缺陷更难以发现。所以不要随便捕获异常，应该把缺陷都暴露出来。由有能力的监管程序来处理。 又如何来权衡哪？根据前面的原则，能够在局部处理的错误要局部处理掉，没有能力处理的要交给调用者，所以不要捕获不应该捕获的异常。 要在捕获并重新抛出异常时使用空的 throw 语句。这是保持异常调用栈不变的最好方法。 public void DoSometing(FileStream file){ long position = file.Position; try{ ... // 一些读操作 }catch{ file.Position = position; // 必要的恢复操作 throw; // 重新抛出异常 } } 注意：抛出一个新的异常（与重新抛出原来的异常相比）相当于报告了一个不同的错误， 而不是实际发生的错误。这会妨碍调试应用程序。因此，应该优先抛出原来的异常，而不要抛出新的异常。最好是完全避免捕获和（重新）抛出异常。 要在对异常进行重新封装时为其指定内部异常（inner exception）。 这一点再怎么强调也不过分。如果拿不定主意，就不要封装异常。 我们知道 CLR 反射就是这样的例子，当通过反射来调用一个方法是，如果该方法抛出了异常，那么 CLR 会捕获并抛出新的 TargetInvoctionException ，这实在让人恼火，因为他隐藏了实际存在问题的方法和发生问题的位置。正是由于反射封装了异常，使我们在调试自己代码是浪费了很多时间（因为要去寻找 InnerException）。 参考说明 Test-Doer 模式 有时候，可以把抛出异常的成员分解为两个成员，这样就能够提高该成员的性能。让我们来看看 ICollection 接口的 Add 方法。 ICollection<int> numbers = ... numbers.Add(1); 如果集合是只读的，那么 Add 方法会抛出异常。在 Add 方法经常会失败的场景中，这可能会引起性能问题。缓解问题的方法之一就是在试图调用 Add 方法前，检查集合是否可写。 ICollection<int> numbers = ... ... if (!numbers.IsReadOnly){ numbers.Add(1); } 用来测试条件的成员成为 tester ，在前面例子中就是 IsReadOnly 。用来执行实际的操作并可能会抛出异常的成员成为 doer ，在前面的例子中就是 Add 方法。 使用这种模式无比小心，如果该方法设计为线程安全的方法时，要考虑竟态条件，在线程不安全的方法中，需要用户来保证。 Try-Parse 模式 该模式对成员的名字进行调整， 是函数语义中包含一个预先定义好的 tester 。例如， DataTime 定义了一个 Parse 方法，如果解析失败会抛出异常，同时他还定义了与之对应的 TryParsef 方法，它会试图解析，但在解析失败时会返回 false ，而在解析成功时则通过一个输出参数来返回结果。 public struct DateTime{ public static DateTime Parse(string dateTime){ ... } public static bool TryParse(string dateTime, out DateTime result){ ... } } 在使用这个模式时，非常重要的一点是要严格定义 try 操作。如果因为 try 操作之外的原因而导致成员失败，那么成员也仍旧应该抛出异常。 在实现 Try-Parse 模式时使用 Try 前缀，并用布尔类型作为方法的返回类型。 要为每个使用 Try-Parse 模式的方法提供一个会抛出异常的而对应成员。 契约式编程 契约式编程允许函数接口和调用方之间建立契约关系， 这个契约允许双方在不同的 API 之间表达需求和承诺。 其核心思想是通过技术的手段将 API 的需求和承诺与实现相分离（不是绝对的分离），在契约式编程之前，契约关系是沟通注释说明来表示的。 契约式编程允许代码中指定前置条件、后置条件和对象的固定条件。前置条件是输入方法或属性时必须满足的要求。后置条件描述在方法或属性代码退出时的预期。对象固定条件描述处于良好状态的类的预期状态。 public int CountWhitespace(string text) { Contract.Requires(text != null, \"text\"); Contract.Ensures(Contract.Result<int>() >= 0); return text.Count(char.IsWhiteSpace); } .NET4 版本上微软提供了契约式编程能力（代码协定）， 但是从 .NET5 开始，微软过期并移除了这个库的支持。 从老版本的使用上看，Framework 内置的契约式编程在实现和维护上是有些麻烦的，其实现的机理远远超出了基础语言的范畴，要配合语法糖编译、工具才能够理解， 所以我感觉面向接口的契约式规格的意义大于契约式编码的实现... -- konglinglei 标准类型异常 本节描述了框架提供的部分标准异常以及他们的使用参考，具体请参阅 MSDN Exception 与 SystemException 不要抛出 System.Exception 或 System.SystemException 异常。 不要在框架性质的代码中捕获 System.Exception 或 System.SystemException 异常，除非打算重新抛出，或在顶层处理模块中。 ApplicationException 不要抛出 ApplicationException 或从它派生的新类。 InvalidOperationException 要抛出 InvalidOperationException 异常--如果对象处于不正确的状态。 如果无法根据对象当前状态设置对象某个属性或调用某个方法，那么应该抛出此异常。例如：往只读的 FileStream 写入数据就应该抛出此异常。 ArgumentException\\ArgumentNullException\\ArgumentOutOfRangeException 需要的时候可以直接抛出这些异常。 NullReferenceException\\IndexOutRangeException\\AccessViolationException 不要让公共 API 显式或隐式的抛出这三类异常。这些异常是专门留给执行引擎来抛出的，大多数情况下他们表示代码存在缺陷。要仔细检查参数，避免抛出这些异常。抛出这些异常会暴露方法的实现细节，而实现细节可能会随着时间而改变。 ComException\\SEHException\\ExecutionEngineException : 不要显式抛出以上异常，只有 CLR 才能抛出。 参考资料 [^1]: NET设计规范：约定、惯用法与模式(第2版) [^2]: 代码整洁之道 [^3]: 代码大全2 [^4]: 程序员修炼之道 [^5]: 托管代码分析警告(MSDN) 待办事项 * 函数的单一职责 只做一件事情 同一个抽象层次 临时变量的单一职责 高内聚 * 函数可重入性 * 函数的可测试性 * 函数体其他设计 switch 语句 循环策略 长度短小 快速退出（深层嵌套） 最小变量作用域 提炼子方法原则"
  },
  "doc/研发管理制度规范/功能规格设计活动流程&规范-R1.html": {
    "href": "doc/研发管理制度规范/功能规格设计活动流程&规范-R1.html",
    "title": "功能规格设计活动流程&规范",
    "keywords": "功能规格设计活动流程&规范 版次：2020年11月X日 第1版 文件类型：程序文件 上层文件：软件开发过程要求 上海维宏电子科技股份有限公司 版权所有 修改历史 文件版本 修改前文件版本 主要修订内容和原因 修订人 修订日期 R1 新建 谷艳艳 1 目的 明确功能规格设计活动的流程及要求，为活动执行提供指导。 2 适用范围 软件平台及各产品线团队。 3 术语和定义 下列术语和定义适用于本文档。 规则：执行活动时必须遵守的约定。 说明：对活动执行内容进一步补充说明 示例：对规则中描述的内容给出正确的例子。 4 活动流程 4.1 流程图 图 1 功能规格设计活动流程图 4.2 流程详解 表 1 功能规格设计活动流程详解 活动名称 活动描述 负责人 备注 功能规格设计 根据需求内容编制或维护已有功能规格书。根据需求内容确定软件功能，查看《产品功能规格表》确定功能对应的规格，以及规格编号。 有规格：对已有的规格进行维护。 无规格：按照功能规格模板编制功能规格。 软件开发 1. 《产品功能规格表》存放路径详见“4 附录”。 2. 功能规格模板： 《功能规格模板（GM指令、API）-Rn》、《功能规格模板（带UI）-Rn》 功能规格评审 对输出的功能规格书由专业团队进行统一评审。 1. 评审内容参考《功能规格审核 Checklist》。 2. 主评审人需要给出评审结论：通过、不通过、有条件通过。 3. 评审后软件开发需输出DR实施表，记录评审基本信息以及评审中提出的意见。 4. 评审完成后，软件开发根据评审意见修改文档，并且需将修改方式更新到DR实施表中，并与提出意见的评审人员确认，直至评审通过。 5. 评审通过后软件开发需将DR实施表中的信息补充完全，并归档至指定位置。 产品经理办公室 具体待定 归档位置详见“4附录”。 归档 更新《产品功能规格表》，将功能规格上传至指定位置：对于新增加的规格编号以及功能名称，需要添加到《产品功能规格表》中， 并将功能规格名称与对应规格文档做链接。 待定 1. 归档位置详见“4 附录”。 2. 在Excel中做功能规格链接时，前半部分链接不变，后面将文件存储位置补充完整即可： http://www.wiki.org:81/#!研发过程记录文件/产品功能规格/ （存储位置） 5 活动执行规范 5.1 功能规格设计 【规则 1-1】新功能开发必须有功能规格设计活动，并输出功能规格书。维护性功能开发，若已有功能规格书，则需同步维护原有功能规格书；若无功能规格书，由总工判断是否需要补充功能规格书。 【规则 1-2】功能规格书中必须注明“规格编号”。 说明：在指定规格编号时，不确定具体编号时，可以“X”代替不确定项，以此避免多团队同时在某一章节增加编号时造成冲突，规格评审通过将功能规格添加到《产品功能规格表》中时再按照已有功能编号顺序添加即可。同时需要更正功能规格书中的规格编号。 示例：例如需要在 6.8 章节增加一个功能，未评审通过时可以先定编号为“6.8.X”；规格评审通过后，将编号更新到《产品规格表》时，6.8 章节只有 6.8.1，则可以定此功能编号为 6.8.2。 【规则 1-3】功能规格书命名规则如下： ​ <团队名称>-<功能名称>-功能规格-Rn.md 说明： <团队名称>：产品线细分行业专用功能使用，通用功能不需要。 <功能名称>：该功能名称。 Rn：文档版本号，n 为十进制整数，起始值为 1，只增不减。 示例：通用功能：断点继续-功能规格-R1.md，行业专用功能：激光-随动自动防撞-功能规格-R1.md 【规则 1-4】DR 实施表命名规则如下： ​ DR 实施表(功能规格)-<团队名称>-<功能名称>-Rn.xls 说明： <团队名称>：产品线细分行业专用功能使用，通用功能不需要。 <功能名称>：评审的功能名称。 Rn：文档版本号，n 为十进制整数，起始值为 1，只增不减。 示例：通用功能：DR 实施表(功能规格)-断点继续-R1.xls 行业专用功能：DR 实施表(功能规格)- 激光-随动自动防撞-R1.xls 【规则 1-5】功能规格书中若附带有图片，则图片统一存放在名称为“images”的文件夹中，将功能规格书和 images 文件夹统一保存在以功能名命名的文件夹中，上传到指定位置；没有附带图片，直接将功能规格书上传到指定位置即可。 示例： 刀具寿命管理功能规格书中附带有图片，则在 CNC 文件夹中创建“刀具寿命管理”文件夹，里面包含“images” 文件夹和“刀具寿命管理- 功能规格-R1.md ”功能规格书。 刀具补偿功能规格书中未附带图片，直接将“刀具补偿--功能规格-R1.md”存放在 CNC 文件夹中即可。 5.2 功能规格评审 【规则 2-1】各团队的功能规格统一在“产品功能规格评审会”中进行评审。 【规则 2-2】功能规格书更新一次只输出一份 DR 实施表，用以记录针对本次修改，通过评审发现的所有问题，多次复评的相关信息在同一份表格中更新，直到评审通过。 5.3 归档 【规则 3-1】功能规格书存放需要以 md 格式存放。 【规则 3-2】一份功能规格文档链接在一个主功能中，子功能可不做链接。若文档中涉及的子功能不在同一个主功能下，需要单独链接。 示例： 一份规格文档，主要介绍规格编号为 6.8.1 的功能，及其子功能“6.8.1.1” “6.8.1.2” “6.8.1.3”，则只需要在 6.8.1 上做链接即可。 攻牙的功能规格文档中还涉及到 G84指令，因此需要同时在攻牙功能和 G84指令上做链接。 6 附录 表 2 相关文档存放位置 序号 文档名称 存放位置 1 功能规格模板 http://www.wiki.org:81/#!维宏研发/设计阶段/模板/功能规格模板-R1.md 2 DR 实施表（功能规格）-<团队名称>-<功能名称>-模板 http://www.wiki.org:81/#!维宏研发/DesignPhase.md 3 功能规格审核 Checklist http://www.wiki.org:81/#!维宏研发/DesignPhase.md 4 产品功能规格表 Wiki 查看位置： http://www.wiki.org:81/#!维宏研发/设计阶段/产品功能规格/产品功能规格表.md TFS存储位置： tfs.weihong.com:8080/tfs/spi/Process Improvement/mdwiki-SPI/维宏研发/设计阶段/产品功能规格 5 功能规格书 TFS存储位置： tfs.weihong.com:8080/tfs/spi/Process Improvement/mdwiki-SPI/产品研发/设计阶段/产品功能规格 6 DR 实施表 \\file01.weihong.com\\01.部门共享\\09.软件部\\04.记录文件\\09.各团队DR实施表 编制： 审核： 批准："
  },
  "doc/研发管理制度规范/包历史记录填写规范-R1.html": {
    "href": "doc/研发管理制度规范/包历史记录填写规范-R1.html",
    "title": "包历史记录填写规范",
    "keywords": "包历史记录填写规范 版次：2018年4月26日 第1.0版 类型：程序文件 作者：Phoenix 架构平台 上海维宏电子科技有限公司 版权所有 1. 目的及适用范围 编写本规范的目的是为了统一 Phoenix 打包时的历史记录的编写风格，提高历史记录的一致性和可读性； 方便使用工具将包中的历史记录抽出作为 markdown 保存起来。 2. 术语和定义 下列术语和定义适用于本规范： Add (shelveset Id) 指添加的功能 < 不兼容 >； Mod (shelveset Id) 指修改的功能 < 不兼容 >； Del (shelveset Id) 指删除的功能 < 不兼容 >； Fix(bugId)(shelveset Id) 指修复的bug < 不兼容 > 【注意】 shelveset Id 为按需添加； 【注意】 < 不兼容 > 为按需添加，不写默认为兼容。 2.1 术语说明 术语 说明 shelveset Id 提交代码后在 TFS 中的 ID， 方便查找 Code< 若有多个id，以逗号分隔向后添加 > bug id 修改的 bug ID Add 功能的添加。例如添加一个查询功能就属于 Add Mod 功能的修改。例如修改了查询功能的实现方式或者接口命名就属于 Mod Del 功能的删除。例如删除了查询功能就属于 Del Fix 表示修改了哪个 bug < 不兼容 > 表示与其他版本不兼容。需要明确标注出来，默认是兼容 注意： - 如果功能和其他版本不兼容必须在后面明确标注，并在下方 写出详细说明和升级指导 。 - 详细说明包括接口更改与接口删除等不兼容原因。 2.2 术语示例 3. 文件名称 历史记录文件名称是 history.md 。 文件名后缀为 .md ，表明是 markdown 文件。 记录内容要求 UTF-8 字符编码。 history.md 文件必须放在打包的根目录下。如果在项目其他目录下，生成项目时要求复制到根目录。 ### 3.1 文件名示例 history.md 4. 题目命名 题目由版本号和更新时间构成 。 4.1 题目示例 5. 内容 内容以 [*] 作为序号分隔符填写， 每一个内容代表一个更改。 5.1 内容示例 6. 不兼容与升级指导格式说明 不兼容与升级建议里需要包含不兼容的接口，功能等不兼容原因，并给出解决方案或升级指导。 6.1 不兼容示例 7. 完整示例 完整代码示例： `[1.502.2.0] - [2018.4.26]` ============================ * Add(30638)： 添加G寻址功能 * Mod(5544)： 将NC.DoBeforeLoop改名为NV.BeforeLoop(`不兼容`) * Del(33696)： 将注册功能从模块中移除（`不兼容`） * Fix(6831) (22387)：修复总线的脉冲轴运动不正确的bug `不兼容功能与升级指导：` * Mod(55448)： 将NC.DoBeforeLoop改名为NV.BeforeLoop(`不兼容`) * 修改内容： 将NC.DoBeforeLoop改名为NV.BeforeLoop，命名不规范 * 升级指导： 将用到NC.DoBeforeLoop改名为NV.BeforeLoop * Del(33676)： 将注册功能从模块中移除（`不兼容`） * 修改内容： 当前组件删除注册功能，按需求将其放入SignIn组件中 * 升级指导： 改用SignIn组件中的注册功能 `[1.402.1.0] - [2018.4.23]` ============================ * Mod(30618)： 将MAuto改为AutoInfo(`不兼容`) * Mod(30628)： 目前Lua子程序中除条件运动外，所有涉及到X，Y，Z的全部换成使用索引0，1，2(`不兼容`) * Del(33676)： 删除总线限位功能 * Fix(6836) (22387)：修复总线的脉冲轴运动过快的bug `不兼容功能与升级指导：` * Mod(30618)： 将MAuto改为AutoInfo(`不兼容`) * 修改内容： 将MAuto改为AutoInfo，名称的更改使名字表达的意思更加的清晰 * 升级指导： 将所有用到MAuto改为AutoInfo * Mod(30628)： 目前Lua子程序中除条件运动外，所有涉及到X，Y，Z的全部换成使用索引0，1，2(`不兼容`) * 修改内容： 将MoveTo(X=，Y=，...)改为MoveTo {{0} =，{1} =} * 升级指导： 将所有用到MoveTo(X=，Y=，...)改为MoveTo {{0} =，{1} =} 版本信息 版本 日期 修改人 修改内容 1.0 2018/4/26 Phoenix 架构平台 初版建立"
  },
  "doc/研发管理制度规范/子产品管理制度（试行）-R2.html": {
    "href": "doc/研发管理制度规范/子产品管理制度（试行）-R2.html",
    "title": "子产品管理制度",
    "keywords": "子产品管理制度 版次：2021年12月25日 第1版 类型：程序文件 部门：软件部 上海维宏电子科技股份有限公司 版权所有 1 目的 为了提高公司软件的复用性， 并进行有效管理， 特制定本制度。软件最大的魅力在于复用性上， 被软件开发人员奉为圭臬的“高内聚低耦合”，其实就是提高软件复用性的手段。 2 适用范围 本制度适用于研发体系及产品体系所有涉及软件产品的人员。 3 术语及定义 3.1子产品 子产品是具有明确功能实现的特性集合。往往是软件产品中的某一模块，为什么不用模块而采用子产品这个名称。有如下几个原因： 模块是针对软件产品进行业务功能划分的描述，而子产品可能跟业务相关度不高。 想更加强调该模块功能具备明确功能范围，经过验证，具备独立发布的能力。 如开发中常用的基础库：日志库SeriLog；对象映射库Mapster等。 具备以下条件： 明确的功能范围。必须包含：子产品的概要说明，功能列表，如何使用。如SeriLog GitHub 上的 README.md 。 完善的说明文档。必须包含：功能规格说明及设计方案。 功能的质量保证。测试代码的功能覆盖率需 100% 覆盖， 单元测试代码覆盖率需 95% 以上。 独立发布。如以独立的 nuget 包发布。 4 职责 4.1 软件部 负责子产品的申请 负责组织子产品评审 负责子产品的发布的形式审核 4.2 专家委员会 负责子产品的评审 负责子产品的发布审核 4.3 发起人 提交子产品的申请 负责子产品的交付 申请子产品的发布 5 子产品管理 申请 由发起人向软件部提交子产品的申请。 交付 由发起人实现子产品。 评审 发起人准备完成后，向软件部申请组织评审。软件部邀请相关专家委员会进行评审。专家委员会给出评审意见。 公布 发起人准备好 nuget 包后，由软件部统一公布。 子产品后续更新 由发起人更新后，经过专家委员会评审后，发布。必须包含：版本更新范围，及对应更新的测试用例。 6 奖励 6.1发布奖励 通过软件部发布成功的， 获得一次性奖励 xxx 元。 6.2 推广使用奖励 由发起人推动成功应用 3 个项目， 获得MVP项目奖励 xxx 元。 6.3 年度专项奖励 具体由软件部制定。如：最多 Star 项目。"
  },
  "doc/研发管理制度规范/家装制造产品部代码审核要求-R2.html": {
    "href": "doc/研发管理制度规范/家装制造产品部代码审核要求-R2.html",
    "title": "家装制造产品部代码审核要求",
    "keywords": "家装制造产品部代码审核要求 版次：2020年7月31日 第2版 类型：程序文件 部门：家装制造产品部 上层文件：软件开发过程要求 上海维宏电子科技股份有限公司 版权所有 1 目的 提高家装制造产品部代码审核质量。 2 适用范围 本制度适用于家装制造产品部所有软件开发人员。 3 职责 产品经理：负责审核本流程，审批是否外发临时版软件。 产品总工：负责监督流程执行，审批是否外发临时版软件。 代码实现人员：负责按照开发方案进行代码编程并自测，发行软件。 1） 严格遵守《软件编程规范》、《C# 编程规范》、《Lua 编程规范》的要求，并使用《代码审核 Checklist》进行自检。 代码审核人员：负责审核代码。 1） 使用《代码审核 Checklist》，按条目审核代码，若被审核人负责的业务不涉及的条目无需检查； 2） 严格审核代码逻辑性、可维护性和代码容错，在逐行审核的基础上，逐行读懂每一行代码的含义和设计思路，并重点关注 Copy 代码。 测试执行人员：负责按照测试点执行测试。 测试审核人员：负责审核测试记录。 助理：负责编写与维护本流程，外发临时版软件，发布正式版软件。 4 审核流程 4.1 一般情况 开发人员每日提交代码审核，RTX 通知审核人员审核。 开发人员当天 16:00 前提交的代码审核，审核人员需当天审核完毕。 开发人员当天 16:00 后提交的代码审核，审核人员需次日审核完毕。 若软件需当天发行，开发人员提交代码审核，审核人员需当天审核完毕。 4.2 特殊情况 特殊情况下，因时间紧急代码未审核，通过产品经理或产品总工审批后，可以发临时版软件。在发完临时版软件后必须要重新走正常流程。 如软件发行后工作项已关闭，因需求变更需新建工作项，开发人员需将情况上报产品经理和产品总工，经过批准后新建工作项并关联相关工作项，同时在对应工作项的历史记录里填写新建理由。 4.3 流程图 ​ 5 代码审核记录 工作项代码审核需要有相关的审核记录。 5.1 代码审核记录表 每个工作项审核后，审核人员需在工作项软件发行后一个工作日内填写《代码审核记录表》。 若评审不通过，则将问题点列出。 若评审通过，则注明评审通过，无需修改，同意签入。 5.2 TFS代码审核记录 每个工作项审核后，审核人员需及时在对应工作项的历史记录中填写评审记录。 记录方式不限，例如： 若评审不通过，则将问题点列出，可在附件中添加审核意见文档，模板不限，描述清楚问题即可； 若评审通过，则注明评审通过，无需修改，同意签入。 说明： 目前 Phoenix 平台已经使用 VS2017 自带的代码审核。由于其他平台的代码基本是在 VS2010 以下版本的，升级到 VS2017 工作量和风险过大，无法使用 VS2017 的审核机制，所以需要审核人在历史记录中添加审核记录。 5.3 代码审核结果处理 以《代码审核记录表》为依据，每月违反编程规范最严重的员工，助理汇总数据提交产品总工审核，产品线内通报批评；若同一员工连续三个月被通报批评，产品线内警告处分。 6 执行监督 若开发人员未经过正常流程代码审核或特殊情况审批，私自发行软件： 第一次：产品线内通报批评 第二次：产品线内警告处分 第三次：未认识到错误，拒不改正，给予劝退 审核通过后的代码出现质量问题，由产品经理、产品总工根据质量问题的具体情况判定责任归属。 7 附录 7.1 相关文件 《软件开发过程要求》 《软件编程规范》 《C# 编程规范》 《Lua 编程规范》 《代码审核 Checklist》 7.2 记录文件 《代码审核记录表-模板》 上述记录文件的存放位置：“（内网）： \\\\172.16.10.88\\02.各部门受限\\04.家装制造产品部\\00.模板 ”。 编制：周勤 审核：李德红、陈豫、竜正城 批准：郑之开 审批链接： http://172.16.1.166:85/workflow/request/ViewRequest.jsp?requestid=262178&_workflowid=564&_workflowtype=&isovertime=0"
  },
  "doc/研发管理制度规范/家装制造产品部开发评审制度-R1.html": {
    "href": "doc/研发管理制度规范/家装制造产品部开发评审制度-R1.html",
    "title": "家装制造产品部开发评审制度",
    "keywords": "家装制造产品部开发评审制度 版次：2020年11月2日 第1版 类型：程序文件 部门：家装制造产品部 上层文件：软件开发过程要求 上海维宏电子科技股份有限公司 版权所有 1 目的 集中优秀同事的技术为整个产品线开发工作把关，节省开发时间，提高开发质量，培养技术人才。 2 适用范围 家装制造产品部功能规格、开发方案、疑难问题。 3 评审团队 分类 主审人 评审人 雕刻 高立、徐鹏 袁飞 板式 高立、徐鹏 徐小龙、岳文学 4 职责 主审人：负责对评审内容进行评估（包括在评审前及评审中确定是否需要进行外审）。 1） 当主审人不能参加评审时，可由主审人指派临时主审人。 评审人：负责对评审内容进行评估。 1） 当评审人不能参加评审时，可由评审人指派临时评审人。 被评审人：准备评审内容及评审内容的整改执行。 1） 有评审内容配套文档，提前1天交给评审助理； 2） 无评审内容配套文档，将评审内容描述清楚即可。 评审助理：负责每日评审会的会前准备，维护《家装制造产品部内审纪录表》。 5 评审时间 工作日 9：00－10：00。（尽量控制在45分钟内） 若当天没有评审，评审助理提前一天在内审群内通知。 任务紧急等特殊情况另行安排。 6 评审对象 6.1 功能规格 新产品开发中，开发人员提交的功能规格。 在维护产品中，总工、组长或者项目负责人明确注明需评审的功能规格。 6.2 开发方案 新产品开发中，开发人员提交的设计文档。 部署工作项时，总工、组长、项目负责人要求评审的设计文档。 开发过程中，开发人员主动提出的设计文档。 6.3 疑难问题 开发过程中，开发人员主动提出的疑难问题。 7 评审流程 7.1 评审前 评审助理至少在评审时间前一天确定被评审参与人（由被评审人提交）、评审人及主审人，做好相应的其它会前准备，并通知各参会人员。 主审人、评审人需在会前查看完需评审的内容。 7.2 评审中 主审人及评审人应在评审会上对被评审人的参评内容给出中肯、切实可行的评价，被评审人对相关评价做好详细记录。 7.3 评审后 被评审人根据评审记录，撰写《DR 实施表（功能规格）-功能名称》，提交给评审助理。 主审人和评审人对被评审人的问题难度、评审内容评价和表现评价进行评价，提交给评审助理。 评审助理对评审人的评审后计划进行监督，评审内容未通过时，安排再次评审时间。 8 评审细则 8.1 评审内容 8.1.1 功能规格 背景、目的、优点（和竞品或旧规格相比）、效果、用语、限制事项、机种、版本对应表 被评审功能规格内容（功能一览、功能详情） 被评审功能规格格式规范（需严格使用公司《功能规格模板》） 8.1.2 开发方案 现有方案概述 被评审方案功能内容 被评审方案格式规范（需严格使用公司《开发方案模板》） 8.1.3 疑难问题 现有问题描述 现有问题处理思路描述 8.2 评价标准 8.2.1 功能规格 功能规格评价：通过、不通过 1） 通过：功能规格无方向性问题，内容清晰明确，表述准确，且有可实施性，且必须有规格实施必要性描述。 2） 不通过：功能规格中有方向性问题，或者思路不清晰，有一处或多处重要问题未描述清晰，需要进行再次评审 表现评价： 可参考：功能规格内容、准备情况、语言表达、内容格式 8.2.2 开发方案 方案难度：简单、中等、困难 方案评价：通过、不通过 1） 通过：无问题、或有少量可控问题，具体执行由主审人评价 2） 不通过：有重大问题，或者问题项很多，需要进行再次评审 表现评价： 可参考：方案设计、准备情况、语言表达、内容格式 8.2.3 疑难问题 问题难度：简单、中等、困难 表现评价： 可参考：准备情况、语言表达 9 触发外审条件 三个工作日内无开发方案 开发方案涉及平台 不能确定开发方案 有技术分歧，不能达成一致 10 附录 10.1 相关文件 《软件开发过程要求》 10.2 记录文件 《家装制造产品部内审纪录表-模板》 《DR 实施表（功能规格）-功能名称-模板》 《功能规格模板》 《开发方案模板》 上述记录文件的存放位置：“（内网）： \\\\172.16.10.88\\02.各部门受限\\04.家装制造产品部\\00.模板 ”。 编制： 周勤 审核：徐小龙、李德红 批准： 审批链接："
  },
  "doc/研发管理制度规范/平台软件发布规范-R3（试用）.html": {
    "href": "doc/研发管理制度规范/平台软件发布规范-R3（试用）.html",
    "title": "平台软件发布规范",
    "keywords": "平台软件发布规范 版次：2020年07月30日 第3版 类型：程序文件 部门：软件部 上海维宏电子科技股份有限公司 版权所有 文件版本 修改前文件版本 主要修订内容和原因 修订人 修订日期 R1 初版 汪腾霞 2016.08.17 R2 R1 1、将“5 发布版撤销”中的涉及“撤销“二字的，都改为作废； 2、“发布公告收件人列表“中新增抄送：软件开发工程师，并将《【审批】平台软件发布公告（软件名称）-模板-Rn.oft》中的收件人更新成和规范中的一致； 3、相关文件存放路径更新成服务器路径一致； 4、在“流程详解”下的软件开发需提交的发布材料一栏，新增还需提交发布 checklist 表。 王娟娟 2017.8.1、2017.11.7 R3 R2 1、 修改“2 适用范围”内容：将“特别说明”中的软件版本说明放置“6 附录”中，并去掉“2 个及以上团队” 的要求。 2、 修改“3 职责”内容：去掉“软件部门经理”的职责，重新定义其他人员职责。 3、 修改“4 发布流程” 内容：去掉“软件部门经理”审核环节，修改各环节责任人以及环节要求，修改“发布公告范围”。 4、 发布材料中增加《XX 不兼容性分析报告》 5、 修改“5 发布版作废”内容：增加 wiki、Nuget 等作废要求。 6、 增加“6.2 发布材料归档位置”。 谷艳艳 2020.4.23、2020.7.30 1 目的 本规范用于规范软件平台团队软件发布的流程。 2 适用范围 本规范适用于以下情况：由软件平台开发且会交付给平台外部或内部其他团队使用的软件产品（以下称“平台软件”）。 3 流程涉及人员 3.1 发布申请人 负责平台软件发布材料的收集和整理。 负责平台软件发布材料清单的编制和修改。 负责平台软件发布公告的编制和修改。 在 wiki 中登记产品发布公告。 邮件发送发布通知。 3.2 团队总工 负责平台软件实现方案的审核。 负责平台软件发布材料内容的恰当性、完整性进行审核。 负责平台软件发布公告的审核。 3.3 研发总监 负责平台软件发布公告的批准。 3.4 研发助理 协助归档发布材料。 4 发布流程 4.1 流程图 图 1 发布流程图 4.2 流程详解 表 1 流程活动 序号 活动名称 活动描述 负责人 备注 1 准备发布材料及清单 整理、修订待发布产品（组件或库）相关材料及材料清单。 发布申请人 1. 待发布产品提测后，开发人员可提前开始准备发布材料； 2. 发布材料详见表 2 发布材料。 2 发布申请 待发布产品（组件或库）测试通过后，可提起发布申请，申请中需明确： 1) 待发布的相关材料； 2) 计划发布的范围。（根据发布对象涉及的团队确定） 发布申请人 见表 3 发布公告范围 3 审核 对团队内提起的发布材料、清单及发布范围进行审核。 团队总工 4 批准 对发布请求进行批准。 研发总监 5 登记发布信息 将软件发布信息更新至团队的 MD wiki 中。 发布申请人 见表 2 发布材料 6 归档发布材料 将发布材料放置在各团队指定位置，具体见章节6.1。 发布申请人/研发助理 驱动与固件组的材料可以由研发助理协助归档。 7 发布通知 通过公司 Outlook 邮箱（外网）发送发布通知，将发布公告作为附件同时发送，需确保发送成功。 发布申请人 可视情况，增加其他的通知形式以便引起相关团队对发布信息的重视，比如 RTX、产品发布会等，由 发布申请人 决定。 表 2 发布材料 序号 发布材料 说明 备注 1 软件开发 功能规格书（软件名称） * 针对本次维护或新增功能的软件功能规格书。 2 软件开发 设计说明书（软件名称） 1) 对需求规格实现给出的设计方案； 2) 若需求简单，可不提供设计说明书(由团队总工指定是否需要设计说明书)。 3 软件开发 使用说明书（软件名称） 1) 发布工具类软件时，提供工具的使用方法、使用要求；新增功能特性时，须完善已有的使用说明； 2) 发布代码库时，对代码库的变更及代码库的使用要求进行说明。 4 软件开发 XX 不兼容分析报告 针对本次发布中不兼容的组件进行特别说明，主要包含：不兼容原因、造成的影响分析以及解决方案等。 5 软件开发 发布对象 * 直接的开发产物，如代码库、工具或软件。 6 软件测试 测试用例（软件名称） 计划用于软件测试的用例。 7 软件测试 测试执行记录（TFS ID） 软件测试执行过程的记录，包括使用环境、输入和结论。 8 软件测试 测试总结报告（软件名称）\\ * 针对本次软件测试情况的总结。 9 发布公告 发布公告内容 * 发布公告中包含内容详见《平台软件-XX 发布公告-模板》 说明：表 2 发布材料中“*”标记项为必备项。 表 3 发布公告范围 涉及范围 默认通知人员 产品体系 产品线经理、产品线总工、产品线测试组长。 软件平台 总工、平台测试主管。 自动化 总工、部门经理、测试主管。 供应链 供应链总监、仓储部经理、品管部经理、品质工程主管。 物联网研发 研发中心主任。 固定抄送 司令部、研发总监、产品总监、软件部门经理、软件部测试主管、发布申请人。 说明： 以上表格中除“固定抄送”，其他为若有涉及才加入公告通知范围，比如金属切削产品部、激光加工产品部。 以上涉及团队有列出默认通知人员，若需通知其他相关人员需特别指出。 5 发布版作废 若已发布版本在使用过程中出现问题，经调查须立即终止该版本的使用，由发布方及时发起作废。作废动作包括： 向发布审批人发出作废申请，申请通过后通过邮件、RTX 等方式通知发布版的接收方和其他相关方，作废公告内容包括：作废项、作废原因、紧急应对措施； 将作废的软件\\模块版本以及相关文档、资料标明作废处理： 1） 在 wiki 的发布公告以及其他相关资料中标记“作废”字样； 2） 若使用文档服务器管理存放发布版和相关资料，则在发布项名称上追加“作废”，并移至“作废”文件夹中； 3） 若使用 NuGget 服务器管理存放发布版和相关资料，则将作发布的作废版本进行删除，不允许再进行下载使用。 6 附录 6.1 版本使用说明 平台软件分 Alpha 版本、Beta 版本、Release 版本： Alpha（α）版本：为内部调试、测试版，此版本为初步完成品。 Beta（β）版本：外部测试版，此版本消除了严重的错误，但还是存在一些缺陷，需经过大规模的发布测试来进一步消除。产品线拿到现场调试的软件至少是此版本。 Release（R）版本：最终完成版。 接收方不得私自使用 α 版作为发布版本。理论上 α 版不可流到客户现场，如有特殊情况，产线应收集相关风险，并承担风险造成的后果。 6.2 发布材料归档位置 团队 归档位置 Phoenix http://phoenix.weihong.com:90/#!docs/Public/Public.md 驱动固件 \\\\172.16.10.66\\NWfile02\\01.安全内网文件夹\\01.研发部文件\\02.受限文件\\01.软件部\\受控文件 运动控制算法 \\\\172.16.10.66\\NWfile02\\01.安全内网文件夹\\01.研发部文件\\01.各组文件\\12.运动控制算法平台\\12.发布材料 CAD 172.16.10.101:8080/tfs/sp/cadcam/ 其他 发布内容涉及研发体系以外人员如供应链，须在“ \\\\172.16.1.111\\05.研发部文件\\产品文件 ”对应目录下创建相关文件夹并做材料归档 6.3 相关文件模板 《功能首字母-测试规格书-功能名-TFSID-姓名(通用)-Rn.xlt》 《测试总结报告(XXX)-模板-Rn.dot》 《平台软件-XX发布公告-模板-Rn.md》 《【审批】平台软件发布公告（软件名称）-模板-Rn.oft》 《使用说明书（软件名称）-模板-Rn.dot》 《平台软件发布登记表-模板-Rn.xlt》 《【审批】平台软件作废公告（软件名称）-模板-Rn.oft》 相关文件存放路径为： 外网路径： \\172.16.1.111\\01.各部门文件\\B1.软件部\\03.模板 内网路径： \\172.16.10.88\\01.部门共享\\09.软件部\\07.模板 编制：谷艳艳 审核：陈豫 批准："
  },
  "doc/研发管理制度规范/插件管理规范-R2.html": {
    "href": "doc/研发管理制度规范/插件管理规范-R2.html",
    "title": "插件管理规范",
    "keywords": "插件管理规范 文档版本：R2.0 1. 概要 1.1 背景 激光行业插件比较多，目前分为通用插件、平面专用插件、管切专用插件，在这些插件基础上，又有各类分支，造成插件代码分支管理难度增加，导致出现代码合并错误，忘记合并分支问题；没有统一的规范，新员工入职之后无章可循，只能自由发挥，进一步加剧分支混乱现象。代码分支的混乱最终体现在软件质量上。 另一方面，插件包版本号不规范，也造成了沟通成本的上升；本因从版本号就能传递的信息（是否兼容、Bug 修复等），必须要通过查代码、问开发人员才能获取，直接造成工作效率低下。 1.2 目的 降低代码维护难度 规范分支流程 规范插件包命名 1.3 用语 序号 用语 描述 1 插件 2 插件包 插件编译、打包的产物；给集成项目使用。 3 集成项目 4 软件 集成项目编译、打包出的产物；可销售的软件产品。 5 主动维护 由维宏主动发现 bug，解决 bug，发布 Fix 软件或补丁包的过程。 6 被动维护 在软件停止主动维护后，客户反馈有严重 bug 时修复 bug 的过程。 7 软件生命周期 软件的某个版本发布后到停止主动维护的时间段。 对于 Release 版本，生命周期为发布之日起到下一 Release 版本发布时截止； 对于 Beta 版本不主动维护。 8 插件生命周期 插件版本发布后到所有带这个版本的软件生命周期终止时的这个时间段。 2. 版本管理 2.1 插件版本 版本号规则： p.snn.f.rf[-suffix]， eg： 1.100.0.0-12345-alpha1 （参考 Phoenix 组件版本管理规则 ） 版本号升级规则： 序号 区段 说明 1 p 主版本号，必填，从 1 开始，无上限 2 s 子版本号，必填，从 1 开始到 9 3 nn 子版本序号，必填，从 00 开始到 99 4 f beta 修订版本号，必填，从 0~99：分支修订版本号 5 rf Fix 修订版本号，必填，从 0~99；Beta 分支发出来的版本，rf 都是 0 6 suffix 先行版本号，可选，由工作项 id 、后缀和序号组成，序号从 1 开始， eg： -12345-alpha1 各分段更新时机 P 段，插件有重大更新时触发 对外接口有重大变化， eg：吹气重构，开关气改用子程序接口操作； 插件入口有重大变化， eg：管顶料重构，功能配置从 NcConfig 挪到平台配置工具； 插件功能表现有重大变化， eg： s 段，插件正式发布新功能，不保证向下兼容（包括参数、接口和功能表现） nn 段，插件小规模增强，保证向下兼容（包括参数、接口和功能表现） f.rf 段，修复插件 bug，不包含任何新功能或功能增强（即不带 Task） suffix 段，在工作项迭代开发过程中存在，正式版本禁止带后缀 2.2 插件包路径 序号 目录名 路径 规则 1 本地 开发人员本地 Public 或其他路径 1. 只能用于自测 2. 带先行版本后缀 2 Public 目录 $/Laser/_Public 1. 可以是未经过测试的版本 2. 多人协同开发使用 3. 带先行版本后缀 3 包服务器 http://phoenix.weihong.com:8088/feeds/Laser 1. 必须是测试通过的 2. 不带先行版本后缀 3. 代码分支管理 3.1 分支目录 序 号 目录 名 描述 备注 1 Beta 主分支目录： 1. 测试通过后才允许提交到此目录 2. 一个插件在 Beta 目录仅有一个分支 3. 签入此目录代码必须通过代码评审 重点管理 2 Dev 开发分支目录： 1. 开发工作项时从Beta分支过来，测试验收通过后合并到 Beta 并删除 Dev 下分支 2. 多人合作开分支 3. 一个插件在本目录可以有多个分支 3 Fix 修复Bug分支目录： 1. 在修复外部反馈 bug 时从 Beta 分支出来，停止主动维护后删除 2. 测试通过后才允许提交到此目录 3. 签入此目录代码必须通过代码评审 4. 一个插件在本目录可以有多个分支 重点管理 分支示意图（插件） 3.2 插件分支管理 3.2.1 新建插件 在 Dev 下新建插件； 开发功能，开发迭代过程插件包，版本号为 1.100.0.0-Task ID-alphaN，放置路径： 本地 或 Public 目录 测试验收通过后，代码提交到 Beta，同时删除 Dev 下代码； 给 Beta 下本次提交的变更集打 Tag 【插件名-1.100.0.0】； 编译正式版插件包，版本号为 1.100.0.0，上传到包服务器； 合并功能到 Beta 目录下其它集成项目分支。 3.2.2 增加功能插件 从 Beta 下分支到 Dev （加上分支时 Beta 下版本号【1.101.1.0】）， 此处允许保留搁置集开发的方式，但必须是测试通过才能发行 ； 开发迭代，过程中版本号带后缀【1.101.1.0-Task ID-alphaN】； 开发过程，最终测试版本需要将 Beta 下最新代码合并到 Dev，并解决冲突发出测试版本； 测试验收通过后，代码合并到 Beta，同时删除 Dev 下代码； 评估修改范围，按版本号规则确定版本号（假设本次修改确定版本号【1.200.0.0】）； 编译正式版插件包，版本号为【1.200.0.0】； 给 Beta 下本次提交的变更集打 Tag【插件名-1.200.0.0】； 合并功能到 Beta 目录下其它集成项目分支。 3.2.3 修复 Bug 确定反馈软件对应的插件版本，如果使用的是 Beta 分支下最新版本（如：【1.200.0.0】），在 Beta 下修复； 如果使用的旧版本插件（假设使用的插件版本号【1.101.0.0】）；找到 Beta 下【插件名-1.101.0.0】的 Tag，在 Fix 目录创建分支【插件名-1.101】； 在 Fix 下修复 bug，搁置集方式开发； 测试验收通过后，发出版本号为【1.101.0.1】的插件包； 合并功能到 Main 下正式发行的集成项目分支；Beta 下也存在问题，则 Beta 分支也需要修改。 3.3 抢版本号问题 多人合作开发一个 Task：统一规划工作，由主导人负责管理分支、代码合并、确定版本号； 多人同时分别做多个 Task：确定 Task 交付节奏，统一规划版本后当做一个（都是兼容修改）或两个（有不兼容修改）大 Task 开发，参考第一条； 多人同时修复多个 Bug：参考2； 厂商定制问题：某厂商提出的新需求，初步评估为通用功能，但是现场要得很急。这种情况考虑插件开一个定制版本，先解决这一家客户的问题，做完后也不合其它集成项目，之后再详细评估此功能是否纳入主分支和如何做到主分支的问题。 修改记录 序 号 版本 修订 人 日期 描述 1 R0.1 陈百 旺 2021/06/30 初始草案 2 R1 唐涛 2021/07/02 1. 修改分支管理示意图 2. 修改 Fix 目录分支规则 3. 增加 Beta 、Fix 下分支的搁置集开发方式 4. 3.2.3 Bug 处理流程修改 5. 增加插件包路径 3 R2 唐涛 2021-8-31 1. 插件版本号 f.f 改为 f.r 定义 Beta/Release 分支下插件包修复 bug 修改的字段 评审记录"
  },
  "doc/研发管理制度规范/方案设计汇报和评审指导书/方案设计汇报和评审指导书-R1.html": {
    "href": "doc/研发管理制度规范/方案设计汇报和评审指导书/方案设计汇报和评审指导书-R1.html",
    "title": "方案设计汇报和评审指导书",
    "keywords": "方案设计汇报和评审指导书 版次：2022年01月23日 第1版 类型：技术文件 部门：软件部 上层文件：方案设计汇报和评审流程 上海维宏电子科技股份有限公司 版权所有 文件版本 修改前文件版本 主要修订内容和原因 修订人 修订日期 R1 新增 肖诗瑜 2022/01/23 1 目的 本文档主要用于指导研发体系人员如何进行方案设计汇报及评审。 2 适用范围 适用于软件平台以及产品线各团队。 3 术语及定义 JIRA：即内网Jira系统。 路径： http://jira.weihong.com 4 方案设计汇报 内网JIRA进行汇报。 项目选择：软件部 点击新建创建问题： 问题类型：方案设计汇报和评审 概要：方案名称 描述：请附带具体方案设计说明书路径。 优先级： P1：最高。汇报并申请评审。 P2：高。 P3：中。 P4：低。单纯汇报。 点击新建完成汇报 5 方案设计评审 研发助理收到 P1 级的方案汇报，则需在一个工作日内完成确定方案评审会议的准备工作：组织评审日期、地点、参加人员。 专家委员会可通过 JIRA 查看汇报的方案设计，若是发现需要评审，需告知研发助理。 由研发助理在一个工作日内完成方案评审会议的准备工作。 编制：肖诗瑜 审核： 批准： 审批链接："
  },
  "doc/研发管理制度规范/方案设计汇报和评审流程/方案设计汇报和评审流程-R1.html": {
    "href": "doc/研发管理制度规范/方案设计汇报和评审流程/方案设计汇报和评审流程-R1.html",
    "title": "方案设计汇报和评审流程",
    "keywords": "方案设计汇报和评审流程 版次：2022年01月21日 第1版 类型：程序文件 部门：软件部 上海维宏电子科技股份有限公司 版权所有 文件版本 修改前文件版本 主要修订内容和原因 修订人 修订日期 R1 新建 胡凯烽 2022.01.21 1 目的 建立技术方案汇报机制，通过评审，检验研发设计工作是否规范，技术产出是否达到规定的技术要求和质量要求。 2 适用范围 适用于软件平台以及产品线各团队。 限定为软件的重要方案以及重大 BUG 的解决方案： 所有通用性方案设计和规格变更，其范围包括但不限于界面设计、技术框架、数控功能、缺陷改进； 对产品具有重大影响的方案设计和改进； 开发任务大于 30 人日的软件功能。 3 职责 3.1 架构 方案的设计； 汇报技术方案。 3.2 专家委员会 评审方案设计。 3.3 软件部 组织评审； 追踪方案的上报、评审和执行情况，并发布方案追踪报告。 4 流程 4.1 方案汇报 各团队架构需按照软件部指定方式汇报相关方案设计。 4.2 方案评审 由专家委员会及软件部共同负责： 当遇到紧急且关键任务，架构在汇报方案的同时，应向研发助理提出评审请求，由研发助理和专家委员会确认评审事项并组织会议 评审通过，流程结束； 评审不通过，方案上报人应立即调整方案，并重新汇报。 专家委员会对汇报的方案进行审核后，如发现有问题或产生异议，向研发助理提出评审请求，由研发助理和专家委员会确认评审事项并组织会议 评审通过，流程结束； 评审不通过，方案上报人应立即调整方案，并重新汇报。 评审应于 2 个工作日内完成，请勿影响开发速度。 研发助理每周追踪技术方案的上报、评审和执行情况，每月发布技术方案追踪报告。 编制： 审核： 批准："
  },
  "doc/研发管理制度规范/测试管理规范/~作废文件/软件测试流程&过程规范-R2.html": {
    "href": "doc/研发管理制度规范/测试管理规范/~作废文件/软件测试流程&过程规范-R2.html",
    "title": "软件测试流程&过程规范",
    "keywords": "软件测试流程&过程规范 版次：2018年12月23日 第2版 文件类型：程序文件 上海维宏电子科技股份有限公司 版权所有 修改历史 文件版本 修改前文件版本 主要修订内容和原因 修订人 修订日期 R1 新建 汪腾霞 2017.07.10 R2 R1 1）加入测试任务提前审核的相关要求； 2）准入、准出准则直接放在各活动后面，冒烟测试准出单独定义； 3） 对部分要求过细的规则，进行修调，以便更合理实施。 4） 增加“通用测试制定原则”章节。 汪腾霞 2018.12.23 1 引言 1.1 编写目的 测试作为公司产品开发的重要环节，明确的测试过程、规范的测试行为，可以提高软件开发工作的质量和效率。 1.2 读者对象 软件部对接的业务线或软件平台的测试团队。 2 术语/定义 为了统一认识，此处给出公司内部关于测试过程中的相关术语的定义。 编号 名称 定义 1 测试流程 从接收任务到任务测试结束经历的一系列有序的测试活动，即为测试流程。包括测试需求分析&计划、测试设计、测试准备、测试执行、测试评估、测试结束，部分活动可能会交替、反复。 2 测试执行阶段 指在成型的产品上，按一定的输入/操作要求进行执行，以比对实际结果与预期结果是否一致的过程。 3 输入 开展特定测试活动需要的程序、文档、数据、软件、硬件。 4 输出 某一测试活动结束需提供的产出。 5 输入准则 测试活动的输入，需满足的条件。 6 输出准则 标记特定测试活动完成的条件。 7 测试点 根据测试范围以相对抽象的形式描述测试思路和预期。不要求提供详细的操作步骤或操作细节。常用Excel表格的形式编制。 8 测试用例 如果说测试点比较抽象，那测试用例就明确规定了测试的前提条件、操作步骤、输入数据以及预期结果。不同的人根据同一测试用例执行结果应该能达到80%的相同效果。 9 测试执行记录 测试用例/测试点在实际的软件上执行的结果记录。 10 测试版软件 即为开发编码完成后直接在本开发机上发行的Release版软件。 11 发布版软件 即为从发行库中Get代码，在指定发行机上发行的Release版软件。 12 通用测试 即软件中常用/基本业务功能的正向操作测试，或典型异常操作测试，通常外发类软件版本都需要进行此项测试。 3 测试流程 3.1 流程图 3.2 过程详解 编号 过程名 描述 负责人 审核人 备注 1 测试需求分析&计划 1. 结合开发需求分析和原始用户需求，进行测试需求分析。 2. 分析中可咨询包括但不限于：开发负责人、测试组长、需求提出人。 3. 主要从时间、熟练度、任务量、设备等方面进行测试计划，并进行适当的风险预估。 4. 测试计划输出内容至少包括： 测试需求、工期、人员安排及输出要求 等。呈现形式不定，可在工作项历史记录中。 测试工程师 测试组长 开发负责人 测试需求分析见《软件测试需求分解指导书-R1.doc》 2 测试设计 1. 根据测试范围进行测试点编写/测试用例设计。 2. 完成后 提交开发负责人确认，测试组长评审。 3. 须注意 用例的可复用性 。 测试工程师 测试组长 开发负责人 详见《软件测试用例设计指导书-R1.doc》 3 测试准备 1. 根据测试计划搭建测试环境，尽可能模拟真实工作环境。 2. 对开发提交的待测软件进行冒烟测试。 测试工程师 4 测试执行 1. 确保充分理解测试用例。 2. 一般优先执行本次维护功能、基本场景的测试用例。 3. 各业务线，一般要求在测试版软件测试执行通过后，再做发布版软件的测试执行。 4. 所有bug一律通过TFS中Bug工作项进行跟踪。 测试工程师 - Bug提交跟踪详见《缺陷跟踪流程-R1 .doc》 5 测试评估 1. 发布版测试通过即提交评审。 2. 评审包括但不限于： 用例执行完整性、缺陷处理合理性、测试记录规范性 。 3. 评审不通过需修订后再次评审。 测试组长 - 6 测试结束 1. 评估通过，则测试任务完成。 2. 归档本次测试相关资料，以便后续查证或使用。 3. 对测试环境进行检查和必要复位。 测试工程师 - 归档材料及路径祥见表格2 文档及路径 表格1 测试过程释义 编号 材料名称 路径 备注 1 测试刀路 \\172.16.10.123\\01.安全内网文件夹\\01.研发部文件\\02.受限文件\\01.软件部\\03.测试\\03.刀路文件 测试过程中使用的刀路文件，如客户刀路、特殊刀路等； 2 软件密码/关键字 \\172.16.10.116\\TestManager\\TCM\\Doc Manager\\CMD&Func Doc（TFS） 1. 执行操作需输入的密码（常用的制造商密码：64038574、33587550、weihong、NcStudio）； 2. 软件操作中需使用的关键字，如仿真软件（homecomputer）。 表格2 文档及路径 4 测试过程规范细则 4.1 测试需求分析&计划 ² 输入 ：TFS工作项、用户/开发需求分析（/+产品规格书、/+概要设计说明），及相关文档说明。 ² 输出 ：测试说明书/测试计划。 ² 输出准则： 1） 项目类型的测试任务，需提供测试方案/测试计划，可参见《测试说明书-模板.dot》or《测试计划表.xlt》。 4.2 测试设计 ² 输入 ：测试需求、测试计划及相关文档说明。 ² 输出 ：测试用例/测试点。 ² 输出准则： 1） 本次新增功能，需提供可复用测试用例。 2） 已存在可复用测试用例的功能变更后，需维护已存的测试用例。 3） 测试用例/测试点由指定测试审核人审核并通过。 4.3 测试准备 ² 输入 ：测试计划、开发提交的待测软件、冒烟测试用例。 ² 输出 ：物理的测试环境、可接受测试版软件。 ² 输出准则： 1） 待测版软件冒烟测试不通过则退回（具体见“5.冒烟测试准则”）。 2） 出现测试退回时，在工作项中留下对应的“退回记录”。 3） 出现2次及以上退回的，上报测试组长。 4.4 测试执行 ² 输入 ：测试计划、测试用例、可供测试执行的软件。 ² 输出 ：测试执行记录、TFS Bug工作项。 ² 输出准则： 1） 发布版软件测试，追加《通用测试》执行（具体见“6. 通用测试制定原则”）。 2） 所有缺陷按“一个Bug一个工作项”的原则提交到TFS服务器。 3） 每完成一次测试执行，在工作项中均对应有“测试情况说明”。具体内容参见《工作项测试记录（模板）.txt》。 4） 对自己提交的Bug，定期跟踪直到Bug关闭。 5） 整个任务测试执行结束，提交《测试执行记录表》等待审核，除非任务项指派时有备注说明。 4.5 测试评估 ² 输入 ：测试执行记录、缺陷记录、测试通过的软件。 ² 输出 ：审核记录（填写在TFS工作项中）。 ² 输出准则： 1） 每个任务工作项均指定测试审核人（审核内容包括但不限于测试用例、工作项填写、相关Bug的处理）。 2） 审核结束，在工作项中提交“审核记录”。具体内容参见《审核记录（模板）.txt》。 3） 审核不通过，需修订后再次提交审核，直到通过。 4.6 测试结束 ² 输入 ：测试执行记录。 ² 输出 ：外发版软件、可复用测试用例。 ² 输出准则： 1） 计划用例100%测试执行完成。 2） 已解决Bug均回归测试并通过。 3） 若需借助客户现场环境完成测试的，需产品经理同意，并在TFS中留下记录。 4） 遗留Bug的处理经测试组长、总工或经理评审并同意。 5） 可复用测试用例符合《软件测试用例设计指导书.doc》。 6） 可复用测试用例或共享步骤已提交至服务器指定位置： \\172.16.10.123\\01.安全内网文件夹\\01.研发部文件\\02.受限文件\\01.软件部\\03.测试\\08.测试指南 下的各组文件夹下。 7） 项目类型的测试任务，提交测试总结报告。参见《测试总结报告(XXX)-模板-Rn.dot》。 8） 测试中存在的其他资料如典型刀路、测试工具、新增或变动的操作口令的，已完成归档（各组指定的服务器位置）。 5 冒烟测试准则 此处主要规定测试在接收测试版和发布版软件时，冒烟测试的准入、准出准则。各测试团队可以在不违背本准则的前提下，细化本团队的冒烟测试准则。 5.1 测试版 \\1) 准入准则：开发已完成自测并提交自测记录到工作项（自测记录的形式视组内要求而定）。 \\2) 准出准则：功能正常实现的关键参数、端口配置符合需求。 \\3) 准出准则：功能基本流程实现符合需求。 \\4) 准出准则：冒烟测试过程中，未发现Block性或重大隐患Bug比如崩溃、卡死。 \\5) 符合组内制定的其他基本准则。 5.2 发布版 \\1) 准入准则：在指定发行机上发行的Release版本（以保证源码正确合并发行库）。 \\2) 符合测试版准则。 6 通用测试制定原则 各测试团队需结合本团队测试对象或测试项目的特点，参照《软件通用必测项-Rn》，制定适合本团队的《通用测试》要求。 《通用测试》制定原则如下： \\1) 以客户视角，也即从操作应用的角度制定通用测试范围和通过标准。 \\2) 需考虑对客户目标正常实现有重大影响的、核心功能的正向操作和典型异常操作。 \\3) 需考虑客户目标正常实现过程中，必定使用功能的正向操作和典型异常操作。 \\4) 需考虑客户目标正常实现过程中，频繁使用功能的正向操作。 \\5) 需考虑近期维护的通用Bug或通用需求。 \\6) 需考虑通用测试执行时长，原则上无配置区分的软件控制在30-60分钟之内，多配置软件控制在90分钟之内。 \\7) 原则上需对测试项按主次划分优先级（在紧急情况下便于筛选）。 \\8) 《通用测试》需根据团队情况进行适时更新，原则上一个季度做一次更新检查。 7 附录 1） 测试用例库的位置为：172.16.10.116\\TestManager\\TCM。 2） 本文档见： \\172.16.10.123\\01.安全内网文件夹\\01.研发部文件\\02.受限文件\\01.软件部\\03.测试\\00.组内管理\\01.制度&要求 。（内网访问） 3） 测试文档模板： \\172.16.10.123\\01.安全内网文件夹\\01.研发部文件\\02.受限文件\\01.软件部\\03.测试\\00.组内管理\\00.测试专用模板 。（内网访问）【建议按给定模板样式使用，自制模板时，包含的内容项不得少于给定的模板】 4） 测试指导书见： \\172.16.10.123\\01.安全内网文件夹\\01.研发部文件\\02.受限文件\\01.软件部\\03.测试\\00.组内管理\\03.测试指导书 。（内网访问） 编制： 汪腾霞 审核：张艳丽"
  },
  "doc/研发管理制度规范/测试管理规范/RobotFramework自动化测试框架使用指导书-R1.html": {
    "href": "doc/研发管理制度规范/测试管理规范/RobotFramework自动化测试框架使用指导书-R1.html",
    "title": "RobotFramework 自动化测试框架使用指导书",
    "keywords": "RobotFramework 自动化测试框架使用指导书 版次：2021年12月27日 第1版 类型：技术文件 部门：软件部 上层文件: 软件测试规范 上海维宏电子科技股份有限公司 版权所有 文件版本 修改前文件版本 主要修订内容和原因 修订人 修订日期 R1 余晓霞 2022/1/5 1 目的和范围 本指导书就使用 RobotFramework 自动化框架实施自动化测试提供指导。 2 RobotFramework 介绍 2.1 自动化测试介绍 自动化测试是相对于手工测试而存在的，主要是通过所开发的软件测试工具、脚本等来实现模拟手工操作。具有良好的可操作行、可重复性和高效性等特点。自动化测试是软件测试中提高测试效率、覆盖率和可靠性的重要测试手段。 2.2 RobotFramework 介绍 RobotFramework 是一个开源的，基于 Python 的，可扩展的关键字驱动的测试自动化框架，用于端到端验收测试和验收测试驱动开发（ATDD），在自动化测试领域被广泛应用。 3 自动化测试框架 3.1 自动化测试框架设计思想 自动化测试框架以统一的自动化工作模式、测试资产库的不断积累为设计思想。 统一的自动化工作模式 自动化测试框架本身固化了一套自动化脚本设计、自动化脚本开发、扩展开发和调度执行的模式和规范，保证了自动化测试实施技术和方法的一致性，降低了自动化测试对具体人员的依赖性，也在一定的程度上减少了因为人员经验技能的差异导致的自动化效果差异。 测试资产库不断积累 自动化测试框架注重自动化测试资产的积累、共享和复用。在自动化测试过程中产生的业务关键字、通用关键字、业务流、测试脚本、对象库、测试数据等资产进行有效的组织和存储，并在不同的测试中实现复用。 3.2 自动化测试框架逻辑架构 自动化测试框架逻辑架构如下图（1）所示： 图（1）说明： Robot Resources ：基于 RobotFramework 语法定义的关键字或资源 Python Resources ：使用 python 定义的关键字资源。 Custom Keyworks ：自定义的关键字，例如：业务通用关键字、工具类关键字、UI 操作关键字。 UI 对象库 ：存储 GUI 对象的 Xpath 信息； Stadard Library ：与 RobotFramework 一起分发的测试库，例如：BuiltIn、String、OperatingSystem 等。 WeihongLibrary ：根据公司产品特点定义的第三方类库。例如：FlaUILibrary，里面包含的功能有：GUI 的操作、Phoenix 软件的通信、Phoenix 软件日志的查询等。 3.3 自动化测试框架使用指导 3.3.1 自动化测试环境 开发语言：RobotFramework、Python； Python 版本：3.8.10 （32位）； RobotFramework 版本：3.2.2； 平台：Windows System； 环境部署操作指导见 wiki(内网)《环境部署》 3.3.2 自动化测试代码管理 自动化测试代码的目录结构如下所示： 自动化测试项目/ ├── action #用例的上层动作集合 │ ├── common #通用关键字 │ │ └── assert.robot #自定义断言关键字文件 │ │ ├── 多语言兼容.robot │ └── NcConfig # NcConfig 项目 │ ├── GUI #项目的页面维护慕课 │ ├──pages │ ├── 机床部件.robot #机床部件页面 │ ├── 打开配置窗口 #关键字 │ ├── 在组件配置窗口选择组件 #关键字 │ ├── 页面元素.robot # 页面控件元素 xpath 维护文件 │ └── Laser # 激光平面项目 │ ├── GUI #项目的页面维护模块 │ ├──pages │ ├── 启动.robot #激光应用程序启动 │ ├── 启动应用程序 #关键字 │ ├── 页面元素.robot # 页面控件元素 xpath 维护文件 │ ├── Phoenix #项目的 Phoenix 寻址或 API 接口维护模块 ├── application #测试框架运行相关的工具包 │ ├── TestServer.dll #被测软件通信包 │ ├── TestServer.toc #被测软件通信包 │ └── AutoTest.CIEngine.exe #自动化安装部署被测软件工具 ├── data #测试数据 │ ├── NcFiles #刀路文件 ├── docs #文件集合 │ ├── keyword.html #flaui 关键字说明文档 │ ├── readme.md #自动化项目说明文档 ├── utils # Python 定义的关键字或工具集合 │ ├── SQLLitePlugin.py #SQLLite 相关的关键字 │ ├── FileHandler.py #文件操作相关的关键字 │ ├── Register.py #被测软件注册工具 ├── testcase #测试用例 │ ├── 安装 #功能/功能模块 │ │ └── Test_安装_installer_UI.robot #用例套件文件，文件命名格式：Test_功能模块_功能[_其它].robot 中括号部分为可选项。 │ ├── 按默认选项安装软件 #测试用例 │ └── 回机械原点 #功能/功能模块 │ ├── Test_机床准备_回机械原点_API.robot #用例套件文件 │ ├── 绝对值模式且关闭辅助设定基准功能执行单轴回，检测回机械原点结束后位置是否正确 #测试用例 │ ├── 绝对值模式且关闭辅助设定基准功能执行单轴回，检测回机械原点的速度是否正确 #测试用例 │ ├── ... │ └── ... 说明： action ： 用例的上层动作集合，用于维护通用业务关键字、通用工具关键字或页面关键字。 application ：用于存放测试框架运行相关的工具包，例如与应用程序通信相关的 TestServer.dll，或部署自动化测试环境相关的 AutoTest.CIEngine.exe 等。 data ： 用于存放测试数据。例如刀路文件。 docs ：用于存放相关文档，例如关键字的说明文档，或其他文档。 testcase ：属于用例层，存放测试用例脚本文件。 utils ： python 定义的关键字或工具类 3.3.3 自动化测试用例执行流程 用例执行流程如下图（3）所示： 图（3） 用例内部执行流程如下图（4）所示： 图（4） 4 自动化测试用例组织指导 4.1 GUI 自动化测试范例 4.1.1 维护对象库 在应用程序（子项目）的 GUI 模块里维护对象库，例如：安装项目 UI 对象的 xpath 维护在 action\\Installer\\GUI\\页面元素.robot 文件文件中。如下所示： xpath 可通过 FlaUInspect.exe (不仅限于工具) 获取；工具可在 内外 wiki 下载。 *** Variables *** ######################选择安装语言 ${语言选择框} //ComboBox[@AutomationId='cbxLanguage'] \\| //ComboBox[@AutomationId='languageComboBox'] ${请选择安装时使用语言} //Text[@AutomationId='tbPrompt'] ${确定按钮} //Button[@AutomationId='btnOK'] ${取消按钮} //Button[@AutomationId='btnCancel'] ${安装程序_主页} /Window[contains(@Name,'安装程序 - NcStudio')] ${安装程序_语言选择页} /Window[contains(@Name,{0})] ${安装程序_语言选择页_提示语} ${安装程序_语言选择页}/Text[@AutomationId='tbPrompt'] ${安装程序_语言选择页_语言下拉列表} ${安装程序_语言选择页}/ComboBox[@AutomationId='languageComboBox'] ######################安装警告 ${安装程序_安装警告页} ${安装程序_主页}/Window[contains(@Name,'安装警告')] ${安装程序_安装警告页_提示文本框} ${安装程序_安装警告页}/Edit 4.1.2 维护页面控件操作的动作 把页面控件操作的动作定义在对应的页面动作文件里，每个页控件操作的动作，宜放在相同的一个 robot 文件里，不同页面控件操作的动作，宜放在其对应的单独页面里。例如：安装过程的选择语言页的页面动作，定义在 action\\Installer\\GUI\\pages \\选择语言页.robot 文件里。如下所示： *** Settings *** #robotframework 的设置模块，通常用于引入第三方库或资源等 Documentation 安装过程语言选择页的页面控件操作的动作定义 #文档说明，可用于说明此文件的适用范围或背景信息等 Library FlaUILibrary #引入 FlaUILibrary 库 Resource ../页面元素.robot #引入资源文件页面元素.robot *** Keywords *** #定义页面相关的关键字。无缩进的行是关键字名称（即函数名称），紧随其下缩进两个空格的行的集合为函数体 获取界面语言 #关键字名称 ${XPath_Chn}= 字符串格式化 ${安装程序_语言选择页} 安装 ${Exists_Chn}= Run Keyword And Return Status Element Should Exist ${XPath_Chn} ${IntfLang}= Set Variable If ${Exists_Chn} chn eng [Return] ${IntfLang} #返回值 选择语言 #关键字名称 [Documentation] ${SpecLang}：指定的语言 #文档说明标签，用于说明关键的描述或背景等信息，在执行日志文件中会被打印 [Arguments] ${SpecLang} # 传参定义 Select Combobox Item By Name ${安装程序_语言选择页_语言下拉列表} ${SpecLang} Press Key s'ENTER' 在语言选择对话框单击【确认】按钮 #关键字名称 click ${确定按钮} 选择语言并确定 #关键字名称 [Arguments] ${SpecLang} 选择语言 在语言选择对话框单击【确认】按钮 4.2.3 测试用例样例 测试用例文件是在 testcase 目录下维护，例如: 安装应用程序的测试套件 Test_安装_UI.robot 的部分脚本如下所示： *** Settings *** #设置模块，引入包和资源。设置测试准备和测试后环境清理 Library FlaUILibrary Resource ../common/allImports.robot Suite Setup 清理安装环境 *** Variables *** #变量模块 ${InstallConfig} 总线 ${AppName} ncstudio *** Test Cases *** #用例模块。无缩进的行为用例标题（即测试函数），紧随其下缩进两个空格的行的集合为测试步骤和预期结果集合 TC001_安装软件_验证按默认选项安装 #用例标题 [Tags] P1 冒烟 通用必测 测试类型=功能 #用例标签 ${datetime0} ToolsPlugin.get current time #测试步骤 启动安装应用程序 选择语言页.选择语言并确定 选择本地参数页.选择本地参数操作方式并确定 安装完成页.等待安装完成 #预期结果 验证应用程序文件修改时间大于等于 ${datetime0} 验证默认配置名称为 ${InstallConfig} *** Keywords *** # 关键字模块，可自定义关键字，此处定义的关键字，适用范围为当前文件 说明： Test_安装_UI.robot ： 是一个测试套件文件，包含有若干测试用例的集合文件。文件的命名格式为：文件命名格式：Test_[功能模块]_功能_[其它]，其中中括号“[ ]” 里的内容为可选项。 Setting 模块：是 RobotFramework 测试套件文件的设置模块，适用范围为此测试套件文件，例如：引入资源和第三方库、声明Setup或Teardown等； Variable 模块：是 RobotFramework 测试套件文件的变量声明模块，适用范围为此测试套件文件。 测试用例模块：*** Test Case *** 分隔线下的模块属于测试用例模块。用例标题格式和用例标签定义遵循《软件测试用例设计规范》 。 关键字模块：*** Keywords *** 分隔线下的模块属于关键字模块，此处定义的关键字使用范围为此测试套件文件。 4.2 API 自动化测试范例 测试用例样例如下： *** Variables *** #变量模块 ${phoenix_pre} Phoenix.G.Channels[${channel}] #定义变量并赋值 *** Test Case *** TC001_开关紧停端口（EStopOn）后检查软件的表现 #用例标题 [Tags] p1 通用必测 '开'逻辑端口'#.AutoInfo.EStopOn' #测试步骤 验证紧停后软件表现正确 #预期结果 最新'1'条Error日志中包含'${log01}'日志 #预期结果 '关'逻辑端口'#.AutoInfo.EStopOn' #测试步骤 验证退出紧停后软件表现正确 #预期结果 最新'10'条Information日志中包含'${log02}'日志 #预期结果 TC002_开关XYZ轴正向限位端口（PLimitOn）后检查软件表现 #用例标题 [Tags] p1 通用必测 FOR ${index} IN RANGE ${3} #测试步骤 ${_name} get phoenix ${phoenix_pre}.Axes[${index}].Name Log 开${_name}轴正限位 '开'逻辑端口'#.Limit[${index}].PLimitOn' #预期结果 等待'2s'直到是紧停状态 红灯应该亮 Sleep 1s ${ishome} get phoenix ${phoenix_pre}.Axes[${index}].IsHomed ${Enable} get phoenix ${phoenix_pre}.Axes[${index}].Enable ${AxisOn} get phoenix ${phoenix_pre}.Axes[${index}].AxisOn Should not be true ${ishome} ${_name}轴机械回原点标志应该被取消 Should not be true ${Enable} ${_name}轴使能没有断开 Should not be true ${AxisOn} ${_name}轴伺服使能没有断开 ${log01} Set Variable ${_name}正向限位报警 Wait Until Keyword Succeeds 5s 1s 最新'1'条Error日志中包含'${log01}'日志 #测试步骤 Log 关${_name}轴正限位 '关'逻辑端口'#.Limit[${index}].PLimitOn' 等待'2s'直到是空闲状态 等待'2s'直到黄灯应该亮 Sleep 2s ${ishome} get phoenix ${phoenix_pre}.Axes[${index}].IsHomed ${Enable} get phoenix ${phoenix_pre}.Axes[${index}].Enable ${AxisOn} get phoenix ${phoenix_pre}.Axes[${index}].AxisOn #预期结果 Should be true ${ishome} ${_name}轴机械回原点标志应该恢复 Should be true ${Enable} ${_name}轴使能断开 Should be true ${AxisOn} ${_name}轴伺服使能断开 ${log11} Set Variable ${_name}轴位置调整成功 #最新'10'条Information日志中包含'${log11}'日志 ${log02} Set Variable 退出${_name}正向限位报警 Wait Until Keyword Succeeds 5s 1s 最新'10'条Information日志中包含'${log02}'日志 END 4.3 数据驱动测试范例 4.3.1 定义测试模板 测试模板是在需要使用不同的输入或输出数据来测试相同的场景时而产生的，其运行机制支持使用同一个测试模板自动遍历测试不同的数据。 在关键字模块里定义模板，模板的定义方式和关键字的定义方式相同，如下所示： *** Keywords *** #关键字模块 导入不同格式的文件 #关键字名称，类易于我们常说的函数 [Arguments] ${filename} ${unit} ${except_complete_time} #传参 [Timeout] 10 minutes #超时设置，若执行时长超过10分钟，则超时退出 #操作步骤 导入文件 ${filename} ${unit} ${except_complete_time} 验证文件导入(打开)成功 ${filename} sleep 1s ${Warning0} 最新'1'条Warning日志 ${Error0} 最新'1'条Error日志 保存文件 savefile.ncex sleep 1s 文件应该被保存成功 savefile.ncex ${Warning1} 最新'1'条Warning日志 ${Error1} 最新'1'条Error日志 #断言检查 should be equal ${Warning0} ${Warning1} 保存过程中出现告警日志${Warning1} should be equal ${Error0} ${Error1} 保存过程中出现错误日志${Error1} sleep 2s 4.3.2 数据驱动测试用例样例 *** Test Cases *** TC001_验证导入不同格式文件功能正确 #用例标签 [Tags] p2 通用必测 [Template] 导入不同格式的文件 #引用测试模板 [Timeout] 10 minutes #以下是测试数据 #加工文件名称 文件单位 预计导入完成所需时间（s） 5层2.dxf 英制单位 2 20210624001.lxd 公制单位 5 JSY250-2D020103-3保险耳板.dwg 公制单位 3 飞行切割.nc 使用文件单位 2 1.65mm201不锈钢切割发送.dxf 公制单位 10 鸿基.plt 公制单位 5 5 工具介绍 5.1 集成开发工具 - RobotFramework-ride RobotFramework-ride 是 RobotFramework 提供的集成开发工具，属于开源项目，可使用 ride 编写测试用例和执行测试用例，其中编写用例提供了 GUI 页面编写和文本模式编写两种方式。优点支持关键字自动补全和语法检测、执行用例、新手入门快等，缺点是没有集成版本管理工具（例如： git 、TFS 等）和不适用 Python 的开发和调试。 对于 RobotFramework-ride 的使用手册可在 wiki (内网) 《测试工具集》 获取。网上也有很多关于 ride 的使用指导，这里不再对其的使用指导做介绍。 5.2 集成开发工具 - PyCharm PyCharm 是 Python 的集成开发环境。PyCharm 安装包，及支持 RobotFramework 用例的执行的插件 intelllibot.jar 的安装指导，可在 wiki（内网）《测试工具集》 获取。 6 执行测试 6.1 命令行执行 在命令执行 RobotFramework 测试用例，可使用 robot 命令。如下只对其常用的命令做说明，其它命令选项说明可使用帮助命令“ robot -h ”查看。 执行一个用例 robot -t \"测试用例名称\" 测试套件文件.robot 按用例文件执行 robot 测试套件文件.robot 执行目录下的所有用例 robot 测试套件文件目录 按 tag 执行用例 robot -i P1ANDSmoking -e SkipORLS3000 测试套件文件目录 -i : 表示包含； -e：表示排除； AND：表示逻辑与关系； OR：表示逻辑或关系； 命令意思是：执行同时包含P1和Smoking标签的用例，并且排除包含有Skip或Ls3000的标签的用例。标签的值大小写敏感。 变量参数 robot --variable env:仿真 --variable install_package_name:Setup-Gen-NC60A-15.550.14.1_Beta.exe 测试套件文件目录 2.2 CI 执行 CI 是基于 Jenkins 实现的。Jenkins 地址： http://172.16.10.40:8080/；使用域账号登录。操作步骤如下： 1、在任务（job）列表单击任务名称，进入任务详情页； 2、单击左侧导航栏的【Build whith parameters】，右侧展示构建参数信息 3、录入构建参数信息，单击【开始构建】按钮，若执行机空闲，则立即开始执行自动化测试，否则等待到执行机空闲之后才开始执行自动化测试。 5、构建结果或其他信息可通过构建详情页查看，如下图（5）所示。 图（5） 经验谈 ： 当想查看构建过程日志时，在构建详情页通过右侧的菜单按钮【控制台输出】查看构建过程日志，控制台输出功能提供构建过程日志的实时输出。 7 查看日志和测试报告 RobotFramework 提供有 html 页面查看执行日志（log.html）和测试报告(report.html)。 图（6）测试报告 编制：余晓霞 审核： 批准： 审批链接："
  },
  "doc/研发管理制度规范/测试管理规范/手工测试用例编写指导书-基于RobotFramework框架-R1.html": {
    "href": "doc/研发管理制度规范/测试管理规范/手工测试用例编写指导书-基于RobotFramework框架-R1.html",
    "title": "手工测试用例编写指导书-基于 RobotFramework 框架",
    "keywords": "手工测试用例编写指导书-基于 RobotFramework 框架 版次：2021年12月27日 第1版 类型：技术文件 部门：软件部 上层文件: 软件测试规范 上海维宏电子科技股份有限公司 版权所有 文件版本 修改前文件版本 主要修订内容和原因 修订人 修订日期 R1 余晓霞 2021/12/27 1 目的和范围 在基于代码方式管理测试用例的背景下，本指导书用于给软件测试人员提供基于 RobotFramework 框架如何编写手工测试用例的指导。 背景：公司软件产品的特性是相对长期稳定、可重复使用和多版本共存，因此测试用例和源码一样也属于公司宝贵的资产。随着业务的发展，软件版本越来越多，为了适应软件多版本，及时响应业务需求，简化测试用例的管理，提出了“使用代码方式管理测试用例”的思想，让测试用例和代码一样使用版本管理。此思想的提出也有利于强化手工测试人员对自动化测试的认知和使用，进而提升手工测试人员的编程素质，和强化测试人员对软件版本管理的认知。 2 RobotFramework 编写手工测试用例规范 RobotFramework 介绍应该参考《 RobotFramework 自动化测试框架使用指导书》，或网上查阅，此处不再做重复介绍。 基于 RobotFramework 框架编写手工测试用例的基础语法和 RobotFramework 的基础语法（ 可参考 RobotFramework 用户手册-基础语法（外网） ）保持一致。用例的组织依赖预定义的关键字，例如：do（测试步骤）、assert（预期结果）、prepare （前置条件）、data（测试数据）。执行测试用例集合的创建需要借助命令行导出工具，把用例集导出为 Excel 文件。 2.1 测试套件规范 测试套件是一组测试用例的无序集合，一般来说，这组测试用例是相关的，放在一起便于管理，也称为测试用例集，是对测试用例进行组织和分组的实例。测试用例存在于后缀为 .robot 的用例文件中，这些文件又可以组织在文件夹中，这些文件夹就是更高层次的测试用例集。文件夹类型的测试套件不直接包含用例, 仅包含用例文件集。整个这些文件和文件夹组成了测试套件的层次结构，如下所示。 用例管理项目_demo/ ├── 产品I部 │ ├── HPCS # 功能套件文件夹 │ │ └── Test_HPCS.robot # 测试套件文件 │ │ ├── TC001_参数生效表现验证_开启高光精度轮廓光顺功能 # 测试用例 │ │ ├── TC002_参数生效表现验证_HPCS等级 # 测试用例 │ │ └── TC003_参数组合场景 │ │ └── Test_HPCS_效果对比图FSS.robot # 测试套件文件 │ │ ├── TC001_参数63100开启高精度轮廓光顺是否有效 # 测试用例 │ │ ├── TC002_HPCS等级设置是否有效 │ ├── 机械回原点 # 功能套件文件夹 │ │ └── Test_机械回原点.robot # 测试套件文件 │ │ ├── TC001_参数设置基本操作及生效性验证_正向 # 测试用例 │ │ ├── TC002_参数设置基本操作及生效性验证_反向 │ │ └── TC003_Z轴回机械原点流程正确 │ ├── 共享用例 │ ├── 参数.robot # 参数共享步骤 │ │ └── 检查参数名称 # 共享步骤 │ │ ├── 检查参数默认值 # 共享步骤 │ │ ├── 检查参数单位 │ │ ├── 检查参数描述 │ │ ├── 检查参数设置权限（同时验证制作商可以使用操作员权限）_正向 │ │ ├── 检查参数设置权限为制造商时，在参数列表操作员无权查看参数_反向 测试套件的层次结构和功能名应该参考软件需求规格说明书。 文件的命名必须以“Test_功能名” 开头，命名格式：Test_功能名_*（*代表：序号 、接口名 、子功能名），其中\"*\"为可选项，也可留空，根据实际情况决定。 2.2 测试用例规范 测试用例是测试执行集合的最小单元，必须遵循上层文件《软件测试规范》。如下范例所示： *** Test Cases *** TC001_参数生效表现验证_开启高精度轮廓光顺功能 #用例标题 [Tags] P1 Auto 测试类型=功能 机型=10轴链式刀库、10轴圆盘刀库 #标签 prepare 全部Z轴有效 未回机械原点 速度参数和其它HPCS参数均为默认值 #前置条件 do 参数“开启高精度轮廓光顺功能”设置为是 #测试步骤 do 载入刀路文件(刀路文件中的路径角度必须包含有大于、小于和等于控制角度的角度) do 查看轨迹视图的轨迹变化 assert 当刀路中路径角度大于控制角度时则进行光顺处理 #预期结果 assert 当刀路中路径角度等于控制角度时则不进行光顺处理 assert 当刀路中路径角度小于控制角度时则不进行光顺处理 示例说明： “*** Test Cases ***” 表示此模块属于用例模块 用例标题：TC001_参数生效表现验证_开启高精度轮廓光顺功能。用例标题独占一行，顶格录入，禁止有缩进。 [Tags] 是 RobotFramework 的标签模块。P1：表示优先级；Auto：表示已实现自动化；“测试类型=功能” 表示测试类型为功能的标签；“机型=10轴链式刀库、10轴圆盘刀库” 表示机型的标签，此用例适用10轴链式刀库、10轴圆盘刀库机型。另外，若所有用例存在相同的标签时，可把相同的标签抽取出来，放在 RobotFramework Settings 模块的 “FORCE TAGS” 标签了。 prepare 标识此行为前置条件。多个前置条件以两个或两个以上的空格分隔， 一个用例仅有一个prepare 。 do 标识此为测试步骤。一个 do 代表一个测试步骤，测试步骤描述和“do”之间至少间隔两个或两个以上的空格。 assert 标识此为预期结果。一个 assert 代表一个预期结果，预期结果描述和“assert”之间至少间隔两个或两个以上的空格。 2.3 测试数据规范 测试数据维护方式如下： 文件方式维护： 测试数据文件存放在用例的 data 目录下。大文件应该存放在指定的文件服务器。 当数据属于文件类型时，若存放在文件服务器，则测试数据填写绝对路径。若存放在用例的 data 目录，则测试数据填写相对路径或文件名。 表格方式维护，如下范例： *** Test Cases *** TC004_检查大文件加工软件表现 #用例标题 [Documentation] 主要用于HPCS 对大文件加工的性能测试 #用例描述信息 [Tags] P3 测试类型=性能 #标签 [Template] 测试模板_检查大文件加工软件表现的场景 #引用测试模板“测试模板_检查大文件加工软件表现的场景” #加工文件 预计加工完成时间 0.2.nc 500min #测试数据表 prc.g 200min *** Keywords *** 测试模板_检查大文件加工软件表现的场景 #测试模板 [Arguments] ${加工文件} ${预计加工完成时间} #模板传参 do 设置开启高精度轮廓光顺的值为：是 do 设置HPCS保持角度的值为:默认值 do 设置HPCS控制误差的值为:默认值 do 设置HPCS区域半径的值为:默认值 do 设置HPCS细分长度的值为:默认值 do 设置HPCS等级的值为：3 do 载入刀路文件 ${加工文件} do 执行模拟加工 assert 等待${预计加工完成时间}直到加工结束 do 记录轨迹视图的轨迹图 assert 检查记录轨迹视图的轨迹图正确 > 示例说明： > > 1、范例使用了 RobotFramework 数据驱动测试的用例编写方式。 > > 2、[Template] 引入模板，“测试模板_检查大文件加工软件表现的场景” 为测试模板名称。 > > 3、测试模板为自定义的关键字，定义在RF的关键字模块里（文件的“*\\*\\* Keywords ***”分隔下的模块属于 RobotFramework 的关键字模块 ）。 > > 4、“#加工文件 预计加工完成时间 ” 为数据表的表头列。 > > 5、使用命令行导出工具导出 excel 后，定义在模板的前置条件、步骤和预期结果会被导出，测试数据以一张新的 sheet 表格来存储。 > **模板说明**：模板是在需要使用不同的输入或输出数据来测试相同的场景时而产生的。其运行机制支持使用同一个模板自动遍历测试不同的数据。通常其试用范围为当前测试套件。 3. 文本格式维护，如下范例： ```python *** Test Cases *** TC001_软限位功能检测有效性（基本流1） [Tags] P1 测试类型=功能 do 设置各个轴的行程范围：X（0 400） do 设置X、Y、Z轴工件偏置为50 50 -20 do 已回机械原点 do 检查工作台行程范围是否有效：是 do 载入 @G代码 执行开始加工操作，查看软件表现。 data @G代码： #测试数据 ... G00 X10 Z-5 ... G01 X30 ... X50 ... X500 assert 当X轴机械坐标到达400后继续往正向运动时，状态为锁定，界面显示的值为400，软限位X，弹出黄色提示信息“软限位，X轴超过工作台行程范围” assert 靠近限位边界5mm左右时有一个减速的过程，是为了防止机床抖动； assert 提示信息显示约3S后自动消失； do 限位后通过 @方式 控制轴往非限位方向运动 data 加工（范围在行程范围内） 手动 手轮 #测试数据 assert 控制的轴可以往非限位方向运动 范例说明： 1、data 标识此为测试测试数据。测试数据和“data”之间至少间隔两个或两个以上的空格。 2、多个测试数据需要分行编辑时，换行后使用“... ” ，如下所示，注意：当在 robotframework-ride 环境开发用例时，“... ” 会被自动转换成两个空格代替。 data 文件A： ... G00 X10 Z-5 ... G01 X30 ... X50 ... X500 3、多个测试数据不需要分行编辑时，可使用一个空格、逗号或分号进行分割，如：data 加工（范围在行程范围内）手动 手轮 4、data里的测试数据使用命令行导出工具导出 excel 后，在测试数据列的单元格会根据分隔符进行自动化换行后展示。 2.4 共享步骤规范 1、共享步骤放在“共享用例”目录下的文件。测试用例主体的组织方式和测试用例一样。 示例： *** Keywords *** #关键字模块 检查参数名称 #共享步骤名称 [Arguments] ${参数名称} do 检查参数名称 ${参数名称} #测试步骤 asser 参数名称等于${参数名称} #预期结果 检查参数默认值 [Arguments] ${参数默认值} do 检查参数默认值 ${参数默认值} asser 参数默认值等于${参数默认值} 2、引用共享步骤，以“call” 作为关键字，对共享步骤进行关联。如下示例： call 检查参数名称 ${参数名称} #关联共享步骤“检查参数名称”，“${参数名称}”为传参 call 检查参数默认值 ${参数默认值} 3 快速入手操作指南 3.1 从 Git 分支上拉取最新的测试用例 测试用例管理的 demo 项目地址为： http://tfs.weihong.com:8080/tfs/SPI/_git/Demo_Project?path=%2F Git 操作指导可查看 wiki (内网) Git 指南 3.2 创建测试套件 按测试套件规范创建文件夹或文件。例如新增一个断点继续功能，则新增一个名为Test_加工_断点继续.robot的文件。如下所示： 测试用例管理项目Demo/ ├── 产品I部 │ ├── 加工 # 功能套件文件夹 │ │ └── Test_加工_断点继续.robot # 测试套件文件 3.3 创建测试用例 1、打开用例文件添加用例模块标识，如下所示。在有些IDE工具（例如：RobotFramework-ride 、Pycharm 等）里新增 robot 文件，会自动添加此标识，不需要手工添加。 *** Test Cases *** 2、在“*** Test Cases ***” 标识的模块下开始添加用例，如下所示。 *** Test Cases *** TC001_检查断点继续功能基本流 #用例标题 [Tags] P1 测试类型=功能 #标签 prepare 不启用断点继续穿孔 #前置条件 do 导入加工文件 test02.ncex #测试步骤 do 启动加工 #测试步骤 do 等待激光开 do 停止加工 do 等待系统状态为空闲 do 在控制栏操作断点继续 assert 系统状态为运行 #预期结果 assert 绿灯亮 assert 加工开始位置为断点位置 TC002_检查暂停状态不可执行断点继续功能 #用例标题 [Tags] P2 测试类型=功能 #标签 prepare 系统状态为暂停状态 do 在控制栏操作断点继续 assert 系统状态为暂停 assert 提示语：当前状态不可执行断点继续 3、把新增或完善后的用例保存，并提交推送到 Git 。 3.4 更新测试用例 先拉取最新的用例，然后在本地更新用例后，再提交并推送到 Git 。更新用例时必须遵循《软件测试规范》的测试用例管理规范。 4 工具介绍 4.1 用例开发工具 初学者推荐使用 RobotFramework-ride 作为用例开发集成工具，因为 RobotFramework-ride 提供友好的GUI页面，引导使用者编写用例和执行用例，并且提供树形目录结构让用例的目录层次结构更清晰，其具体使用指南可参考《RobotFramework 自动化测试框架使用指导书》的 5.1 章节，或网上自学。 用例开发工具不做限制，大家可使用适合自身的工具，例如：nodepad++ 、PyCharm 、VS Code 等。 4.2 命令行导出工具 命令行导出工具的功能是：根据标签筛选用例，把用例集以 EXCEL 文件方式导出。此工具的获取和最新的详细使用说明可参考内网 wiki： http://wiki.weihong.com/pages/viewpage.action?pageId=30245325。 用法：RobotTool.exe --dir=F:\\自动化测试\\用例管理项目_demo --output=D:\\测试用例.xlsx --include=\"NK300CX||P1\" --exclude=auto 选项说明： --dir：测试用例目录, 默认为当前执行目录。 --output：导出Excel文件的路径，默认为： D://测试用例.xlsx 。 --filter:包含指定功能的测试套件则导出。多个测试套件使用“||”分隔，例如：--filter=\"安装||机械回原点\" --include: 包含指定标签的测试用例则导出，默认为空。当使用逻辑与或非的时候，需要使用双引号，例如：--include=\"NK300CX||P1\"，因为“||” 和“&&” 是windows命令行自带的特殊字符。 --exclude：包含指定标签的测试用例则不导出，即使满足include 也不导出。默认为空 。用法和include用法相同。 运行示例： 示例说明： 遍历“F:\\自动化测试\\用例管理项目_demo”目录下的Test_*.robot 文件，把文件里的测试用例导出到Excel文件：D:\\导出用例文件.xlsx 。其中只导出包含P1和Nk300cx 标签的用例，并且不包含Auto的测试用例。标签的名称大小写不敏感。 编制： 余晓霞 审核： 批准： 审批链接："
  },
  "doc/研发管理制度规范/测试管理规范/模板文件/测试计划(模板)-R1.html": {
    "href": "doc/研发管理制度规范/测试管理规范/模板文件/测试计划(模板)-R1.html",
    "title": "测试计划- XXXXXX 需求/项目",
    "keywords": "测试计划- XXXXXX 需求/项目 版次：2022年1月25日 第1版 类型：技术文件 部门：软件部 上海维宏电子科技股份有限公司 版权所有 文件版本 修改前文件版本 主要修订内容和原因 修订人 修订日期 R1 余晓霞 2022/1/25 1 引言 1.1 系统概述 本章应简述本文档适用的系统和软件的用途，它应描述系统与软件的一般性质；概述系统开发、运行和维护的历史；标识项目的投资方、需方、用户、开发方和支持机构；标识当前和计划的运行现场；并列出其它有关文档。 1.2 术语和定义 本章应包含为理解本文档需要的术语和定义，所有缩略语和他们在稳定中的含义的序列表。 1.3 参与人员 产品管理： 开发人员： 测试人员： 2 引用文件 本章应列出本文档引用的所有文档的编号、标题、修订版本和日期。还应标识不能通过正常的供货渠道获得的所有文档的来源。 名称 作者 编号 修订版本 发布日期 来源（查阅地点或渠道） ​ 表（1） 3 测试目标 测试关注点：系统测试和集成测试场景，注重于暴露给最终客户的功能特性、跨组件的交互操作、稳定性和可扩展性测试以及测试报告 功能测试：全覆盖需求； 自动化测试：通用功能自动化 性能测试：辅助性能测试指标测量对的执行、报告和趋势总结。 4 软件测试环境 测试环境名称 软件项 硬件及固件项 备注 仿真环境 1. 朗达仿真器； 2. Ex31A 仿真器； 台式电脑 * 1 此处可以备注其他信息，或相关说明等 测试环境 1. SQLiteSpy 查看应用程序运行日志； 1. NK300CX * 1； 2. Lambda 21B * 1； 3. Ex31A * 2； 4. 示波器 * 1； 5. EMU * 1； 6. 固件项： 生产环境 - 1. XXX 机床 * 1； 2. XXX 设备 * 1 ​ 表（2） 5 测试范围 本次需求新增和优化的功能： 序号 功能模块/组件 功能/能力 备注 1 圆弧插补 顺圆插补(G02) 半径编程 用户使用频繁，影响范围广 2 顺圆插补(G02) 圆心编程 3 逆圆插补(G03) 半径编程 4 逆圆插补(G03) 圆心编程 5 机械回原点 单轴（X、Y、Z）机械回原点 6 全部轴机械回原点 ​ 表（3） 耦合功能列表： 加工启动 断点继续 6 测试策略 6.1 功能测试 测试用设计策略分析 本章节主要描述测试设计中使用的策略，一般从验证项、用例设计原则、覆盖原则、可借鉴的经验等几方面进行描述。 （1）验证项： 描述需要验证的内容，分析哪些是重点验证项，可能存在的难点等 （2）用例设计原则： 设计用例时使用到的方法，如边界值分析法、等价划分法、错误推断、场景法等。 （3）覆盖原则： 描述设计用例时覆盖的范围。如新增功能模块需要全部覆盖，继承版本需要部分覆盖。 （4）可借鉴的经验： 从经验库中分析可以获取更多的测试方法、策略。 （5）核心业务特性功能测试设计： 从整体功能结构中分析整体核心业务逻辑，针对核心功能设计测试思路，构造具体测试方法、策略，依据基础测试理论总结测试设计，例如： 测试过程策略分析 在渐进测试或累积测试情况下，应解释计划的测试顺序和过程 6.2 自动化测试 通用功能自动化测试； 耦合功能自动化测试 6.3 兼容性测试 操作系统兼容：Win7、Win10； 软件配置兼容：总线、非总线 软件版本兼容： 硬件兼容：兼容二代朗达 6.4 性能、长时运行和稳定性测试 此处确定主要性能测试指标和性能测试策略 7 测试标准 7.1 冒烟测试通过标准 通用必测功能的冒烟测试用例，自动化测试通过； P1 级别的测试用例，手工测试通过。 7.2 XX 阶段测试通过标准 8 时间表 任务类型 测试任务 预计开始日期 预计结束日期 负责人 备注 测试管理 构建核心测试团队、人员和流程 建立基础硬件实验环境 测试设计 测试用例设计和评审 测试脚本设计和调试 测试执行 手工测试执行 通用功能自动化测试 测试报告 测试总结 文档归档 ​ 表（4） 附录 附录可用例提供那些便于文档维护而单独出版的信息（例如图表、分类数据）。为便于处理附录可单独装订成册。附录应按字母顺序（A 、B 等）编排。 编制：余晓霞 审核： 批准： 审批链接："
  },
  "doc/研发管理制度规范/测试管理规范/自动化测试管理规范-R1.html": {
    "href": "doc/研发管理制度规范/测试管理规范/自动化测试管理规范-R1.html",
    "title": "自动化测试管理规范",
    "keywords": "自动化测试管理规范 版次：2022年1月5日 第1版 类型：技术文件 部门：软件部 上层文件：软件测试用例设计规范 上海维宏电子科技股份有限公司 版权所有 文件版本 修改前文件版本 主要修订内容和原因 修订人 修订日期 R1 余晓霞 2022/1/5 1 目的 在团队协同工作环境下，让自动化测试可以更好的并行开发和实施。通过脚本的编码规范，达到增强脚本可读性、健壮性和可维护性的目的，并减少项目组中人为造成的损失。通过脚本质量规范，提高自动化测试执行的准确率，减少人工干预成本。 2 适用范围 软件平台及各产品线团队。 3 术语和定义 下列术语和定义适用于本规范。 规则： 必须遵守的约定。 原则： 指导性的约定。 说明： 对此规则或原则的必要解释。 正例： 对此规则或原则给出的正确例子。 反例： 对此规则或原则给出的反面例子。 例外： 对此规则或原则给出例外的说明。 代码片段： 在代码区域出现中括号中带中文字的及符号…， 如：[代码片段]或…， 则一般表示代码片段。 4 编程规范 编程规范遵循软件部的 软件编程规范（内网） 5 用例组织 【规则 1-1】 用例的标题描述、标签和优先级可参考《软件测试用例设计规范》。 【规则 1-2】 测试用例必须有断言（即预期结果），没有断言的用例，不属于完整的用例。 ​ 例外： 性能测试用例和稳定性测试用例可以不遵循此规则 【原则 1-3】 UI 自动化必须使用分层的思想，即把 UI 界面的对象属性和对象操作抽取到脚本的上层；禁止在测试用例里直接使用元素定位和操作元素。以下正反例是基于 RobotFramework 框架的代码片段。 ​ 反例 ： *** Test Cases *** TC001_验证按钮可用 click //Button[@AutomationId='1'] [代码片段] ​ 正例： *** Variables *** //UI对象库 button1_xpath=\"//Button[@AutomationId='1']\"; *** Keywords *** //元素所在页面的文件（或类文件）内容 ClickButton click button1_xpath *** Test Cases *** TC001_验证按钮可用 ClickButton [代码片段] 【原则 1-4】 遵循业务场景与应用操作分离的原则，即测试场景是由上层的应用操作组合而成。如下范例所示，范例是基于 RobotFramework 框架的代码片段。 *** Keywords *** 所有轴机械回零 [代码片段] 自动模式启动加工 [代码片段] 获取绿灯状态 [代码片段] return green_status *** Test Cases *** TC001_验证自动模式启动加工 所有轴机械回零 自动模式启动加工 Should Be True 获取绿灯状态 [代码片段] 【原则1-5】 UI 自动化测试，当有对话框或页面非系统首页时，必须有后置处理模块把对话框关闭或返回系统首页。以下正反例是基于 RobotFramework 框架的代码片段。 例外： 在各种异常或执行失败发生时，能把对话框关闭，避免未关闭的对话框，影响后面的用例执行。 正例: *** Settings *** Suite Teardown 退出日志列表页 *** Keywords *** 退出日志列表页 ${is_LS6000} is 6000 UI run keyword if ${is_LS6000} 进入绘图页 run keyword if ${is_LS6000} == ${False} LS3000关闭日志列表对话框 6 运行 【规则 2-1】 冒烟测试和回归测试（通用必测项回归测试）必须执行自动化测试。 ​ 例外： 自动化测试覆盖率不高，或自动化执行体系不健全，可不遵守此规则。 【规则 2-2】 保证提交服务器的代码无语法错误。 【原则 2-3】 脚本上传服务器之后，必须在持续集成上手动构建，并关注构建的结果，只有构建成功并且执行测试通过才可用于测试。 【原则 2-4】 搭建持续集成环境来执行自动化测试。自动化测试负责人负责持续执行环境的搭建和维护。 【原则 2-5】 当持续集成执行的自动化测试，执行失败时，应 24 小时内定位问题，如果是脚本问题，则应在 24 小时内修复。 【原则 2-6】 当测试用例超过 500 个，或修改影响的范围较广时，不可在用于真实测试的代码分支上进行修改，必须在开发分支上进行修改。 ​ 例外： 紧急问题修复可不遵守此原则。 【原则 2-7】 已实现自动化测试的功能，当其功能规格发生变更时，功能测试负责人须告知相关的自动化测试人员。 【原则 2-8】 功能测试人员必须关注自动化测试执行结果。执行失败时或自动化测试执行结果与手工测试执行结果不一致时，必须告知自动化测试人员。 编制：余晓霞 审核： 批准： 审批链接："
  },
  "doc/研发管理制度规范/测试管理规范/软件测试流程&过程规范-R3.html": {
    "href": "doc/研发管理制度规范/测试管理规范/软件测试流程&过程规范-R3.html",
    "title": "软件测试流程&过程规范",
    "keywords": "软件测试流程&过程规范 版次：2022年1月11日 第3版 类型：程序文件文件 部门：软件部 上海维宏电子科技股份有限公司 版权所有 文件版本 修改前文件版本 主要修订内容和原因 修订人 修订日期 R1 新建 汪腾霞 2017.07.10 R2 R1 1、加入测试任务提前审核的相关要求。 2、准入、准出准则直接放在各活动后面，冒烟测试准出单独定义。 3、对部分要求过细的规则，进行修调，以便更合理实施。 4、增加“通用测试制定原则”章节。 汪腾霞 2018.12.23 R3 R2 1、把 word 格式转换成 markdown 格式。 2、流程图增加评审通过和不通过环节，有些环节的输出物做调整，“测试工程师”修改为“测试”。 3、有些过程详解重定义。 4、去掉第 5 章冒烟测试准则 5、去掉第 6 章通用测试制定原则 6、新增 HotFix 说明 余晓霞 2022.1.11 1 目的 测试作为公司产品研发活动中的重要环节，明确的测试过程、规范的测试行为，可以提高软件研发工作的质量和效率。 2 适用范围 软件平台及各产品线团队。 3 术语和定义 为了统一认识，此处给出公司内部关于测试过程中的相关术语的定义。 测试流程： 从接收任务到任务测试结束经历的一系列有序的测试活动，即为测试流程 HotFix ： 也称为快速修复工程 ，是软件开发人员或程序员对已发布软件出现的 Bug 需进行紧急修复的术语。 过程： 为实现某一既定目的而进行的一组有组织的活动。 规则： 必须遵守的约定。 原则： 指导性的约定。 说明： 对活动、输入、输出、规则和原则等做必要的说明。 测试点： 根据测试范围以相对抽象的形式描述测试思路和预期。通常只有测试用例的标题，不要求提供详细的操作步骤或操作细节。 测试用例： 测试用例通常是测试执行的最小单元，主要由测试用例标题、前置条件、测试步骤、测试数据以及预期结果等要素组成。 测试执行记录： 测试用例/测试点在实际的软件上执行的结果记录。 测试版组件/软件： 不在用于发布分支打包的组件/软件，都属于测试版软件。 发布版组件/软件： 在用于发布分支打包的组件/软件，都属于发布版软件。 通用必测： 即软件中常用/基本业务功能的正向操作测试，或典型异常操作测试，通常外发类软件版本都需要进行此类测试。 4 软件测试流程 4.1 软件测试流程图 ​ 图（1） 说明： HotFix 的测试可不应用此测试流程，因为 HotFix 是对已发布软件出现的Bug 即时更正和优化，关注的是发布效率，即发布的周期越短越好。当客户反馈的问题被标志为 Hotfix 之后，测试应该马上介入，快速掌握引发问题的原因，并给出合理的测试方案。在开发提测之后，即刻进入测试执行，测试通过后才可发布。 4.2 过程详解 4.2.1 测试需求分析&计划 测试需求分析&计划过程的主要活动：测试需求分析、定制测试计划。 输入： 需求规格说明。 输出： 测试计划。 负责人角色： 测试。 审核人： 程序管理。 准入原则： 功能需求规格评审通过。 准出原则： 测试计划完成。 说明： 测试需求分析过程有疑问可咨询包括但不限于：开发、测试、产品管理、UE。 测试计划的主要目的是明确测试范围、指导测试工作的开展和结束、指导测试用例的编写及测试环境的搭建等。 测试计划包含的主要内容：测试方法和策略、确定质量度量指标和如何测量、明确测试目标、确立测试的类型、决定测试涵盖的内容、定义功能测试、决定测试的相关交付成果（例如：测试用例、测试脚本、测试资料等）、时间表。 满足以下任一要求，原则上需要输出测试计划： 软件逻辑架构有变更。例如：Phoenix 6.0 升级 MCC 后处理逻辑变更。 在内网研发的产品。 4.2.2 测试设计 测试设计的主要活动：测试用例的设计和编写、测试脚本及测试数据的设计和准备。 输入： 需求规格说明、测试计划。 输出： 测试点/测试用例。 负责人角色： 测试。 准入原则： 功能需求规格评审通过。 准出原则： 测试点/测试用例编写完成。 说明： 过度性的解决方案或特性变更频繁的功能点可以仅输出测试点，否则原则上要求必须输出测试用例。 测试用例设计规范参考《软件用例设计规范》。 测试脚本和测试数据的设计和准备，通常是指 G 代码、性能测试脚本和输入数据、自动化测试脚本和数据的设计和制作。这些活动开始于测试设计，止于测试执行结束。 4.2.3 测试用例评审 测试用例评审主要活动：对测试点\\测试用例进行评审。 输入： 测试点\\测试用例初稿。 输出： 测试点\\测试用例。 负责人角色： 测试。 评审人： 产品管理、开发、测试、架构师、UE、程序管理。 准入原则： 测试点/测试用例编写完成。 准出原则： 测试点/测试用例评审通过。 说明： 测试点/用例评审的方式不做要求，可以是正式（会议）或非正式（审查），根据实际情况而定。 有效的评审活动要求评审方的成员至少包含有其中一个上述提及的评审人。 如果是测试相互评审，则参与评审的测试必须经验丰富。 4.2.4 测试执行 测试执行的主要活动：测试准备、文档测试、冒烟测试、测试版本组件/软件测试、发布版本组件/软件测试等。 输入： 测试计划、测试点/测试用例、已提测软件/组件、开发交付件。 输出： 测试执行记录、Bug 记录、测试报告（测试版/发布版）。 负责组织： 测试。 参与人： 开发 准入原则： 测试版本组件/软件测试准入原则：开发自测通过、冒烟测试通过。 发布版本组件/软件测试准入原则：冒烟测试通过。 准出原则： 测试版本组件/软件测试准出原则：测试通过。 发布版本组件/软件测试准出原则：测试通过、通用必测通过。 测试通过规则： 【规则 2-4-1】 所有用例必须 100% 完成执行（若由于某些原因不可执行，必须告知相关人员（ 产品管理、开发、程序管理），在测试报告中说明）；且P1 和 P2 的用例必须 100% 执行通过。 【规则 2-4-2】 无严重级别为“致命”和“严重” 的 Bug （若不修复，相关人员（ 产品管理、开发、程序管理）必须达成统一意见）；所有不修复的 Bug 必须给出不可修复说明和风险评估，且在测试报告中说明。 说明： 测试执行不仅仅指开发提测后，对需求规格进行的确认测试；也包含开发提测前的有限的测试执行活动（例如: 文档测试等）。 测试版本组件/软件，或发布版本组件/软件提测之后，必须 48 小时内进行冒烟测试，并给出冒烟测试结论。 通常要求在测试版组件/软件测试执行通过之后，再做发布版组件/软件的测试执行。 发布版本组件/软件测试，必须对组件/软件进行通用测试。 发布版本组件/软件测试，通常要求对测试版本组件/软件的严重级别为“致命” 的 Bug 进行回归测试。 Bug 记录规范参考《缺陷跟踪流程》。 冒烟测试和通用测试必须执行自动化测试（例外：无自动化测试，或自动化测试能力缺失）。 发布版本组件/软件测试，在冒烟测试通过之后，建议进行交叉测试，即测试人员相互交换测试。 测试准备是指测试环境、测试数据（例如刀路文件等）、测试脚本等的准备工作。 4.2.5 测试评估 发布版软件测试通过即提交评审。评审包括但不限于：用例执行完整性、缺陷处理合理性、测试记录规范性。评审不通过需更正后再次评审。 输出： 审核记录 负责人角色： 测试\\程序管理。 说明： 当测试间相互评估时，要求评估的测试必需经验丰富。 4.2.6 测试结束 测试结束是测试流程的最后环节，其主要活动是对测试过程中使用到的相关资料或产出物进行整理归档，或对测试工作进行总结。 输出： 归档资料。 负责人角色： 测试。 准入原则： 测试评估通过 说明： 测试过程中使用的刀路文件，如客户刀路、特殊刀路等，归档至： \\\\172.16.10.123\\01.安全内网文件夹\\01.研发部文件\\02.受限文件\\01.软件部\\03.测试\\03.刀路文件 。 完善后的测试用例、测试脚本等上传至指定的服务器。 编制： 余晓霞 审核： 批准： 审批链接："
  },
  "doc/研发管理制度规范/测试管理规范/软件测试用例设计规范-R3.html": {
    "href": "doc/研发管理制度规范/测试管理规范/软件测试用例设计规范-R3.html",
    "title": "软件测试用例设计规范",
    "keywords": "软件测试用例设计规范 版次：2021年12月27日 第3版 类型：技术文件 部门：软件部 上层文件：软件测试流程&过程规范 上海维宏电子科技股份有限公司 版权所有 文件版本 修改前文件版本 主要修订内容和原因 修订人 修订日期 R1 新建 祁彩云、汪腾霞 2017.08.10 R2 R1 预置条件并入到操作步骤中 汪腾霞 2019.07.23 R3 R2 1、把word文档转换成markdown格式 2、第3章用例基本要素添加“标签”，“前置条件”；更新用例标题规则；修改“优先级”释义 3、第4.2章节添加标签详细解释；更新用例标题的内容； 修改title 为软件测试用例设计规范 4、重定义用例优先级 5、用例设计总原则加第8条 余晓霞、祁彩云 2021.12.27 1 目的 测试用例作为指导测试执行的重要依据，合理的设计，可以采用最少的用例，发现更多的问题，从执行效率和保证质量上达到双重目的。而合理的设计，也可以保证测试的复用，节省整体的测试时间。因此，特制定软件测试用例设计规范，规范用例设计和编写。 2 适用范围 软件平台及各产品线团队。 3 术语和定义 下列术语和定义适用于本规范。 规则： 必须遵守的约定。 原则： 指导性的约定。 说明： 对此规则或原则的必要解释。 正例： 对此规则或原则给出的正确例子。 反例： 对此规则或原则给出的反面例子。 例外： 对此规则或原则给出例外的说明。 4 用例设计总则 可以作为独立功能的需求，需编写基于该功能的测试用例。若一个需求里面包含多个功能，可以分解为多个功能，针对每个功能设计相关用例。 设计优先考虑功能性、其次是可靠性、易用性和其它特性。其中功能性优先考虑正向测试（功能正常）、其次是负向测试（功能异常）。 功能相关用例不仅仅考虑单一功能，也需要考虑功能和功能之间的交互影响。 每条测试用例粒度合理，测试目的唯一，如：该条用例不能够既包含正向测试又包含负向测试；或者既包含功能测试，又包含可靠性测试。原则上测试点唯一，或者根据优先级别和执行步骤、执行顺序，可以酌情合并和拆分。 测试用例设计方法优先推荐场景分析法（基本流、备选流），优先保证默认或者常用参数、条件的正确性，再基于等价类、边界值等方法考虑多组数据的组合。 测试步骤/预期结果具有普遍适应性，需考虑先设计“共享用例”，再引用。 功能的界面测试与业务逻辑测试分离设计。 每个用例可独立运行，用例间无依赖关系。 5 用例基本要素 编号 要素 释义 规则 1 用例标题 简单概要的描述该用例的归属和测试目的。 格式：[用例编号]_测试标题描述 用例标题应体现测试的范围和目的。其中，用例编号在功能范围内唯一，建议使用字母和数字组合，以字母开头。 2 前置条件 是测试用例执行的前置准备，如果不满足这些条件，则无法进行执行测试。 非必要的用例基本要素，当没有前置条件时，可忽略此要素。 3 测试步骤 人工或者机器执行的一系列操作。 一条用例的测试步骤一般不超过 15 条 4 测试数据 测试步骤操作过程中使用的输入数据。 1) 测试数据要具体。 2) 多数据变量时，可以采用等价类、边界值和正交分析等方法，选取尽量少的组合达到最大覆盖。 5 预期结果 在指定条件下，测试数据和测试步骤执行后，程序表现出的在开始处理、处理中和处理后的效果。 1) 一般一个测试步骤对应一个或多个预期结果。 2) 预期结果要尽量具体、明确。 6 优先级 优先级即用例在该功能模块中的重要级别，通过功能的重要性和用户实际使用频率的两个维度阐述用例的重要级别 。 目前定义为四个等级：P1 ~ P4，具体定义见 6.3 章用例优先级。 7 标签 标签为用例管理提供了一种灵活的管理方式，便于用例查找和复用。 一个测试用例可以包含多个标签，团队也可根据项目的实际情况自行定制。 ​ 表格1 用例基本要素 6 用例关键要素详析 6.1 用例标题 用例标题应体现测试的范围和目的。一个简单、清晰、有针对性的标题，能让人快速理解设计人的测试思路，从标题即可知道测试点及预期结果，也能方便后续使用人对用例的检索。 【规则 1-1】 用例标题格式：[用例编号]_测试标题描述 说明： 用例编号：用例编号在功能范围内唯一，建议使用字母和数字组合，以字母“TC”开头，用例编号中禁止包含下划线“_”。 正例：直排换刀功能 ​ TC001_验证换刀功能基本流程正确（ 功能正确性验证 ） ​ TC002_换刀时未检测到相关到位信号，换刀停止（ 功能异常处理/异常测试 ） ​ TC003_验证非空闲状态，换刀操作无效（ 异常测试 ） 6.2 用例主体 用例主体由前置条件、操作步骤、测试数据和预期结果组成。在描述用语原则： 【原则 2-1】 描述使用的专有名词或术语尽可能与相关使用说明文档（例如：功能规格说明书）中的保持一致。 【原则 2-2】 描述用词尽量规范、明确、量化、无二义性，避免口语化的描述。 6.2.1 前置条件 前置条件属于测试用例的可选元素，是测试用例执行的前置准备，如果不满足这些条件，则无法进行执行测试；例如执行所需的硬件环境或软件环境等。 【原则 3-1】 在团队内（或业务领域内）约定的默认前置条件，无需填写到前置条件。 正例: ​ 数控系统（NcStudio）约定以下内容为默认条件(不仅限于此默认条件，根据项目的实际情况而定)，无需填写到前置条件： 启动 NcStudio 软件 系统空闲状态 软件未回机械原点 参数设置为默认值 仿真软件 6.2.2 测试步骤 【原则 4-1】 测试步骤即是实际的操作，应避免将预期结果放在步骤里。 【原则 4-2】 测试数据和测试步骤要分离，步骤里面不要编写测试数据。 【原则 4-3】 若存在共享步骤，则可直接引用共享步骤。 说明 ：共享步骤即重复使用率高和通用性较强测试步骤，使用范围不受项目的限制。例如文本框的输入验证、参数默认值的验证、参数设置权限验证等。 【原则 4-4】 单个步骤描述时避免包含多个不同类型的操作。 反例： ​ 装载刀路，打开图层设置对话框，切割参数-特殊工艺中勾选“无感穿孔”勾选项，设置穿孔类型为类型 3，穿孔高度 10 mm 正例： ​ 1、装载刀路 ​ 2、打开图层设置对话框 ​ 3、切割参数-特殊工艺中勾选“无感穿孔”勾选项 ​ 4、设置穿孔类型为类型 3，穿孔高度 10 mm 6.2.3 测试数据 相同的操作只是因为进入前的状态或输入的数据不同，导致测试覆盖的路径不同，此时即可将其提取作为测试数据，按不同的测试目的进行组织，简化阅读并缩减后期维护工作量。 测试数据要具体，比如具体刀路文件、具体偏置设置值。 若不同前置置条件、不同的输入数据对于软件功能的影响不同，设计数据可以和前置条件进行组合设计。 测试数据可以不是一个实际的参数，比如可以将系统的不同状态作为测试数据、或将功能的不同入口作为测试数据。 6.2.4 预期结果 书写时要和测试步骤相对应并且具体。 一个步骤可能对应一个或多个预期结果。 为简化阅读和执行，保证结果的一致性，预期结果应尽可能具体，特别是针对坐标、速度、状态和正确/错误信息的描述。 范例： 回机械原点功能——Z轴回机械原点检测到精定位信号后，预期结果描述如下： 操作信息提示栏提示:Z轴粗定位信号与精定位信号之间的距离是***（单位是直线或者角度标准单位）； Z轴以200 mm/min的速度回退-2 mm后运动停止； Z轴运动结束后，操作状态为空闲，操作状态附加信息为正常结束； 坐标显示区Z轴名称前出现机械原点标志，Z轴机械坐标为0，Z轴工件坐标为0（前置条件是所有偏置设置为0） 6.2.5 标签 标签为用例管理提供了一种灵活的管理方式。便于用例查找和复用。一个用例可以包含多个标签，团队也可根据项目的实际情况自行定制。 已定义的标签类型说明如下： 用例优先级标签（ 必选 ）：P1~P4；优先级定义说明见《 6.3 用例优先级》；例如：P1。 测试类型标签（ 必选 ），主要包括：功能、易用、性能、可靠、兼容；例如：测试类型=功能。 功能使用范围标签（可选），主要包括：通用功能、XXX 客户定制功能。 通用必测标签（可选），若用例属于通用必测，则添加标签：通用必测。 执行方式标签（可选），若实现自动化，可以添加标签：Auto。 机型标签（可选），例如：机型=十轴链式刀盘。 环境标签（可选），例如：环境=Lambda21B。 【规则5-1】 必选的标签，必须在用例的标签处标上。 6.3 用例优先级 测试用例优先级作为测试各个阶段明确测试范围的重要依据，包括 开发自测、冒烟测试、全面测试（包括功能和非功能性测试）、回归测试、自动化覆盖 等，特对优先级别进行定义。目前定义四个等级 P1 ~ P4 具体见表格 **优先级 ** **覆盖用例 ** 优先级和测试范围关系 P1 用例覆盖主要的业务功能性和用户常用的业务场景 ——一般是基本流 1）核心功能的该等级则作为 开发自测、冒烟测试必测项 ； 2）一般为 通用必测 3）一般为 兼容性测试必测项 ； 4）自动化测试优先覆盖。 P2 用例覆盖主要的业务功能交互和用户不常用的业务场景 ——一般是备选流、边界用例、常见的反向用例 1）修改影响的功能回归测试必测项； 2）兼容性、性能&可靠性测试按需覆盖； 3）自动化测试优先覆盖。 P3 用例覆盖次要的业务功能，界面 ，和用户几乎不用的业务场景 ——一般是不常见的非法操作、异常场景 1）新功能或功能重构必测项； 2）兼容性、性能&可靠性测试按需覆盖； 3）自动化测试根据情况覆盖。 P4 用例覆盖功能相关的易用性、性能、可靠性等 1）新功能或功能重构必测项； 2）兼容性、性能&可靠性测试按需覆盖。 3）自动化测试根据情况覆盖。 ​ 表格2 用例优先级定义 说明： 为了保证测试策略执行的正确性，因此需要明确用例的优先级别。如果写用例的时间有限，请先设计优先级别高的测试用例。 优先级可以视质量需求和维护情况进行调整。"
  },
  "doc/研发管理制度规范/测试管理规范/软件测试规范.html": {
    "href": "doc/研发管理制度规范/测试管理规范/软件测试规范.html",
    "title": "软件测试规范",
    "keywords": "软件测试规范 版次：2022年3月1日 第1版 类型：程序文件 部门：软件部 上海维宏电子科技股份有限公司 版权所有 文件版本 修改前文件版本 主要修订内容和原因 修订人 修订日期 R1 新建 余晓霞 2022.03.1 1 目的和范围 本规范就公司的软件项目的测试活动、测试用例设计、自动化测试管理做出规定和指导。 2 术语和定义 为了统一认识，此处给出公司内部关于测试过程中的相关术语的定义。 HotFix ： 也称为快速修复工程 ，是软件开发人员或程序员对已发布软件出现的 Bug 需进行紧急修复的术语。 项目测试： 新产品研发或被定义为项目类型的任务的测试，称为项目测试。 维护测试： 产品发布或交付之后，因修改（产品计划的特性改善（例如产品迭代计划发布）、纠正和紧急变更、操作环境的变更、软件升级以及缺陷和漏洞的补丁等）、迁移、退役而引起的测试，称为维护测试。 正例： 对此规则或原则给出的正确例子。 反例： 对此规则或原则给出的反面例子。 说明： 对活动、输入、输出、规则和原则等做必要的说明。 测试点： 根据测试范围以相对抽象的形式描述测试思路和预期。通常只有测试用例的标题，不要求提供详细的操作步骤或操作细节。 测试用例（Test Case）： 为了特定的目的（证明软件存在某问题）而设计的一组由测试输入、执行条件、预期结果构成的文档。它通常包含测试标题、优先级、前置条件、测试步骤、预期输出、测试数据、标签等七个基本要素。 测试执行记录： 在被测对象上执行测试用例/测试点的结果记录，记录测试用例/测试点的执行情况（例如：准备运行、通过、失败、阻塞、故意跳过等）。 测试版本： 当被测对象是在非发布分支打包的组件/软件，称为测试版本。 发布版本： 当被测对象是在发布分支打包的组件/软件，称为发布版本。 通用必测： 即软件中常用/基本业务功能的正向操作测试，或典型异常操作测试，通常外发类软件版本都需要进行此类测试。 代码片段： 在代码区域出现中括号中带中文字的及符号…， 如：[代码片段]或…， 则一般表示代码片段。 ## 3 测试活动规范 ### 3.1 测试分析 必须对需求规格规格说明书或其它测试依据进行测试需求分析，解决需求疑问（例如：需求表述存在歧义或错误、缺少用户故事等），明确“测试什么”。 ### 3.2 测试计划 必须输出测试计划文档，文档的评审人可以是程序经理或项目内测试经验丰富的测试。测试计划文档应该包含内容，但不仅限于如下： 确定测试的范围、目标和风险。 决定使用的质量度量指标和如何测量。 安排测试分析、设计、执行和评估活动的进度表，可以按特定日期安排（例如，在顺序开发中）或以每次迭代的周境安排（例如，在迭代开发中）。 确定相关交付成果和测试文档的详细程度和结构（例如，通过提供模板或示例文档）。 项目测试的测试过程应该进行测试计划活动。维护测试的测试过程应根据变更内容的风险程度和影响范围或其它实际情况决定是否需要进行测试计划活动；通常情况下 HotFix 的测试过程不进行测试计划活动。 ### 3.3 测试设计 测试设计活动必须输出测试用例或测试点。内网研发的项目测试，必须输出测试用例。 维护测试的测试设计活动应根据变更内容的风险程度、影响范围、是否已存在历史用例、和实际情况，决定是否输出用例。若变更内容属于通用必测、内网开发的产品或已存在历史用例，则必须输出新增或完善后的测试用例；若变更内容是客户定制类、配置类或外网开发类需求，则可输出测试点。 在测试过程中，可不进行测试设计活动的情形有：产品从一个平台迁移到另一个平台、产品已退役、或 HotFix 。 测试用例编制或完善之后，必须进行用例评审活动，评审人应该包含，但不仅限于：产品管理、开发、项目内经验丰富的测试、架构师。评审方式不做限制，可以是正式评审或非正式评审，对应影响范围广、难度高和测试要求高的项目，宜进行正式评审活动。 ### 3.4 测试执行 在产品提测前，应该创建测试执行所需的用例集。例如：冒烟测试用例集、功能测试用例集、回归测试用例集等。 产品首次提测之后，必须48小时内进行冒烟测试，并给出冒烟测试结论。 发布版本测试必须进行通用必测。 当产品发布流程为：测试版本 -> 发布版本时，在发布版本应该对测试版本产生的严重级别为“致命”的 Bug 进行回归测试。 冒烟测试和通用必测必须执行自动化测试。 发布版本测试宜进行交叉测试（即测试之间相互交互测试）。 Bug 记录和跟踪必须按《缺陷跟踪流程》执行。 测试执行过程必须做测试执行记录。 ### 3.5 测试结束 检查测试用例是否 100% 执行，已解决的 Bug 是否都已关闭，未解决的 Bug 是否都已正确处理，若均回答“是”，则输出测试总结报告。 必须对测试过程中产生的测试件进行归档，例如：把完善后的测试用例上传代码管理服务器（Git/TFS），测试报告、测试记录或测试点以附件形式或备注形式附在对应的工作项或问题上。 应该进行测试总结与改进，纳入测试团队知识库，从而推动测试工作的不断优化与改进。 ### 3.6 测试监督和控制 测试结束之后，必须进行测试评估活动，确定是否满足产品准出准则，若满足，则评估通过，发布产品。测试评估活动包括但不限于：用例执行完整性、缺陷处理合理性、测试记录规范性、测试的度量标准。评估人由程序经理或项目内经验丰富的测试负责。 测试过程中，当测试实际进度与计划的进展差异较大，或存在其它风险时，宜向利益相关方发送测试进度报告。 ## 4 测试用例设计规范 ### 4.1 测试用例设计总则 可以作为独立功能的需求，需编写基于该功能的测试用例。若一个需求里面包含多个功能，可以分解为多个功能，针对每个功能设计相关用例。 设计应该优先考虑功能性、其次是可靠性、易用性和其它特性。其中功能性优先考虑正向测试（功能正常）、其次是负向测试（功能异常）。 功能相关用例不仅仅考虑单一功能，也应该考虑功能和功能之间的交互影响。 每条测试用例粒度合理，测试目的应该唯一，如：该条用例不能够既包含正向测试又包含负向测试；或者既包含功能测试，又包含可靠性测试。原则上测试点唯一，或者根据优先级别和执行步骤、执行顺序，可以酌情合并和拆分。 测试用例设计方法优先推荐场景分析法（基本流、备选流），优先保证默认或者常用参数、条件的正确性，再基于等价类、边界值等方法考虑多组数据的组合。 测试步骤/预期结果具有普遍适应性，宜考虑先设计“共享用例”，再引用。 功能的界面测试与业务逻辑测试应该分离设计。 每个用例必须独立运行，用例间无依赖关系。 描述使用的专有名词或术语应该与相关使用说明文档（例如：需求规格说明书）中的保持一致，用词应该规范、明确、量化、无二义性。 ### 4.2 测试用例基本要素 #### 4.2.1 用例标题 概述测试用例的主要内容，明确测试用例的意图。一个简单、清晰、有针对性的标题，能让人快速理解设计人的测试思路，从标题即可知道测试点及预期结果，也能方便后续使用人对用例的检索。 规范： 用例标题必须使用格式： [用例编号]_测试标题描述 。其中，用例编号在功能范围内必须唯一，必须使用字母和数字组合，以字母“TC”开头，用例编号中禁止包含下划线“_”。 正例： 直排换刀功能 TC001_验证换刀功能基本流程正确（**功能正确性验证**） TC002_换刀时未检测到相关到位信号，换刀停止（**功能异常处理/异常测试**） TC003_验证非空闲状态，换刀操作无效（**异常测试**） 4.2.2 前置条件 测试用例执行的前提条件，如果不满足这些条件，则无法进行执行测试。 规范： 非必要的用例基本要素，当没有前置条件时，可忽略此要素。 在团队内（或业务领域内）约定的默认前置条件，无需填写到前置条件。 正例： 数控系统（NcStudio）约定以下内容为默认前置条件 启动NcStudio应用程序 系统空闲状态 软件未回机械原点 参数设置为默认值 仿真环境 4.2.3 测试步骤 如何执行这个测试用例，每步的操作是什么。 规范： 一条用例的测试步骤不宜超过 15 条。 测试数据和测试步骤要分离，步骤里面不应编写测试数据。 若存在共享步骤（重复使用率高和通用性较强的测试步骤，使用范围不受项目的限制。例如文本框的输入验证、参数默认值的验证、参数设置权限验证等），则应该直接引用共享步骤。 单个步骤描述时禁止包含多个不同类型的操作。 反例： 装载刀路，打开图层设置对话框，切割参数-特殊工艺中勾选“无感穿孔”勾选项，设置穿孔类型为类型3，穿孔高度10 mm 正例： step1: 装载刀路 step2: 打开图层设置对话框 step3: 切割参数-特殊工艺中勾选“无感穿孔”勾选项 step4: 设置穿孔类型为类型3，穿孔高度10 mm 4.2.4 预期结果 预期结果是和测试步骤对应起来，操作后希望程序或系统返回或特征。 规范： 为简化阅读和执行，保证结果的一致性，预期结果应尽可能具体和明确，特别是针对坐标、速度、状态和正确/错误信息的描述。 正例: 回机械原点功能—— Z 轴回机械原点检测到精定位信号后，预期结果描述如下： 1. 操作信息提示栏提示:Z轴粗定位信号与精定位信号之间的距离是***（单位是直线或者角度标准单位）； 2. Z轴以200 mm/min的速度回退-2 mm后运动停止； 3. Z轴运动结束后，操作状态为空闲，操作状态附加信息为正常结束； 4. 坐标显示区Z轴名称前出现机械原点标志，Z轴机械坐标为0，Z轴工件坐标为0（前置条件是所有偏置设置为0） 4.2.5 测试数据 测试时使用的测试数据。 规范： 测试数据要具体，比如具体刀路文件、具体偏置设置值。 若不同前置置条件、不同的输入数据对于软件功能的影响不同，设计数据可以和前置条件进行组合设计。 测试数据可以不是一个实际的参数，例如：系统的状态、功能入口。 测试过程中使用的刀路文件，如客户刀路、特殊刀路等，归档至： \\\\172.16.10.123\\01.安全内网文件夹\\01.研发部文件\\02.受限文件\\01.软件部\\03.测试\\03.刀路文件 4.2.6 标签 标签为用例管理提供了一种灵活的管理方式，便于用例查找和复用。个用例可以包含多个标签，团队也可根据项目的实际情况自行定制。 规范： 用例优先级标签（ 必须 ）：P1~P4；优先级定义说明参考 4.2.7 章的用例优先级。 测试类型标签（ 必须 ），主要包括：功能、易用、性能、可靠、兼容；编写正例：测试类型=功能。 功能使用范围标签（可选），主要包括：通用功能、XXX客户定制功能。 通用必测标签（可选），若用例属于通用必测，则添加标签：通用必测。 执行方式标签（可选），若实现自动化，可以添加标签：Auto。 机型标签（可选），例如：机型=十轴链式刀盘。 环境标签（可选），例如：环境=Lambda21B。 说明： “必须” 的标签，必须在测试用例的标签出标记有。 4.2.7 用例优先级 优先级即用例在该功能模块中的重要级别，通过功能的重要性和用户实际使用频率两个维度阐述用例的重要级别。用例优先级可以作为明确不同测试类型（开发自测、冒烟测试、全面测试（包括功能和非功能性测试）、回归测试、自动化覆盖等）的测试范围的重要依据。优先级定义四个等级 P1 ~ P4 具体详述如下。 P1 ： 覆盖功能或业务的重要点部分，用户使用频繁。通常为关键业务流，此用例通常可以确认此版本是否可测。 优先级和测试类型的关系： 开发自测必测 冒烟测试必测 若功能属于通用功能，则其属于通用必测 自动化测试应该覆盖 版本兼容性测试应该执行此用例 P2 ： 覆盖功能或业务的次要部分，用户偶尔使用。一般为备选业务流、边界用例、常见的反向用例。 优先级和测试类型的关系： 单功能回归测试时必测 自动化测试应该覆盖 P3 ： 覆盖功能或业务的次要部分，用户几乎不使用。一般为不常见的非法操作、异常场景。 优先级和测试类型的关系： 单功能回归测试时必测 自动化测试应该覆盖 可靠性测试应该覆盖 P4 ： 覆盖功能或业务的次要部分，用户不会如此操作。通常覆盖功能相关的易用性、性能、可靠性。 优先级和测试类型的关系： 性能测试或稳定性测试覆盖。 ### 4.3 测试用例管理规范 必须使用代码的方式管理测试用例（使用指导应参考《手工测试用例编写指导书-基于 RobotFramework》），测试用例存放在版本管理服务器（Git/TFS）。 当手工用例完全转换成自动化用例之后，应该作废手工用例或删除手工用例。 当手工用例只有部分可以转换成自动化用例时，应该把此用例按照手工和自动化进行拆分。 完善用例时，必须先确认是否已存在相同的用例，若已存在相同的用例，则完善用例，否则新增用例。若是自动化用例，则更新自动化脚本。 ## 5 自动化测试管理规范 编程规范宜遵循软件部的 软件编程规范（内网） 。 基于 RobotFramework 框架的自动化应按照《RobotFramework 自动化测试框架使用指导书》实施。 UI 变化频繁的产品不宜实施 UI 自动化。功能逻辑变更频繁或尚不稳定的产品不宜实施自动化。 ### 5.1 用例组织规范 用例设计规范应遵守第 4 章的测试用例设计规范。 功能性的自动化测试用例必须包含有断言（即预期结果），否则属于无效用例。 UI 自动化测试脚本设计应该使用分层的思想，即把 UI 页面控件的获取和操作封装成函数，供组织用例时调用；不应在测试用例里直接引用页面元素的定位和操作。以下正反例是基于 RobotFramework 框架的代码片段。 反例： 用例文件 *** Test Cases *** TC001_验证按钮可用 #用例标题 click //Button[@AutomationId='1'] #单击xpath=//Button[@AutomationId='1'] 的页面元素 [代码片段] 正例： 1、先把 UI 页面控件的获取和操作，在文件 A 里定义。 *** Variables *** button_xpath=\"//Button[@AutomationId='1']\"; #Xpath 地址 *** Keywords *** ClickButton #定义单击按钮的关键字（函数） click ${button1_xpath} #单击 xpath 等于变量 ${button_xpath} 的页面元素 2、用例文件使用文件 A 已定义的操作按业务流组成用例。 *** Settings *** Resource A #载入 UI 页面控件的获取和操作文件 A *** Test Cases *** TC001_验证按钮可用 #用例标签 ClickButton #调用UI 页面控件的获取和操作文件 A 里定义的单击按钮的关键字（函数） ClickButton [代码片段] UI 自动化测试，当有对话框弹出或进入非首次进入的默认页时，必须在后置处理模块把对话框关闭或返回首次进入的默认页。避免在出现异常或执行失败时，影响后续用例的执行。 UI 对象的 xpath 应该使用相对路径。 5.2 自动化版本管理规范 测试工具或测试库的版本管理应遵循如下规范： 非 Hotfix 的修复禁止在主分支上直接修改，必须在开发分支上进行维护开发，，待测试（维护人负责测试）通过之后，通知相关方（软件部），待其验收通过之后，才可合并到主分支上。 开发分支合并主分支后，应该在其中一台测试执行机上进行发布测试（由变更人进行测试，软件部验收）通过之后，才可发布到各个测试执行机。 提交或合并到主分支的测试脚本，必须经过自测，自测检查列表如下，但不仅限于： 无语法错误。 单个测试套件执行通过。 持续集成环境执行通过，且不影响其他用例的执行。 当自动化用例体量较大，或参与开发人员较多时，宜规划分支管理策略（团队内的自动化测试负责人），不宜主分支上维护。 5.3 持续集成管理规范 Jenkins Job 名称或 TFS 生成定义的名称命名格式：部门名称_[产品名称]_测试环境_[其它标识或描述]，中括号“[ ]”的字段选填。 正例： 金属切屑_TZ820_NC300CX_RobotFramework 金属切屑_TZ820_NC300CX_Lua 激光加工_仿真环境(win10)_发版前回归测试 必须保证自动化持续集成环境的稳定性，禁止出现5天以上的不可用情况。 ### 5.4 自动化运行规范 在持续集成环境，使用自动化测试，执行失败之后，如果是脚本问题，或无法定位的问题类型时，应该告知相关人员（脚本编写人或自动化维护人员）尽快对问题进行定位分析和修复。 当自动化持续集成环境不可用时，可在测试环境上离线执行自动化测试。 ## 6 参考文献 国际软件测试委员会的大纲《ISTQB 认证测试工程师_FL大纲-2018版_V3_1》。 《微软软件研发的奥秘 MSF 精髓》。 软件产品质量模型标准 GB/T 16260 。 编制： 余晓霞 审核： 批准： 审批链接："
  },
  "doc/研发管理制度规范/激光加工产品部Bug处理流程-R3.html": {
    "href": "doc/研发管理制度规范/激光加工产品部Bug处理流程-R3.html",
    "title": "激光加工产品部 Bug 处理流程",
    "keywords": "激光加工产品部 Bug 处理流程 版次：2021年07月28日 第2版 文件类型：程序文件 上海维宏电子科技股份有限公司 版权所有 修改历史 文件版本 修改前文件版本 主要修订内容和原因 修订人 修订日期 R1 新建 唐涛 2021-7-13 R2 增加软件发行、发行测试 删除文档整理 唐涛 2021-7-28 R3 添加重现步骤描述、自测要求、缺陷分析详细要求、测试准入准出详细要求。 骆玲 2021-8-18 1 引言 1.1 编写目的 为指导和规范激光加工产品部在处理内部或外部反馈 bug，特编写此流程。 此文档不适用于以下情况： 工作项衍生出来的 Bug 工作项 没有开发任务的纯测试工作项 1.2 读者对象 激光加工产品部开发、测试、应用。 1.3 参考文档 《TFS 工作项命名规范》 《TFS 工作项填写规范》 《长沙 Wiki 使用指南.md》 1.4 用语 序号 用语 描述 1 外部 bug 由客户提出的 Bug 2 工作项 bug 工作项发行过程中出现的 bug 3 独立 Bug 与当前在测试工作项无关 bug 4 研发 完成客户产品需求的生产过程，包括需求分析、设计、实现、测试 5 开发 专指开发工程师编写代码、自测、发行软件过程 2 Bug 处理流程 根据软件研发和实际工作，研发流程分为如下阶段： 1） Bug 信息收集 2） Bug 复现 3） 原因分析 4） 解决&自测 5） 代码评审 6） 测试&回归 7） 分支合并 8） 软件发行 9） 发行测试 2.1 流程图 2.2 流程详解 2.2.1 Bug 信息收集 外部反馈 bug 针对客户提出的问题，确定问题现象，操作方式，出现概率，软件版本，客户信息，现场日志等第一手信息收集回来，整理并创建 TFS Bug 项 Bug 项创建完成后，通知研发经理（研发组长）分配开发工程师跟进 Bug 在收集信息过程中，也伴随着 bug 的复现和反复沟通，现场情况渐进明细；相关的信息补充到 Bug 项说明中。 工作项 Bug 测试工程师测试过程中直接创建 不确定的现象，先跟开发、应用沟通再创建 bug 有争议的现场，可直接创建 bug， 有结论后再根据实际情况关闭 工作项 bug，需要链接到 Task 项，链接方式【Tests】 独立 Bug 测试工程师测试过程中直接创建 不确定的现象，先跟开发、应用沟通再创建 bug 有争议的现场，可直接创建 bug，有结论后再根据实际情况关闭 工作项 bug，需要链接到 Task 项，链接方式【Related】 Bug 项的创建，需要判断 Bug 影响的范围，如果是多款软件都存在的，需要在 Bug 项中增加【Tag】“未合并” Bug 项命名规范，请参考《激光加工产品部 TFS 工作项命名规范.md》 Bug 项重现步骤要求如下： 【测试环境】软件环境和硬件环境 【Bug 步骤】 /* 描述 Bug 重现的详细步骤，尽量保证每步仅做一个操作 * /； …… 说明：操作对象有特定刀路，刀路名称描述在操作步骤里面 【Bug 概率】百分百出现时缺省 【实际结果】描述清楚操作后的现象 【期望结果】实际结果对应的期望结果 【测试复现】外部 BUG 填写，测试复现情况，已复现或者未复现 【现场情况】外部 BUG 填写，描述客户现场的情况，发生的时间，发生的概率，是否有临时处理方案，紧迫性如何 2.2.2 Bug 复现 工作项 Bug、独立 Bug 本来就是测试工程师测试的，问题复现相对简单；外部反馈 Bug 非本人操作出来，复现难度较大。 Bug 复现主要是为了后续确定 Bug 、定位 Bug 、修复 Bug 、验证 Bug 是否解决。这个过程很重要，主要测试工程师负责，但对于偶发 bug，需要开发工程师给出复现思路，甚至修改软件提高复现概率。 2.2.3 原因分析 Bug 原因分析由开发工程师或系统工程师完成； 分析 bug 产生的直接原因、根本原因；并将分析过程和分析结论写入 TFS Bug 项【Analysis and Correction】 Bug 原因分析完成， 追溯 Bug 具体核实产生，确定引入人和引入的版本，评估影响范围；需要填写 Bug 项中【Imported By】、【Bug Type】 Bug 原因分析完成，即可确定 Bug 归属的团队，需要将 Bug 项中【Team】改为引入者对应团队； 注意： Bug 引入人非 Bug 解决人，则需要通知引入人，并得到引入人的确认才可以。 2.2.4 解决方案 大部分 Bug 原因明确之后，就可以直接得到解决方案，此时只需要将解决方案给出，相关开发、测试、应用讨论即可；无需为了形式写文档评审。 对于涉及系统架构、底层原理方面的 Bug，则需要正经写出原因分析和解决办法进行方案评审。 2.2.5 解决方案评审 解决方案评审： 由产品总工负责，系统工程师、开发工程师参与 首先按照《技术文档写作指南_内容-R1.1.md》对文档书写内容进行规范化 确定评审相关的人员，并组织评审会议 评审完成， 将评审记录，写入方案设计最后一章：评审记录中 根据评审会议结果修改设计文档 评审决议要求复评，准备下一次评审 2.2.6 实现、自测 根据 Bug 解决方案进行实现，并按照复现环境和方法验证 Bug 是否解决 需要对修改的每一行代码进行调试 自测阶段，要保证基本流正确 如果功能涉及硬件，必须上机床测试 转测试之前，需要在 TFS 正确填写必填字段，特别是引入者，找不到引入者，需要把原因写在 Analysis And Correction 里面， 原因分析和解决措施需要写得清晰易懂，写自测说明。 Analysis And Correction 示例： 【原因分析】： 【解决方案】： 【预防措施】： 无预防措施则填无 【引入者说明】：没有具体的引入者需要写这一条 自测说明示例： 【自测说明】 是否自测：是 测试方法：手工\\自动化、以及其他测试方法 测试范围：BUG 项需要描述详细的自测范围 建议测试范围：此处填写工作项影响范围，请根据代码修改情况充分评估影响范围，要求测试范围具体、准确，比如，影响哪些功能的哪些部分。 2.2.7 代码审核 代码审核原则： 每一行代码都必须评审 签入的每一行代码都必须通过编码规范审核 代码审核制度： 凡是代码签入，必须要经过评审；审核通过才能签入 审核发现三处编码规范问题，可直接退回，修改后重新提交评审；因此而产生的工作项延期，由被审核人承担 代码审核提交后，截图以 RTX 通知审核者 代码审核完成之后，截图以 RTX 通知申请人 多个审核人，有一个审核通过即可签入代码 以上所说的代码，指的是 非 Dev 分支 代码。 2.2.8 搁置集测试 测试工程师根据 Bug 的现象，复现步骤，对软件进行测试； 也要根据自测记录，思考会影响的功能进行测试。 测试通过后 State =已关闭，Activity =待合并。 2.2.9 分支合并 分支合并由开发工程师负责： 开发工程师根据工作项的范围，确定要合并到的插件 or 集成项目分支 判断本次合并的范围，如果合并有较高风险，需要与测试沟通，发合并任务测试 所有合并完成之后， 激光管切 Activity=空，激光平面 Activity=待 beta 验收。 注意： 合并的质量由开发工程师保证 2.2.10 软件发行 Bug 的解决，尤其是外部 Bug，解决 Bug 的软件客户真正使用上才能算 Bug 完整的解决；软件发行时，将上个版本到本次发行的 Bug 加入发行项中，并在发行软件转测试时，开发验证 Bug 已经合并。 2.2.11 发行测试 测试必须严格准入： 开发提供详细的自测说明，无自测说明，测试范围不可收敛，不可测，拒绝测试。 测试必须检查引入者和 Analysis And Correction，没有填写具体的引入者需要在 Analysis And Correction 特殊说明， Analysis And Correction，清晰易懂，测试必须理解。 测试必须严格准出： 测试记录格式如下： 第*次测试情况说明： 测试结论：（通过） /（不通过） 测试环境： 测试版本： 测试范围： 是否检查开发缺陷分析： 是否检查开发自测说明： 测试资料是否归档：归档了写地址，未归档写待归档，不需要写不需要原因 激光管切： 发行项测试时，需要将已经合并的 Bug 验证，保证发行出去的软件一定是解决了此Bug。 激光平面： 发行 beta 软件，需要把所有待 beta 验收的 Bug 都验收掉，Activity =待 release 验收。 发行 release 软件，需要把所有待 beta 验收和待 release 验收的 BUG 验收掉，Activity =验收完成。 说明：发行 release 软件时， beta 还未验收，就直接验收 release 这种情况，我们认为 release 是由 beta 合并而来，release 没有问题，beta 就没有问题。 3 附录 产品技术架构设计： http://172.16.1.7:9999/#!维宏研发/DesignPhase.md 长沙 Wiki 使用指南： [ http://172.16.1.7:85/#!ChangSha_tm/00.使用指南/Wiki 使用指南.md]( http://172.16.1.7:85/#!ChangSha_tm/00.使用指南/Wiki 使用指南.md) 编制： 唐涛 审核： 批准："
  },
  "doc/研发管理制度规范/激光加工产品部TFS工作项命名规范-R5.html": {
    "href": "doc/研发管理制度规范/激光加工产品部TFS工作项命名规范-R5.html",
    "title": "激光加工产品部 TFS 工作项命名规范",
    "keywords": "激光加工产品部 TFS 工作项命名规范 版次：2021年8月11日 第5版 类型：规范文件 作者：激光加工产品部-长沙研发 上海维宏电子科技股份有限公司 版权所有 1. 命名定义 Task 命名： 【产品型号*】-【型号说明】-【创建团队*】-【功能模块】-【功能名称*】-【客户名】 Bug 命名： 【Bug 来源*】-【创建团队*】-【产品型号*】-【功能模块】-【型号说明】-【Bug 描述*】-【客户名】 发行工作项命名： 软件发行-【产品型号*】-【客户名】-【软件版本*】-【发行日期*】 *：必须项 【型号说明】与【功能模块】一般情况是互斥的 1.1 产品型号* 通用型号定义 以产品系列为基础进行划分；在细分的产品系列又分为平面、管切、板管一体 三种类型，具体如下： 名称 说明 Laser 激光通用，包括平面、管切、板管一体 LS 平面专用，此类标题的任务不用考虑管切 TU 管切专用，此类标题的任务不用考虑平面 LT 板管一体专用，此类标题一般都是板管才会有的任务 专用型号定义 一般以产品系列名称作为定义；如果有多个产品型号都需要的，以 \\ 作为区分； 例： TU3500\\TU5500M-CS-电动卡盘增加水平垂直延时-邦德 型号分类图 1.2 型号说明 可选项，用于对型号进行补充说明：包括但不限于以下几个方面： 通用型号强调：Laser - 通用 板管一体型号细化：LT - Tube/Plane 客户定制功能：TU3700M - 定制 1.3 功能名称/Bug 描述* 功能名称、Bug 简述：都是名词，概况性描述任务内容。 1.4 创建团队* 简写 团队名称 LH 上海激光 CS 长沙研发 1.5 客户名 外部反馈： 客户名称 或 技术销售姓名 内部需求\\Bug： 提出者姓名 1.6 Bug来源* 客户反馈： 由客户或销售人员反馈的 bug 内部测试： 由测试人员发现的 bug 研发测试： 研发人员在自测或使用过程中发现的其他 bug 1.7 功能模块 在做功能增强时，功能所属的大模块。 TU-CS-管顶料-增加纯伺服管顶料-迅镭 Laser-LH-焦点控制-增加普雷调焦 1.8 软件版本 Alpha:未经过内部完整测试的版本 Beta:在上一版本上增加了新功能，发给客户公测的版本 Release:稳定版本 1.9 发行日期 年.月.日 2021.04.22 2. 案例 管切平面通用需求 Laser-通用-摄像头启用状态保存-邦德 【产品型号】-【型号说明】-【功能名称】-【客户名】 邦德提出的需求，内部判断是激光通用功能；所以工作项为激光通用 Laser-通用-修改极性添加制造商权限 【产品型号】-【型号说明】-【功能名称】 专管功能 TU-CS-管顶料-增加纯伺服管顶料-迅镭 【产品型号】-【创建团队*】-【功能模块】-【功能名称】-【客户名】 TU-通用-CS-暂停减速加速度分轴设置 【产品型号】-【创建团队*】-【功能名称】-【客户名】 板管一体功能 通用：LT-通用-安装、参数路径修改 管切：LT-Tube-增加激光 DA 校正 平面：LT-Plane-增加 CE 认证 某个产品系列通用功能 LS6000-通用-LH-增加五级穿孔-宏山 【产品型号】-【型号说明】-【创建团队*】-【功能名称】-【客户名】 客户单个产品定制功能 TU3700M-定制-CS-迅镭双卡下料需求-定制-迅镭 【产品型号】-定制-【创建团队*】-【功能名称】-【客户名】 客户多个产品定制功能 TU3000\\TU1000-定制-CS-特殊拉料功能-江门安德 软件发行 软件发行-TU3700M-迅镭-2021.04.15 3. 其他说明 修改记录 序号 版本 修订人 日期 描述 1 R1.0 唐涛 2021-4-13 初版建立 2 R2.0 唐涛 2021-4-22 增加发行日期规则，修改Bug来源：外部反馈 -> 客户反馈 3 R3.0 唐涛 2021-5-24 修改部分文字错误；增加定制字段 4 R4.0 唐涛 2021-7-13 增加 bug 中的创建团队 5 R5.0 唐涛 2021-8-11 增加 Task 中的团队缩写"
  },
  "doc/研发管理制度规范/激光加工产品部研发流程-R2.1.html": {
    "href": "doc/研发管理制度规范/激光加工产品部研发流程-R2.1.html",
    "title": "激光加工产品部研发流程",
    "keywords": "激光加工产品部研发流程 版次：2021年11月9日 第2.1版 文件类型：程序文件 上海维宏电子科技股份有限公司 版权所有 修改历史 文件版本 修改前文件版本 主要修订内容和原因 修订人 修订日期 R1 新建 唐涛、穆冬华 2021-7-15 R1.1 R1 1. 需求分析阶段，建议测试、开发都参加 唐涛 2021-7-23 R2 R1.1 添加开发自测报告要求、添加测试具体测试记录要求 骆玲 2021-8-18 R2.1 R2 添加平面发布自动化要求 骆玲 2021-11-9 1 引言 1.1 编写目的 为指导和规范激光加工产品部在研发过程中的任务流转，特编写此流程。 1.2 读者对象 激光加工产品部应用、开发、测试。 1.3 参考文档 《TFS 工作项命名规范》 《TFS 工作项填写规范》 《长沙 Wiki 使用指南.md》 2 研发流程 根据软件研发和实际工作，研发流程分为如下阶段： 1） 需求分析 2） 需求审核 3） 规格制定 4） 规格评审 5） 功能设计 6） 设计评审 7） 实现、自测 8） 代码审核 9） 测试&回归 10） 合并 11） 文档整理 2.1 流程图 2.2 流程详解 2.2.1 需求分析 针对技术销售工程师、客户提出的功能需求，对初步的需求进行需求分析，了解需求的背景、要解决的问题，评估需求的合理性，并对需求从功能、性能方面进行全面的分析。针对需求进行竞品研究，了解行业中同类需求的解决办法。 需求的核心是： 定义问题 需求分析之后，如果软件中已经具备功能，则不进入研发流程 需求分析完成之后，建立工作项，并通知产品总工 需求分析文档以附件的形式链接到工作项中 此阶段由应用工程师负责，必要时总工、开发工程师协助分析问题 需求分析完成，建立 TFS Task，关键内容： 完成时间： 需要跟开发经理或总工协商； 发行项 所带任务完成时间要 提前两个工作日 标题： 要符合《激光加工产品部TFS工作项命名规范.md》 最佳实践： 在讨论需求、进行需求分析时，将测试人员、开发人员一起拉入需求讨论组，这样需求的讨论会更加充分，最大限度减少返工的可能性。 2.2.2 需求审核 由产品总工负责对需求进行审核，从如下几个维度对需求进行审核： 需求的合理性 需求是否有价值 是否是共性需求 现有功能规格是否符合需求 需求是否可以通过其他功能实现 需求是否需要写功能规格、设计方案 Task 完成时间的合理性：如果不合理，需要跟应用、销售、客户协商确定好时间 需求审核：TFS工作项审核字段改为“通过”；需求审核完成，需将 Task 告知开发经理（组长）、测试负责人、应用工程师 审核历史记录： 结论：通过 or 不通过 说明： 是否需要写规格方案，工作项要注意的点，其他说明 2.2.3 规格制定 规格制定分为两种情况： 现有规格不满足需求：由系统工程师对原有规格进行扩展，并修改出完整的新规格。 制定全新规格：进行竞品分析，结合需求制定全新的规格 规格由系统工程师制定 规格文档必须包括：背景分析、竞品分析，功能规格，性能规格 功能规格产出文档：功能规格说明书 功能规格模板： http://172.16.1.7:9999/#!维宏研发/设计阶段/模板/[团队名称]-[功能名称]-功能规格-模板-R1.md 规格的核心： 描述通过什么功能解决问题 2.2.4 规格评审 规格评审原则： 凡是规格的变化必须通过评审 规格评审 必须 有：开发、测试、应用参加 全新规格需要经过公司评审 评审完成， 将评审记录，写入功能规格最后一章：评审记录中 评审通过，由总工负责，将功能规格放到三级规格中： http://yfmis.weihong.com/View 2.2.5 功能设计&测试用例设计 功能设计： 由系统工程师执行 首先要评估自己的知识技能是否能够做出符合功能规格的设计；如果评估不够，先要及时反馈，并对缺失的内容进行弥补 接下来，要找出设计的核心问题；并判断出此次设计是增量式设计还是颠覆式设计，尽量避免重复造轮子 整理自己的思路，并说明核心设计内容 进行详细设计，以设计文档为主体；将对功能的设计清晰的表述到设计文档中 对于改动量大，设计复杂的方案， 建议系统工程师与开发工程师一起写详细设计方案 功能设计的核心： 如何实现功能 设计文档模板：设计方案模板： http://172.16.1.7:9999/#!维宏研发/设计阶段/模板/[团队名称]-[XXX方案设计]-模板-R1.md 测试用例设计： 由用例设计负责人执行 首先接到需求后就开始进行需求分析，从专业角度对需求进行理解、纠错、补充。 需求分析中可咨询包括但不限于：需求责任人、开发负责人、测试主管、测试组长。 接到规格后开始进行测试分析，常用的测试分析法：质量模型分析法、场景分析法。 制定测试计划，主要从时间、人员、任务量、设备等方面着手，并进行适当的风险预估。 测试分析产出：测试分析文档。 推荐工具：OneNote、思维导图。 运用黑盒测试用例设计方法进行用例设计。 测试用例设计产出：测试用例。 注意：测试用例设计时需考虑用例的可重复利用性、自动化脚本编写便利性。 2.2.6 设计评审&测试用例评审 设计评审： 由产品总工负责，系统工程师、开发工程师参与 首先按照《技术文档写作指南_内容-R1.1.md》对文档书写内容进行规范化 确定评审相关的人员，并组织评审会议 评审完成， 将评审记录，写入方案设计最后一章：评审记录中 根据评审会议结果修改设计文档 评审决议要求复评，准备下一次评审 测试用例评审： 由测试审核人负责 测试用例修改后必须进行审核 由测试主管/测试组长指定测试审核人 确定评审相关的人员，并组织评审 评审完成，根据评审结果修改测试用例 评审决议要求复评，准备下一次评审 2.2.7 实现、自测 根据设计文档进行代码模块的编写 需要对每一个功能分支进行调试 需要对每一行代码进行单步调试 自测需要写自测说明，如下： 【自测说明】 是否自测：是 测试方法：手工\\自动化、以及其他测试方法 测试范围：工作项需要提交《自测报告》 建议测试范围：此处填写工作项影响范围，请根据代码修改情况充分评估影响范围，要求测试范围具体、准确，比如，影响哪些功能的哪些部分。 2.2.8 代码审核 代码审核原则 ： 每一行代码都必须评审 签入的每一行代码都必须通过编码规范审核 代码审核制度： 凡是代码签入，必须要经过评审；审核通过才能签入 审核发现三处编码规范问题，可直接退回，修改后重新提交评审；因此而产生的工作项延期，由被审核人承担 代码审核提交后，截图以 RTX 通知审核者 代码审核完成之后，截图以 RTX 通知申请人 多个审核人，有一个审核通过即可签入代码 对于代码改动量大，改动范围广的修改； 建议开代码评审会议 以上所说的代码，指的是 非 Dev 分支 代码。 2.2.9 测试 测试工程师按照测试流程，以功能规格为样本，制定测试用例，执行测试。测试过程中发现的问题建立bug项。 准入准则： 开发已完成自测并提交自测报告到 TFS 工作项； 冒烟测试：功能基本流程实现符合需求； 冒烟测试：功能涉及到的参数、端口配置符合需求； 冒烟测试：无致命 Bug 比如内存泄漏、崩溃、卡死，影响系统稳定性或者影响加工安全性的问题； 注意： 发现开发质量低，列出证据，拒绝进一步测试。 准出准则： 需完善的测试用例已完善； 确认需执行的测试用例，已 100% 完成测试执行； 确认需修改的 Bug 均已回归测试通过。 如果有本次发行没有解决的内部 BUG，需要把标题的内部测试改成 BUG 维护。 提交测试记录： 第*次测试情况说明： 测试结论：（通过）/（不通过） 自动化执行结果：（通过）/（不通过）（平面发布时需填写，且执行后的的测试报告与测试日志附在 TFS 的对应工作项 ） 测试环境： 测试版本： 测试范围： 是否检查开发自测说明： 是否检查 Checklist： 测试资料是否归档：归档了写地址，未归档写待归档，不需要写不需要原因 2.2.10 分支合并 分支合并由开发工程师负责： 开发工程师根据工作项的范围，确定要合并到的插件 or 集成项目分支 判断本次合并的范围，如果合并有较高风险，需要与测试沟通，发合并任务测试 所有合并完成之后，将工作项标签中的【未合并】删除 注意： 合并的质量由开发工程师保证 2.2.11 整理文档 这一阶段功能已经测试通过，代码也已经提交；回过头去重新审视规格文档，设计文档，查找那些和代码实现不匹配的地方。主要工作： 根据代码修改设计文档，使之一致 对文档进行润色。一些模棱两可的叙述可能给今后的阅读者造成困惑，都应该做修改 明示方案的边界、局限性和缺陷 将工作项相关的文档最新版本都上传到工作项附录中 将文档整理好之后，规格文档上传三级规格，设计文档上传 Wiki 中 以功能二次开发、使用为目标，给团队中的成员做一次分享 将刀路、测试分析文档、测试用例归档到对应的库中。 3 附录 产品技术架构设计： http://172.16.1.7:9999/#!维宏研发/DesignPhase.md 长沙 Wiki 使用指南： http://172.16.1.7:85/#!ChangSha_tm/00.使用指南/Wiki使用指南.md 编制： 唐涛 审核： 批准："
  },
  "doc/研发管理制度规范/激光线软件发行规定-R3.html": {
    "href": "doc/研发管理制度规范/激光线软件发行规定-R3.html",
    "title": "激光线软件发行规定",
    "keywords": "激光线软件发行规定 版次：2021年7月2日 第3版 作者：激光加工产品部 上海维宏电子科技股份有限公司 版权所有 1 目的 为进一步提升软件质量，保证始终给前方一个稳定可靠的软件版本， 即时起激光线发布 Release 版本与 Beta 版本。 2 适用范围 适用于激光产品生命周期所有发行软件，如： V12 通用软件（通用 LH、通用 LS、通用 LA、通用 LT、通用 TB）； V12 定制软件（邦德 LH、邦德 LT、得马 LH 等）； Phoenix 通用/定制软件（LS1500， LS3000， LS3500， LS6000 等） 3 Phoenix 发行规定 3.1 软件版本命名说明： SetUp-客户缩写-产品型号-写号类型-15.主版本号.子版本号_/Beta/Release.exe 例如： SetUp-Bodor-LS6000M-LE-15.016.1_Beta/Release.exe SetUp_Gen_LS3000-LS-15.016.2_Beta/Release.exe 关于版本号： Beta 版和 Release 版软件共用，主版本号从 016 开始（016~999），子版本号从 1 开始（1~999）； 主版本号： Beta 分支每隔三个月，合并一次到 Release 分支后，主版本+1； 子版本号： 每次发行 Beta 或 Release 软件后，子版本号+1。 3.2 Beta/Release 说明 需求建立发行项发行软件（工作项注明 Beta/Release 版本） Beta/Release 测试通过后需要上传到服务器备份，并更新 Readme。 4 V12 发行规定 4.1 软件版本命名说明： Release 版本说明： 软件后缀带 Release，版本号全部为 10 整数倍； ![激光线软件发行规定-Realease 版本说明](.\\images\\激光线软件发行规定-Realease 版本说明.png) 例如： V12.1000.4_LaserHFiber5E_Release（通用 Release LH-V12.1000 版本，修复 4 个 Bug） V12.1000.4_JiNanBangDeLaserTFiber5S_Release （邦德 Release -LT-V12.1000 版本，修复 4 个 Bug） V12.1020.2_DeMaLaserHFiber5E_Release（得马 Release- LH-V12.1020 版本，修复 2 个 Bug） V12.1020.3_LaserHFiber5E_Release（通用 Release -LH-V12.1020 版本，修复 3 个 Bug） Beta 版本说明： ![激光线软件发行规定-Beta 版本说明](.\\images\\激光线软件发行规定-Beta 版本说明.png) 例如： Setup_NcEditor_V12.1001_JiNanBangDeLaserHFiber5E Setup_NcEditor_V12.1002_DeMaLaserHFiber5E Setup_NcEditor_V12.1005_LaserSFiber5E 4.2 软件发行 注意： 1：软件版本号升级到 1000； 2：Release 版本打包需要有 Release 后缀； 3：Release 版本号为三位，并注意和打包版本号区分； 4：Release 版本号为 10 的整数倍，Bate 版本跳过为 10 整数倍版本 5：Release 发行的第三位版本号根据 Bug Fix 数量确定第三位版本号，其他版本号保持一致性； 6： 需求创建 Release 分支工作项 7： Bug 修复是否合并到 Release 需在 Bug 项中说明并由开发发行 Release 验收， Bug 修复尽量提交完整变更集，以防止漏合并 5 软件放置说明 V15(Phoenix)软件放置目录： \\\\172.16.10.88\\06.NcStudio\\产品Ⅱ部\\05.激光切割\\LaserCutting(V15) V12 软件放置目录： \\\\172.16.10.88\\06.NcStudio\\产品Ⅱ部\\05.激光切割\\LaserCutting"
  },
  "doc/研发管理制度规范/研发部产品方案汇报与处理流程-R1.html": {
    "href": "doc/研发管理制度规范/研发部产品方案汇报与处理流程-R1.html",
    "title": "研发部产品方案汇报与处理流程",
    "keywords": "研发部产品方案汇报与处理流程 版次：2014年04月24日 第1版 作者：研发部 上海维宏电子科技股份有限公司 版权所有 1 目的 建立产品方案汇报机制，将各产品组中重要的开发方案集中到专家组评审，保证产品方案的合理性、及时性、可控性，同时实现通用方案共享，完善通用方案的跨产品推广部署流程。 2 适用范围 本流程适用于所有产品组及关联的职能部门，汇报范围限定为软件、硬件、机构与外观中的重要方案，以及重大BUG的解决方案，详见方案汇报的规定。 本流程适用于产品发布后的维护阶段，不适用于新产品、新项目等需要立项进行的开发提案（此部分可以参照立项流程）。 3 方案汇报 3.1 汇报原则 (1) 首先，注册、加密相关的方案必须上报，这部分涉及市场策略、定价体系以及安全性； (2) 其次，涉及用户体验的方案必须上报，这部分会涉及操作风险、维护成本、品牌认知和产品口碑； (3) 再次，重大BUG的解决方案必须上报，涉及产品质量的方案需要特别重视，并需要共享。 凡是上述情形，都需要按照约定内容写成产品方案提案，将提案邮件发送给专家组并抄送给研发经理和研发助理。约定内容可以参照汇报内容中的细分说明。 3.2 汇报对象 软件类，需要汇报给研发经理、研发副总、总经理和研发助理。 硬件类，需要汇报给硬件总工、硬件经理、研发经理、研发副总、总经理和研发助理。 机构类，需要汇报给机构组负责人、硬件总工、研发经理、研发副总、总经理和研发助理。 为方便大家发送，已在outlook收件人中建立“方案汇报联系人”组，该组包括以上汇报对象和产品组主要负责人，发送方案时如有需要可以抄送技术市场部主要负责人及对提案有帮助的人员。 3.3 汇报格式 参照“方案汇报模板”格式进行上报。如果有详细设计文档，可以作为附件一起发送。 3.4 汇报内容 3.4.1 软件界面 此部分发生下述修改情形时，需要上报产品方案，上报内容为修改原因、功能方案和测试方案。 l 与操作习惯相关的内容改动。 l 整体性UI方案，同一页面下超过50%的页面内容删除或修改、超过30%的页面色彩调整（前景色、背景色），超过30%的控件或关键控件的风格改变。 3.4.2 软件功能 此部分发生下述修改情形时，需要上报产品方案，上报内容为修改原因、功能方案和测试方案。 l 注册和加密相关。 l 通用软件（非客户定制）增加或删除功能。 l 自己拿不定的功能。 l 开发任务大于30人日的功能。 3.4.3 软件BUG 此部分发生下述BUG情形时，需要上报解决方案，上报内容为问题描述、解决措施和实施方案。 l 严重影响系统运行 的BUG。 包括但不限于：死机、系统瘫痪、重启、无法起动、黑屏、花屏、偏位等。 3.4.4 硬件设计 此部分发生下述修改情形时，需要上报产品方案，上报内容为修改原因、设计方案和测试方案。 l 注册和加密相关。 l 涉及用户使用的产品升级：包括尺寸变化，端口布局和接线方式调整，客户可见丝印的变化。 l 产品重大缺陷的修改（系统死机、花屏、偏位等）。 l 通用新模块的设计。 3.4.5 平台软件（ARM\\FPGA\\单片机\\DSP） 此部分发生下述修改情形时，需要上报产品方案，上报内容为修改原因、设计方案和测试方案。 l 注册和加密相关。 l 通用类BUG修改。 l 单个产品重大缺陷的修改。 l 通用类新功能的设计。 l 开发任务大于30人日的功能。 3.4.6 机构 此部分发生下述修改情形时，需要上报产品方案，上报内容为修改原因、设计方案和检测方案。 l 基本机械结构改动，与整体外观布局或者外形尺寸相关的较大的更改。 l 影响和其他部门对接的更改，如：板卡需要重新设计的更改、对生产装配工艺有影响的更改。 l 由于设计引起合格率、可装配率低，对此进行的改进。 l 丝印内容或者布局等较大的更改。 l 开发任务大于30人日的设计，需要上报。 l 其他应该上报的更改，具体上报与否由组长或者项目负责人来确定。 3.4.7 其他 其他不属于上面汇报内容所述但是在汇报原则之内的情形，需要上报修改原因、方案内容和和验收方案。 4 处理流程 4.1 方案备案 产品组和相关职能部门根据汇报流程的约定，将提案以邮件的形式发送给汇报对象。 方案汇报备案后，提案人可以继续进行对应内容开发工作。如果任务紧急且关键，提案人在提交提案后，应该立即向研发经理说明情况，必要时研发经理召集相关人员进行讨论确认。 4.2 审议流程 相关人员收到提案后，有责任审议方案内容，如果发现问题或有异议应该及时联系提案人确认。审议发现方案的确有问题时，提案人应该立即调整方案，并且重新备案。 审议时间应该控制在2个工作日完成，否则会影响到开发进度。 4.3 提案追踪 研发助理每周定期追踪提案的上报、审议和执行情况，每月发布提案追踪报告。 5 惩处措施 研发助理每月需要结合产品组月报、TFS工作项、市场部验证反馈信息，检查是否有应该上报的内容未按照流程上报的情形。并每月发布抽查结果。 为了保证本制度的有效执行，自发布之日起，若发现有未按流程处理的，将对主要负责人处以50-500元的罚款，具体罚款额度视实际情况而定。当遇到由于审议主要人员（明确的汇报对象）未尽责导致的问题时，将通报批评或进行50-500元的罚款。 6 说明 自本流程发布之日起，原《研发产品质量处理流程-R1》自动废止。 编制：张来迎/2014.4.28 审核：陈豫/2014.4.28 批准：郑之开/2014.4.28"
  },
  "doc/研发管理制度规范/缺陷跟踪流程-R2.html": {
    "href": "doc/研发管理制度规范/缺陷跟踪流程-R2.html",
    "title": "缺陷跟踪流程",
    "keywords": "缺陷跟踪流程 版次：2021年03月22日 第2版 文件类型：程序文件 上海维宏电子科技股份有限公司 版权所有 修改历史 文件版本 修改前文件版本 主要修订内容和原因 修订人 修订日期 R1 新建 杨银 2017.08.21 R2 R1 更新 2.2 章节的“严重级别” 余晓霞 2021.03.22 1 引言 1.1 编写目的 为规范缺陷的提交和跟踪过程，特制定此流程。 1.2 读者对象 维宏电子科技股份有限公司所有从事产品软件测试及相关人员。 1.3 引用标准 无。 2 术语/定义 2.1 缺陷术语解析 为了统一认识，此处给出公司关于测试过程中，相关术语的定义。 编号 名称 定义 1 缺陷 所谓缺陷，就是产品（包含程序、数据、文档、硬件）中不符合用户需求的问题，通常又叫 Bug 。 经过一步或多步操作后，软件实际运行结果与预期结果不符合，即定义为一个 Bug 。若已知不同 Bug 现象产生的本质原因相同可归类为一个 Bug 。 2 缺陷跟踪 从缺陷提交至缺陷关闭的整个过程的跟踪，包括缺陷提交、评估、指派、修复、验证、关闭。 3 外部缺陷 客户或销售人员在使用过程中发现的 Bug ，称之为外部缺陷或外部 Bug 。 表格 1 缺陷术语 2.2 缺陷基本属性解析 字段 解释 规则 标题 Bug 现象、存在范围的简述，如哪个客户、平台、功能，Bug 主要现象等。同时可以加入提交人（即 Bug 发现人或销售联系人）。 格式：客户名-平台名-功能名-Bug 简述-提交人 其中平台名和Bug 简述是必不可少项。客户名省略则为通用bug 。 例：深圳大宇--NK260-硬件端口-测试开测试关时无密码确认-江亲明 缺陷类别 Bug 所属类型。 1. 需求缺陷 ：由需求的获取、理解或转换导致缺陷。 2. 设计缺陷 ：需求没问题，但设计方案不足导致缺陷。 3. 编码缺陷 ：需求、方案正确，但编码出错导致缺陷。 4. 界面缺陷 ：实现界面的绘制/编码导致的缺陷。 严重级别 指该 Bug 在多大程度上影响产品的正常使用 详细内容见: Bug 严重级别处理规范 Bug 描述 记录 Bug 现象、Bug 重现步骤、期望结果、测试环境及分析建议，若 Bug 非每次出现，可补充说明出现的概率。 === 格式要求 ============== 【测试环境】 【Bug步骤】 1. /* 描述Bug重现的详细步骤，尽量保证每步仅做一个操作 /； 2.…… 【实际结果】 【预期结果】 ==== 完毕 ================ 表格 2 缺陷基本属性 3 Bug 跟踪流程 结合公司的测试过程，缺陷跟踪流程分为如下阶段： 1） 缺陷提交 2） 缺陷评估 3） 缺陷指派 4） 缺陷修复 5） 缺陷验证 6） 缺陷关闭 3.1 流程图 3.2 流程详解 3.2.1 缺陷提交 在内部测试、使用、调试、销售产品过程中，对发现的问题在指定缺陷管理系统中进行记录，以上报给相关人。 Bug 提交分为：新建 Bug 与激活已有 Bug 。 Bug 新建： Bug 在 Bug 库中不存在，则新建 Bug 。 Bug 激活： Bug 在 Bug 库中已经存在且为非活动状态，则重新激活该 Bug ，并确定是否需要关联相关任务项。 Bug 以 Bug 工作项形式提交。具体填写要求可参照具体的项目管理工具，如《TFS 工具使用指导书-Rn.doc》 一个 Bug 一个工作项。 在工作项测试过程中发现的问题，直接在当前工作项的“链接”页面新建 Bug 工作项（链接类型可以视情况选择，一般为“测试方”）；随机测试发现的 Bug ，在对应区域创建 Bug 工作项。 3.2.2 缺陷评估 提交至缺陷管理系统中的缺陷，需评定其后续的处理措施。 若为外部 Bug ，Bug 提交后由测试组长安排人员进行 Bug 重现并记录重现结果。根据重现结果由产品总工进行评估。 Bug 提交后，若为当前任务项测试出的 Bug ，由开发责任人进行评估，否则由产品总工进行评估。 经评估后，在缺陷管理系统中给出该缺陷的处理措施。 3.2.3 缺陷指派 缺陷评估后若需要进行调查、处理，则分配相应人员进入缺陷修复过程。 若为当前任务项测试出的 Bug ，则直接由当前开发负责人修复，当前测试人员进行回归，否则由产品总工指派开发负责人，测试组长指派测试负责人。 3.2.4 缺陷修复 由指派的开发责任人对缺陷进行定位分析、修复处理。 Bug 修复后开发人员需进行自测，确保缺陷得以修复。 Bug 修复后开发人员需提交原因分析及处理说明。 缺陷定位分析过程中，发现 Bug 难以修复或影响范围太大，综合 Bug 修改成本、影响程度等原因评估不处理的，重新修改 Bug 处理意见为不处理，进入缺陷关闭阶段。 缺陷定位分析过程中，发现 Bug 修改比较复杂，综合 Bug 影响程度等原因评估暂缓处理的，重新修改 Bug 处理意见为暂缓处理。 3.2.5 缺陷验证 对标记为“已修复”的 Bug 进行回归测试。 经验证，当前 Bug 不存在，且未引入新的 Bug ，则认为验证通过。 经验证，若原有 Bug 仍然存在，则激活本 Bug ； 经验证，原有 Bug 不存在，但引入了新的 Bug ，则提交新的 Bug 。 回归测试通过后，需确保 Bug 对应用例已更新至对应功能的测试用例中。 3.2.6 缺陷关闭 经分析，不需处理或已修复且验证通过的 Bug 可关闭。 不管缺陷如何处理，缺陷关闭需由测试工程师验证后关闭； 若已指派测试工程师则由当前指派的测试工程师负责，若未指派则由测试组长负责。 编制： 杨银 审核：陈豫 批准：郑之开"
  },
  "doc/研发管理制度规范/软件命名及版本方案说明-R3.html": {
    "href": "doc/研发管理制度规范/软件命名及版本方案说明-R3.html",
    "title": "软件命名及版本方案说明",
    "keywords": "软件命名及版本方案说明 版次：2018年11月28日 第3版 作者：软件部 上海维宏电子科技股份有限公司 版权所有 目前各个产品线 Phoenix 软件命名存在比较大差异，且版本号没有一个统一的标准，个别产品线组内命名也没有一个固定的规则。为了今后更好的拓展工作，需要统一规范。 1 软件命名规则 Setup- 客户名称 -[ 软件类型 - 轴数 ]- 平台版本号 . 升级版本号 _ 附加字段 .zip 示例 ：Setup-FoshanRuinuo-[SideHole-3Axes]-15.1_Alpha.zip 客户名称： 这个字段对于通用版本，可以以 Gen 代替，客户定制软件可以是客户名称全拼或简写； 软件类型： 主要是指软件的类型，例如 SideHole ，此为可选项。 轴数： 软件的轴数，例如 3Axes ，此项为可选项。 版本号： 见软件版本号规则。 附加字段： 不添加该字段默认为 Release 版，内部测试软件后面附带 Alpha 字样，内部升级可使用 Alpha1 、Alpha2 逐次累加。 2 软件版本号规则 软件平台版本号 . 升级版本号 为方便沟通与维护，软件版本号均以两个字段的数字表示，版本号之间以“.”为分割符。第一段为平台专用版本号，例如 Phoenix 平台为 V15 ，第二段为升级版本号。 示例： 小版本： 15.1 15：平台版本号，版本升级时平台版本号不作升级。 1： 对应各产品线版本升级 版本升级原则： 版本升级时，平台版本号不进行修改，只修改第二字段的值。"
  },
  "doc/研发管理制度规范/软件平台-遗留缺陷发布标准-R1.2.html": {
    "href": "doc/研发管理制度规范/软件平台-遗留缺陷发布标准-R1.2.html",
    "title": "软件平台遗留缺陷发布标准",
    "keywords": "软件平台遗留缺陷发布标准 版次：2021年11月9日 第3版 类型：技术文件 作者：祁彩云 上海维宏电子科技股份有限公司 版权所有 背景 平台迭代发布前仍有 Bug 未修改的情况，是否可以作为遗留 Bug 发布，没有比较文档化的标准可参考，不同角色对于发布标准不够一致，引起内部发现的问题，由于概率低、赶时间等各种原因发布，后续产品线或者在客户端重现类似问题，造成比较低的客户满意度。 目的 明确软件发布的标准并且文档化，即什么样的缺陷可以作为遗留缺陷，迭代可以允许暂不修改发布，统一标准，避免无效沟通和不合理的决议。 遗留缺陷分析 迭代负责人需在第一个集成版本测试完毕后对未修改缺陷进行收集整理，沟通跟踪缺陷修复的进度及计划组织遗留缺陷评审。评审人必须包括测试主管、开发总工、其它小组开发&测试负责人。 进行遗留缺陷需要从以下几个角度进行分析： 1）缺陷风险程度 缺陷的风险程度高低是决定缺陷是否修改的先决条件，受三个因素影响。 一是缺陷的严重程度，即缺陷在用户环境出现后对于客户的影响程度。严重程度根据当前TFS定义的等级，分为致命、严重、一般、轻微/建议。 二是缺陷产生的概率。缺陷产生概率分为：有条件必现，有条件概率必现，无规律复现，无法重现。 三是缺陷相应功能的使用频率。功能使用频率分为：每天使用多次，每周使用多次，较少使用，基本不使用。 综合三个因素，缺陷的风险评估按照以下优先级考虑。严重程度>功能使用频率>重现概率。基本原则如下： 严重程度若为致命等级，无论重现概率和功能使用情况如何，风险程度高。 严重程度若为严重等级，重现概率除无法重现，功能使用频率除基本不使用外，风险程度高。 严重程度若为一般等级，重现概率为有条件必现，功能使用频率为每天使用多次，风险程度高。 若严重程度为轻微和建议性，无论重现概率和使用频率如何，风险程度统一为低。 其它具体情况可以参考以下组合。 风险程度 严重程度 重现概率 功能使用频率 中 严重 无法重现 较少使用 低 严重 无法重现 基本不使用 中 一般 有条件概率必现 每周使用多次 中 一般 无规律复现 每天使用多次 中 一般 无法重现 每天使用多次 中 一般 无法重现 每周使用多次 2）缺陷发生概率 缺陷发生概率，也叫缺陷重现概率，是指缺陷在测试环境或者模拟真实用户的环境中发生的概率。可以分为以下几类。 缺陷发生概率 定义和描述 有条件必然重现 缺陷在相应的环境，符合相应的条件必然重现。 有条件概率重现 缺陷在测试环境中不会每次都出现，但按照一些特定的操作出现的概率很大。 无规律重现 不知道可以复现这些缺陷的条件，但是这个缺陷却可以在测试环境中无规律地出现。 无法重现 不知道可以复现这些缺陷的条件，并且这个缺陷无法出现。 3）缺陷暂不修改原因 缺陷可能由于项目的时间进度、人员能力和技术经验以及修改成本和风险等原因暂不修改，该原因将会影响缺陷是否会在本次发布修复。 4）缺陷规避措施 对于有一定风险的缺陷，以及存在合理的暂不修改的原因，需要制定缺陷的规避措施，以降低因不修改造成的影响程度。比如，提供了可以代替的功能可以规避此问题；在系统配置上做了限制，避免用户触发或者小概率触发；系统给出友好明确的提示降低不好的用户体验感诸如此类。 5）缺陷过往出现情况 缺陷在不同版本以类似形态出现的情况，如在以往版本出现过，后续版本不能够复现，再后续又有版本复现过，此类问题需要重视，对于定位风险程度有一定程度的影响。 发布标准 在确定遗留缺陷的过程中，不同人对于缺陷遗留的标准因为认知、角度、角色的不同存在很大的偏差，明确以下标准供发布作为参考，如存在冲突，则提升到上级进行评审决议。 风险程度 规避措施 暂不修改原因（总工评审后） 发布/处理方法 高 无 人员能力和技术经验不足 不可发布，提交上级评审 高 无 时间成本高 不可发布，提交上级评审 高 无 修改风险高 不可发布，提交上级评审 高 有 时间成本高 可临时方案发布，需跟踪新方案 高 有 修改风险高 可临时方案发布，需跟踪新方案 中 无 人员能力和技术经验不足 不可发布，提交上级评审 中 无 时间成本高 不可发布，提交上级评审 中 无 修改风险高 不可发布，提交上级评审 中 有 时间成本高 可临时方案发布，需跟踪新方案 中 有 修改风险高 可临时方案发布，需跟踪新方案 低 无/有 合理原因 可遗留发布 遗留Bug评审 遗留Bug需要通过相关人员的评审，总工，责任开发，责任测试，质量主管必须参与评审，针对产品线的需求或者新增问题评估到可能会影响到其他产品线的情况，还需要邀请产品线责任人参与，团队评审通过方可进行遗留。 修改记录 序号 版本 修订人 日期 描述 1 1.0 祁彩云 2020年6月10日 初版建立 2 1.1 祁彩云 2020年6月11日 内部评审修改 3 1.2 祁彩云 2021年11月9日 内部修改"
  },
  "doc/研发管理制度规范/软件测试需求分解指导书-R2.html": {
    "href": "doc/研发管理制度规范/软件测试需求分解指导书-R2.html",
    "title": "软件测试需求分解指导书",
    "keywords": "软件测试需求分解指导书 版次：2015年10月27日 第1版 文件类型：技术文件 上海维宏电子科技股份有限公司 版权所有 修改历史 文件版本 修改前文件版本 主要修订内容和原因 修订人 修订日期 R1 新建 汪腾霞 2015.10.27 R2 R1 增加章节 2 汪腾霞 2017.09. 01 本文主要是从黑盒测试的层面进行指导。 根据软件的定义，软件包括程序、数据、文档，故软件测试即程序、数据、文档的测试。 1 需求获取 接到测试任务后可以从以下途径获取、理解需求： 工作项任务信息； 开发需求分析或设计文档； 与开发人员沟通； 提出需求的销售人员或最终客户。 沟通的方式有很多种，根据情况选择，目的是正确、清晰的理解 用户需求 的本质（而非客户需求）， 即该需求是为解决什么生产问题而产生的 ；同时尽量降低沟通成本。 2 需求确认 用户需求是否被正确描述，并转化为恰当的开发设计需求，可以从以下方面去分析、评估： 需求的清晰性、完备性、正确性； 需求的一致性； 需求的可行性、易测试性； 需求的兼容性； 需求的健壮性。 【特别说明】 1) 需求是否具有可测试性，需要测试人员结合自身的经验和理解进行审核评估。 2) 不可测试的需求不能成为一个需求。 3 需求分类 在了解任务需求时，可从以下几个方面去分解测试需求，进行测试计划和测试设计。 功能需求 （如上下料功能、排转功能） 易用性需求 （如界面、提示信息、说明性文档） 效率需求 （如页面刷新速度、按钮响应时间、刀路加载时长、刀路加工效率） 兼容性需求 （如前后版本兼容、格式兼容、硬件环境兼容、软件环境兼容） 可靠性需求 （如长时间运行，表现的一种性） 安全性需求 （此项属于功能需求的一部分，但是为了特别凸显强调，特单独提出，如权限控制安全性、操作安全性） 4 需求细化 所有需求都有显式和隐式之分，显式即被明确提出的，隐式即暗含的、默认的、常识性的。测试中要特别注意隐式需求的挖掘。 以下就测试中可进一步做需求分解的点进行说明。 4.1 功能需求 功能需求测试包括业务流程测试和功能点测试，一般都需要进行正面测试和负面测试。 正面测试就是测试系统是否完成了它应该完成的工作；负面测试就是测试系统是否不执行它不应该完成的操作。比如： 功能入口 控制有效； 正常状态 下，功能实现正确； 各 异常状态 下，功能表现可接受，具有可恢复性或容错性； 功能相关的 参数输入检查 合理，比如刀库容量参数应该是一个正整数，若允许输入负数或小数则算是 Bug； 功能相关的 端口控制 正确； 实际表现与操作提示一致； 多次重复操作， 功能表现的一致性 与相关功能 交互操作 后，表现正确性。比如清零动作会自动修改工件偏置，但是若进行清零动作后就不能手动修改工件偏置或手动设置成功但不作用于工件坐标的计算，则属于 Bug，任何时候手动修改工件偏置都应该能正确作用于工件坐标的计算。 4.2 易用性需求 易用性包括三部分，按主次依次为：产品执行用户所需的功能；快速安全的执行该功能；易于理解、方便使用。 主要考虑界面接口、辅助图示或说明文档，使用户易学、易操作。比如做界面测试时： 界面元素要符合通用标准 。一般认为在 Windows 上运行的软件要符合微软公司提供的一套界面设计规范，比如颜色、风格、位置、大小、语言一致，避免各界面之间存在较强的逻辑关系。如果不符合，则认为是 Bug 。 界面尺寸的改变。 如控件是否需要成比例缩放、位置是否会重新排列、界面刷新是否正常等。 操作系统层次上的不同外观设置。 考虑软件是否适应不同的外观设置。 不同分辨率。 因为硬件条件或个人喜好，软件在不同分辨率下显示是否完整。 焦点的设置。 每个界面都有焦点设置，默认焦点是否合适，执行功能操作后，焦点变化是否正确，焦点跳变顺序（Tab）是否正确。 对静态文本、图片或动画的检查。 比如文字不能有错别字、语法错误，不能有违反法律的文字或图片存在； 快捷。 常用操作是否快捷比如提供快捷键、入口显示在主界面或可立即生效的参数就不应该设为重启后生效； 醒目。 重点关注点或异常情况是否醒目显示。 4.3 效率需求 效率测试要监控如下指标：响应时间、吞吐量、CPU 占用率、占用内存数和内存占用率，比如： 一次按键、操作的及时响应能力； 反复按键、操作响应能力的一致性； 界面一次、反复刷新显示的流畅性、及时性； 高负载下，操作表现的一致性，比如程序文件列表下文件很多与无文件时刷新界面； 存在并发访问或并发操作时的负载能力测试，比如同时访问一台机器上的共享文件； 存在检索操作时的及时响应能力比如选刀加工、选择加工。 4.4 兼容性需求 功能所依赖的运行环境（硬件或软件）可变、可选择时，需考虑不同环境配置时，功能表现的一致性如安装功能； 需要进行数据编辑或会产生数据时，需考虑同类软件数据的兼容性、新旧版本数据的兼容性； 与其他常用应用软件、工具同时工作时，是否产生不兼容的情况。 4.5 可靠性需求 一般做系统测试或新增功能测试时需要考虑 多次重复同一操作，监测是否存在占用资源未释放，比如监控内存的递增情况、图片资源 GDI 对象、句柄数 Handle Count 、CPU 利用率等； 加重负载（大量数据的处理），观察系统运行的稳定性和可恢复性，比如加载一个比较大的文件，查看系统是否能加载，加载完成后是否可继续进行其他操作； 多个功能交互使用时，功能实现的稳定性； 长时间运行，系统的稳定性。 4.6 安全性需求 安全性主要指权限的控制以及破坏性操作的安全防护能力。一般可能存在危害人身安全、损害用户财产的操作都需要考虑安全性。 对于权限控制上又分不同的安全级别，如一次性授权、重启软件前的永久授权或注册后的完全授权等。比如： 参数是否根据安全性分级，对其访问、修改权限限制； 端口修改设置是否安全性考虑； 权限控制的安全级别是否恰当； 是否存在安全性漏洞，比如权限校验被非预期注销、加密方式被破解； 可能损害数据、设备的操作是否存在确认操作； 正常操作时，安全性检测设置是否恰当比如多Z轴联动，超行程检测； 异常情况下，是否存在安全预防能力比如换刀时，刀库门没打开，是否终止换刀。"
  },
  "doc/研发管理制度规范/软件编程规范-R5.html": {
    "href": "doc/研发管理制度规范/软件编程规范-R5.html",
    "title": "软件编程规范",
    "keywords": "软件编程规范 版次：2020年11月28日 第5版 类型：程序文件 部门：软件部 上海维宏电子科技股份有限公司 版权所有 1 目的 编写本规范的目的是为了统一公司软件编程风格，提高软件代码的可读性、可维护性，从而提高软件的质量。 现代软件架构的复杂性需要协同开发完成，如何高效地协同呢？无规矩不成方圆，无规范难以协同，比如，制订交通法规表面上是要限制行车权，实际上是保障公众的人身安全，试想如果没有限速，没有红绿灯，谁还敢上路行驶？对软件来说，适当的规范和标准绝不是消灭代码内容的创造性、优雅性，而是限制过度个性化，以一种普遍认可的统一方式一起做事，提升协作效率，降低沟通成本。代码的字里行间流淌的是软件系统的血液，质量的提升是尽可能少踩坑，杜绝踩重复的坑，切实提升系统稳定性，提高质量。 ​ --摘自阿里的《java开发手册》泰山版 2 适用范围 本规范适用于公司所有产品的软件代码。自本规范实施之日起，以后新编写或修改的代码均应执行本规范。 3 术语和定义 下列术语和定义适用于本规范。 规则： 编程时必须遵守的约定。 原则： 编程时指导性的约定。 说明： 对此规则或原则的必要解释。 正例： 对此规则或原则给出的正确例子。 反例： 对此规则或原则给出的反面例子。 例外 ： 对此规则或原则给出例外的说明。 Pascal命名法： 将标识符的首字母和后面连接的每个单词的首字母都大写。可以对三字符或更多字符的标识符使用Pascal 大小写。 例如： BackColor Camel命名法： 标识符的首字母小写，而每个后面连接的单词的首字母都大写。 例如：backColor 代码片段： 在代码区域出现中括号中带中文字的及符号…， 如：[代码片段]或…， 则一般表示代码片段。 4 基本原则 如何写出一份高质量的代码呢？ 高质量的代码具有以下的特点： 可读性高 可维护性 可扩展性 可读性高：代码的写法应当使别人理解它所需要的时间最小化。 相对于追求最小化代码行数，更好的提高可读性的方法是：最小化人们理解代码所需要的时间。 可维护性高：功能或系统出现问题后， 能恢复正常功能所需要的时间最小化。包括对问题的诊断、定位、修复所花的时间。 可扩展性高：当出现需求变更时， 能响应需求实现所需要的时间最小化。 那如何做到高质量的代码呢？高质量的代码一定是整洁的，整洁是好代码的必要条件。整洁的代码一定是高内聚低耦合的，也一定是可读性强、易维护的。 高内聚低耦合 高内聚低耦合是从事编程来一直的要求， 但过于宽泛； 一般的编程设计原则中： DRY(Don't Repeat Yourself) ：编程过程中不写重复代码。 KISS(Keep It Simple,Stupid) ：让代码简单直接。不过早优化代码， 不过度设计， 不复杂化代码。 而面向对象设计原则中更是提出了SOLID设计原则，即： 单一职责原则 SRP (Single Responsibility Principle) 开放封闭原则 OCP (The Open-Close Principle) 里氏替换原则 LSP (Liskov Substitution Principle) 接口隔离原则 ISP (Interface Segregation Principle) 依赖倒置原则 DIP (Dependence Inversion Principle) 可读性 具体如何让代码易读？主要体现在下面三个层次： 表层上的改进：在命名方法（变量名，方法名），变量声明，代码格式，注释等方面的改进。 控制流和逻辑的改进：在控制流，逻辑表达式上让代码变得更容易理解。 结构上的改进：善于抽取逻辑，借助自然语言的描述来改善代码。 避免代码的坏味道（Code Smells） “代码的坏味道”是来自 Martin Fowler 所著《重构 改善既有代码的设计》。 以下着重列举重点： 重复代码 ： ​ Martin Fowler 也认为坏味道中首当其冲的就是重复代码。 ​ 很多时候，当我们消除了重复代码之后，发现代码就已经比原来整洁多了。 函数过长、类过大、参数过长 ： ​ 过长的函数解释能力、共享能力、选择能力都较差，也不易维护。 ​ 过大的类代表了类做了很多事情，也常常有过多的重复代码。 ​ 参数过长，不易理解，调用时也容易出错。 发散式变化、霰弹式修改、依恋情结 ： ​ 如果一个类不是单一职责的，则不同的变化可能都需要修改这个类，说明存在发散式变化，应考虑将不同的变化分离开。 如果某个变化需要修改多个类的方法，则说明存在霰弹式修改，应考虑将这些需要修改的方法放入同一个类。 如果函数对于某个类的兴趣高于了自己所处的类，说明存在依恋情结，应考虑将函数转移到他应有的类中。 数据泥团 ： 有时候会发现三四个相同的字段，在多个类和函数中均出现，这时候说明有必要给这一组字段建立一个类，将其封装起来。 【原则 0-1】 尽可能避免重新造轮子。 说明 ：选择可复用的代码，对其修改优化以达到自身要求。 【原则 0-2】 开发人员对自己编写以及修改的代码必须做到单步调试，调试的要求是需要做到路径覆盖，并跟踪每一条语句。 说明 ：罕见路径一般很少执行，所以要优先调试，特别是出错处理代码一般在调试过程中很容易被忽略，而且往往正常情况下很难触发，所以调试时必须首先对出错处理代码做到单步调试，此时可以通过修改内存值或是外部变量的方式触发出错处理代码进行调试。 ​ 对于代码语句，要求监控内部变量、数据的初始值，同时对于每个边界都要单步调试。 ​ 对于条件语句，要求每个分支、每个退出条件都必须单步调试到。 ​ 对于循环语句，要求循环的边界、中间退出条件（有 break 或 continue 时）、正常执行逻辑都必须单步调试到。 ​ 调试时需要监控每个变量、执行数据以及动作的变化，监控其行为是否与预期一致。 ​ 对于对象变量，除监控其本身变量外，还需要监控其内部数据的变化，如果有多级继承和派生时，必要时还需要逐一展开监控，关注其内存布局的变化或是对象对齐等问题。 ​ 对于 C++ , 涉及 STL 中的代码，需要对常用的 List 、vector 的内存布局理解清晰，便于调试代码时监控其存储值的变化。调试时可能会涉及人为修改变量使其进入期望调试代码段的情况，此时可以使用重置代码段 PC 指针的方式提高代码调试的效果。 【原则 0-3】 以代码仓库为单位， 保证与原有的代码风格的一致性。 代码仓库是 Git 代码管理中的代码存储单位，也可以等同理解为解决方案（微软定义的 sln）。一般以存储文件目录为单位。 5 编程规范 编程规范主要可以分为两大类：风格类与编程实践类。 风格类规范包括标识符的命名、布局以及注释风格等。此类规范引导开发团队使用统一的代码风格进行开发。一致的编码习惯与风格，会使代码更容易阅读、理解，也更容易维护。需要注意的是，对于开源项目，如果在代码风格类上有冲突，原则上遵从开源项目原本的代码风格要求。 编程实践类包含编程语言特性相关的条款，比如 OOP 规范、函数、表达式与语句、变量、常量与数据类型的使用、以及错误处理等。 本章分为 9 小节（5.1~5.9）， 小节内的内容适合所有语言， 小节的下级节点为各语言的规范； 若有冲突， 请以各语言的规范为准。 如命名章节中【规则 1-4】与【规则 1-1-1】冲突， 以【规则 1-1-1】为准。 5.1 命名 好的命名规则能极大地增加可读性和可维护性。同时，对于团队项目来说，统一命名约定也是一项必不可少的内容。 好的命名具有如下几个特点： 名副其实 避免误导 做有意义的区分 使用读的出来的名称 使用可搜索的名称 添加有意义的语境 ​ 摘自 《代码整洁之道》 【规则 1-1】 标识符要采用英文单词或其组合，便于记忆和阅读，切忌使用汉语拼音来命名（客户名称相关除外）。 说明 ：标识符应当直观且可以拼读，可望文知义，避免使人产生误解。程序中的英文单词一般不要太复杂，用词应当准确。考虑到软件中有客户定制的情况，为便于识别，客户相关的名称可以使用汉语拼音命名；除非必要，不要用数字或无明确指向意义的字符来定义标识符。 例外 ：习惯用法中的短生命周期的临时变量可以不遵守该规则， 如迭代过程中的临时变量。 正例 ： for (int i = 0; i < fileNum; i++) { [代码片段] } 正例 ：Weihong, LabelTaskLoader 反例 ：wh, BiaoqianRenwu(标签任务), 标签任务 【规则 1-2】 杜绝完全不规范的缩写，避免望文不知义。 反例 ：AbstractClass “缩写”命名成 AbsClass；condition “缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。 【规则 1-3】 命名空间、类名、方法名使用Pascal命名法。 正例 ：Weihong, LabelTaskLoader 反例 ：wh, BiaoqianRenwu(标签任务), 标签任务 【规则 1-4】 参数名、成员变量、局部变量都统一使用 Camel 命名法。 正例 ：taskListManager, labelTaskLoader 【规则 1-5】 不要使用大小写区分不同的命名标识。 说明 ：通过大小写来区分标识， 很容易让人记忆负担。 例外 ：C# 中属性与成员变量之间可以按照习惯用法。 如属性 BackColor 往往对应成员变量 backColor。 【规则 1-6】 抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类 命名使用 Test_开头, 以它要测试的类的名称结尾。 【规则 1-7】 避免在子父类的成员变量之间、 或者不同代码块的局部变量之间采用完全相同的命名， 使可读性降低。 说明 ：子类、父类成员变量名相同，即使是 public 类型的变量也是能够通过编译，而局部变量在同一方法 内的不同代码块中同名也是合法的，但是要避免使用。 反例 ： public class ConfusingName { private int stock; public void get(String value) { if (condition) { int money = 666; // ... } for (int i = 0; i < 10; i++) { // 在同一方法体中，不允许与其它代码块中的 money 命名相同 int money = 15978; // ... } } } public class Son ： ConfusingName { // 不允许与父类的成员变量名称相同 private int stock; } 【原则 1-8】 在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度。 正例 ：startTime / workQueue / nameList / TERMINATED_THREAD_COUNT 反例 ：startedAt / QueueOfWork / listName / COUNT_TERMINATED_THREAD 【原则 1-9】 如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。 说明 ：将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。 正例 ： public class OrderFactory; public class LoginProxy; public class ResourceObserver; 5.1.1 C++ 【规则 1-1-1】 变量名称采用匈牙利命名法，即：完整的名称由“缀”和“主体”复合而成。“缀”用于指示变量的种类、数值类型、作用域等属性，由小写字符和下划线（_）组成，根据其附着在“主体”的位置分为前缀和后缀两种。“主体”表示变量的语义。 说明 ：整个变量名称格式：<作用域前缀>[<指针缀>]<类型缀><主体><作用域后缀> 【规则 1-1-2】 使用一致的前缀来区分变量的作用域。 说明 ： 变量作用域前缀规范如下： 前缀 说明 g_ 全局变量、常量 m_ 类成员变量 s_ 模块内静态变量 _（前缀） 局部变量 _（后缀） 形式参数 【规则 1-1-3】 使用一致的小写类型指示符作为前缀来区分变量的类型。 说明 ：类型缀由小写字符构成，用于描述变量的类型。 常用变量类型前缀列表如下： 类型前缀 说明 n 用于一般情况下的各种整数、浮点数、枚举类型，包括：(unsigned int), (unsigned long)，和一些派生类型：UINT，ULONG，WORD，DWORD 等 b bool 类型 p 表示指针。 h Windows API 内部的各种 HANDLE c char 或者 TCHAR 类型的字符 sz char 或者TCHAR 类型的数组或者字符串常量 str CString/std::string clr COLORREF，其它用来表示颜色的数值类型 以上前缀可以进一步组合，在进行组合时，数组和指针类型的前缀指示符必须放在变量类型前缀的首位。 正例 ： char g_szFileName[_MAX_PATH] = {0}; // 全局字符串变量 char* g_pszFileName = NULL; // 全局字符串指针变量： static char s_szFileName[_MAX_PATH]; // 静态字符串变量 static char* s_pszFileName = NULL; // 静态字符串指针变量： static char _s_szFileName[_MAX_PATH] = {0};//局部静态字符串变量 static char* _s_pszFileName = NULL; //局部静态字符串指针变量： char m_szFileName[_MAX_PATH] = {0}; // 类字符串变量 char* m_pszFileName = NULL; // 类字符串指针变量： static char ms_szFileName[_MAX_PATH] = {0};//类静态字符串变量 static char* ms_pszFileName = NULL; // 类静态字符串指针变量： TCHAR _szTempDir[MAX_PATH] = {0}; 对于其他不在上面表中的结构、类等复杂数据类型，特别是不常使用的和不通用的，按其作用域以及使用场景加前缀。例如： CPerson _Jonson; // 局部变量 CPerson Jonson_; // 函数形参 struct DateTime _DateTime; 函数的参数变量要求由后下划线结尾（见变量作用域前缀一节）。在一些纯数学函数中，也可省去数值类型前缀n，其它类型前缀不能省略。例如： bool Create(PCTSTR pszPathName_); double Add(double a_, double b_); // 值类型前缀省略 局部变量由前下划线开头。在纯数学函数中，简短的上下文中，或是变量的声明周期较短的情况下，也可省去数值类型前缀n和下划线(_)，其它类型前缀不能省略。例如： bool _bRet = false; char _szBuffer[_MAX_PATH] = {0}; // 下面是一些值类型前缀省略的例子 int temp; // 常表示生命周期较短的变量 for (int i = 0; i < _countof(_szBuffer); i++) { float a; // a的作用域很短 } 全局变量使用作用域前缀’g_’。全局变量因为作用域很大，所以命名一定要规范。名称的主体部分必须能清晰说明变量的意义。例如： CWinApp g_Application; int g_nVersion; HINSTANCE g_hInstance; 静态变量使用作用域前缀’s_’。 局部静态变量使用前缀'_s_’。例如： static CNcWinApp s_App; static int s_nVersion = 0; static HINSTANCE s_hInst; void Func() { static int _s_nCallTimes = 0; } 其他例子： extern HINSTANCE g_hInst; //全局变量 static int s_nTimer = 0; //全局静态变量 int Func(int nCounter_, int* pnSize_) //参数变量 { //局部变量 long _nTotalItem = 0; static long _s_nCount = 0; int _nVar = 0; LPSTR _pszBuffer = _T(\"\"); TCHAR _szCache[_MAX_PATH] = {0}; } 【规则 1-1-4】 结构命名：结构成员服从一般变量命名法则。 正例 ： struct DateTime { int nYear; int nMonth; int nDay; int nHour; int nMinite; int nSecond; }; 反例 ： 本规范不采用对结构成员使用表示结构的前缀。如： struct DateTime { int dtYear; int dtMonth; int dtDay; int dtHour; int dtMinite; int dtSecond; }; 【规则 1-1-5】 enum 类型，枚举值应全部大写，单词间以下划线相连。 正例 ： enum dblz_t { DBLZ_NA = -1, DBLZ_Z1, DBLZ_Z2, DBLZ_Z1Z2, }; 【规则 1-1-6】 宏都要使用大写字母, 用下划线‘_’分割单词。 正例 ： 如 DISP_BUF_SIZE、MIN_VALUE、MAX_VALUE 等等。 说明： #define 定义的常数要求用大写字母和下划线混合命名，但是并不强制要求在每个单词之间插入下划线。 #define LEFT 0 //推荐 #define RIGHT 1 //推荐 #define UP_DOWN 1 //推荐 反例 ： #define Right 1 //不推荐 5.2 布局 程序布局的目的是显示出程序良好的逻辑结构，提高程序的可读性、可维护性。更重要的是，统一的程序布局和编程风格，有助于提高整个项目的开发质量，提高开发效率，降低开发成本。程序员养成良好的编程习惯有助于提高自己的编程水平，提高编程效率。统一的、良好的程序布局和编程风格既是体现个人主观美学上的形式，也涉及到产品质量、个人编程能力的提高，应重视程序布局。 【规则 2-1】 长表达式要在低优先级操作符处拆分成新行，操作符放在新行之首（以便突出操作符）。拆分出的新行要进行缩进（以制表符缩进），使排版整齐。 说明 ：条件表达式的续行在第一个条件处对齐。for 循环语句的续行在初始化条件语句处对齐。函数调用和函数声明的续行在第一个参数处对齐。赋值语句的续行应在赋值号处对齐。 正例 ： // 条件表达式的续行缩进 if ((long_condiction_statement) && (long_condiction_statement) && (long_condiction_statement)) { DoSomething(); } // for循环语句续行缩进 for (long_initialization_statement; long_condiction_statement; long_update_statement) { DoSomething(); } // 函数声明的续行缩进 public MemberAccessor(object instance, PathItem pathItem, string phoenixPre) // 赋值语句的续行应缩进 totalBill = totalBill + customerPurchases[id] + salesTax(customerPurchases[id]); 【规则 2-2】 在 switch 语句中，每个case分支需要有结束标志 break 或者 return ，如果有不满足 case 枚举条件的值，需要包含一个default。 说明 ：在 switch 语句中，每一个 case 分支和 default 要用{ }括起来，{ }中的内容需要缩进，若是 break ，要放在{ }外，这样可以使程序可读性更好，也可以定义局部变量。有时候 case 分支中的语句较少时，可以不使用{}，但是推荐使用{}。对于多个分支相同处理的情况可以共用一个 break ，但是要用注释加以说明。 正例 ： switch (code) { case 1: { // 缩进 DoSomething1(); } break; case 2: { // 每一个case分支和default要用{}括起来 DoOtherThing(); } break; …// 其它case分支 default: DoSomething2(); break; } 【规则 2-3】 if、else、else if、for、while 等逻辑分支语句自占一行，执行语句不得紧跟其后。 说明 ：这样可以防止书写失误，也易于阅读。 正例 ： if (maxNum < currentValue) { maxNum = currentValue; } 反例 ： 下面的代码执行语句紧跟 if 的条件之后，而且没有加{}，违反规则。 if (maxNum < currentValue) maxNum = currentValue; 【规则 2-4】 代码中关系较为紧密的代码应尽可能相邻。 说明 ：这样便于程序阅读和查找。 正例 ： // 矩形的长与宽关系较密切，放在一起。 length = 10; width = 5; 反例 ： length = 10; ... ... // 中间又做了很多其他的处理 width = 5; 【规则 2-5】 不同逻辑程序块之间要使用空行分隔。 说明 ：空行起着分隔程序段落的作用。适当的空行可以使程序的布局更加清晰。函数后要有空行；for 循环后要有空行；if语句后要有空行；switch 中每个 case 处理后要有空行。 正例 ： void Hey() { [Hey实现代码] } // 空一行~~~~ void Edit() { [Edit实现代码] } 反例 ： void Hey() { [Hey实现代码] } void Edit() { [Edit实现代码] } // 两个函数的实现是两个逻辑程序块，应该用空行加以分隔。 【规则 2-6】 多元运算符和它们的操作数之间需要一个空格。 正例 ： value = oldValue; total + value; number += 2; 【规则 2-7】 代码使用制表符缩进，制表符宽度为4。 说明 ：消除不同编辑器对TAB处理的差异，有的代码编辑器可以设置用空格代替 TAB 键。 【规则 2-8】 结构型的数组、多维的数组如果在定义时初始化，按照数组的矩阵结构分行书写。 正例 （C++）1： int numbers[4][3] = { 1, 1, 1, 2, 4, 8, 3, 9, 27, 4, 16, 64 }; int numbers[4][3] = { {1, 1, 1}, {2, 4, 8}, {3, 9, 27}, {4, 16, 64} }; 正例 (C#)2： int [,] a = new int [3,4] { {0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11} }; 【规则 2-9】 单个预处理指令从行首开始，不要缩进，但如是嵌套预处理指令，最外层的预处理指令不缩进，内部其他语句需缩进。 说明 ：即使预处理指令位于缩进代码块中，指令也应从行首开始。这样做的目的主要是为了很方便区分出预处理语句。 **正例 **1： if (isCorrect) { #if DISASTER_PENDING // 正确 DropEverything(); #endif BackToNormal(); } **正例 **2： if (isCorrect) { #if DISASTER_PENDING // 正确 #if _DEBUG ... #else DropEverything(); #endif #endif BackToNormal(); } 反例 ： if (lopsided_score) { #if DISASTER_PENDING // 错误! DropEverything(); #endif // 错误! BackToNormal(); } 5.3 注释 注释对保证代码可读性至为重要，下面的规则描述了应该注释什么、注释在哪儿。当然也要记住，注释的确很重要，但最好的代码本身就是文档，类型和变量命名意义明确要比通过注释解释模糊的命名好得多。注释是为别人（下一个需要理解你的代码的人）而写的，为了便于自己和别人快速理解代码，所以一定要认真对待。 有效的注释是指在代码的功能、意图层次上进行注释，提供有用、额外的信息，而不是代码表面意义的简单重复 。 【规则 3-1】 一般情况下，代码中有效注释量不少于代码量的 20% ，最低不得少于代码量的 10% 。 说明 ：注释的原则是有助于对程序的阅读理解，注释不宜太多也不能太少，注释语言必须准确、易懂、简洁。有效的注释是指在代码的功能、意图层次上进行注释，提供有用、额外的信息。 【规则 3-2】 注释使用中文。 说明 ：对于特殊要求的可以使用英文注释，如工具不支持中文或国际化版本时。 【原则 3-3】 别给糟糕的代码加注释，重构他。 说明： 注释不能美化糟糕的代码。当企图使用注释前，先考虑是否可以通过调整结构，命名等操作，消除写注释的必要，往往这样做之后注释就多余了。 【规则 3-4】 注释应当提供信息、表达意图、阐释、警告。 说明： 注释不能美化糟糕的代码。当企图使用注释前，先考虑是否可以通过调整结构，命名等操作，消除写注释的必要，往往这样做之后注释就多余了。 正例 ： // 仅计算一次，因为它很耗性能 if (computed) { return; } 正例 ： // 必须创建新的Foo实例，因为单例Foo是不安全的 return new Foo() 正例 ： // 请注意，顺序很重要，因为... Wash(); Brush(); 【原则 3-5】 若当前代码存在局限性， 注释说明后续的改善点。 正例 ： /// <summary> /// 找到路径最短标注 /// </summary> /// <param name=\"list\">标签列表</param> private void SetLabelIndex(List<LabelInfo> labelInfoList) { // 目前根据初始值置序号，不是最优效率； 后续可以考虑优化， 获取最短路径, 标注LabelIndex int i = 1; foreach (var item in labelInfoList) { item.LabelIndex = i; i++; } } 【规则 3-6】 签入主干的代码不能存在临时的调试代码以及大段被注释掉的代码。 说明 ：调试代码从排版、注释上（比如临时的调试代码可以采用首行对齐的方式，而不是缩进的方式）注意需要明确区分，这样在做清理时，可以快速识别。 在代码签入主干时需要删除大段被注释的代码，如果需要事后查看，可以通过源代码版本进行比对。 【规则 3-7】 代码和注释要同步维护，不再有用的注释及时删除，特别是错误的注释一定要删除。 说明： 注释的内容要清晰明了，含义准确，防止注释二义性。错误的注释不但无益反而有害。 【规则 3-8】 注释的内容不要重复代码。 说明： 写实现注释时需要记住的最重要的一点就是，描述代码是做什么的（what）和为什么这么做（why），而不是描述怎么做（how）。因为实现代码本身就是 how 。 代码永远是主体。通过对函数或过程、变量、结构等正确的命名以及合理地组织代码结构，使代码成为自注释的。清晰准确的函数、变量命名，可增加代码的可读性，减少不必要的注释。 提倡大段的功能性的注释，只要把实现的主要思想和流程写清楚就可以，没有必要每一句都加上注释。大段的功能性的注释更有利于对功能的理解。 【规则 3-9】 注释应与其描述的代码相近，对代码的注释可放在其上方位置，需与其上面的代码用空行隔开；也可与代码同行，但不可放在代码的下方。 说明：在使用缩写时之前，应对缩写进行必要的说明。 正例 ： 如下书写比较结构清晰 // 获得子系统索引 _nSubSysIndex = _nData[_nIndex].nSysIndex; // 代码段1注释 [ 代码段1 ] // 代码段2注释 [ 代码段2 ] int _nVar = 5; // 注释 反例 1： 如下例子注释与描述的代码相隔太远。 // 获得子系统索引 _nSubSysIndex = _nData[_nIndex].nSysIndex; **反例 **2： 如下例子注释不应放在所描述的代码下面。 nSubSysIndex = _nData[_nIndex].nSysIndex; // 获得子系统索引 **反例 **3： 如下例子，显得代码与注释过于紧凑。 // 代码段1注释 [ 一行代码1 ] // 代码段2注释 [ 一行代码2 ] 【规则 3-10】 注释与所描述内容进行同样的缩进。 说明 ：可使程序排版整齐，并方便注释的阅读与理解。 正例 ： 如下注释结构比较清晰。 int DoSomething() { // 代码段1注释 [ 代码段1 ] // 代码段2注释 [ 代码段2 ] } 反例 ： 如下例子，排版不整齐，阅读不方便； int DoSomething() { // 代码段1注释 [ 代码段1 ] // 代码段2注释 [ 代码段2 ] } 【原则 3-11】 维护已有代码时， 注释时要写上作者姓名和日期。（名字一律写全拼或汉字，不要写英文名字或代号缩写）。 说明 ：拷贝或移植的代码要特别注意，不要将原始代码的作者也进行了拷贝。对于一些变量、函数接口的简单注释可以不写姓名和日期。 正例 ： // 这里写你的注释 add by zhangsan 20100929 // 这里写你的注释 修改者：张三 2010-09-29 void OnBlowStop(); // 吹气关 void OnBlowStart(); // 吹气开 反例 ： // 这里写你的注释 add by zs 20100929 // 这里写你的注释 add by mill 20100929 // 这里写你的注释 修改者：小李 20100929 5.4 OOP 规范 在程序设计领域， SOLID（单一功能、开闭原则、里氏替换、接口分离以及依赖反转）是由罗伯特· C ·马丁在21世纪早期引入，指代了面向对象编程和面向对象设计的五个基本原则。当这些原则被一起应用时，它们使得一个程序员开发一个容易进行软件维护和扩展的系统变得更加可能。 【规则 4-1】 避免申明类的成员变量为 public 。 例外 ：static readonly 成员变量和 const 成员变量例外。若非继承类需要使用，则默认申明为 private。 【规则 4-2】 避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成 本，直接用类名来访问即可。 【规则 4-3】 类的继承请符合里氏替换原则。 说明 ： 里氏替换原则（LSP）声明：“所有引用基类的地方必须能透明地使用其子类的对象”。 【规则 4-4】 所有重载（overload）方法的相同变量应该都保持同样的目的和相同的表现。 说明 ：不要给人太多意外。 正例 ： public class Foo { public double CalcAmount(int quantity, double price) { return CalcAmount(quantity, price, 1.0d); // 1.0表示不打折扣 } public double CalcAmount(int quantity, double price, double discount) { ... } } 【规则 4-5】 不能使用过时的类或方法。 说明 ：接口提供方既然明确是过时接口， 那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。C#会通过特性[Obsolete(过时原因及替换方式)]标注。 正例 （c#）： 以下标明了该属性已过时， 不能使用。 /// <summary> /// 气体模式默认气体类型 /// </summary> [Param(\"Control\")] [Obsolete(\"命名语义不明确, 以后的版本中将会删除. 请使用 DefaultGasTypeOfGasTypeMode\")] public int DefaultBlowType { get => (int) DefaultGasTypeOfGasTypeMode; set => DefaultGasTypeOfGasTypeMode = (GasTypes) value; } 5.5 函数 函数是程序的基本功能单元。如何编写出正确、高效、易维护的函数是软件编码质量控制的关键。一个函数包括函数头，函数名，函数体，参数，返回值。 函数一般结构如下： /// <summary> /// 函数注释 /// </summary> 函数作用域 返回值 函数名(参数1， 参数2...) { // 检查函数入参 // 主体逻辑 // 函数返回 } 如何写好一个函数, 关键是以下四个方面： 函数仅完成一件功能。 限制函数的体量， 容易理解函数功能。 函数名的命名：命名是提高可读性的第一步。 函数的参数： 保证尽可能少的参数。毫无疑问，函数参数越多，函数的易用性就越差。 不要修改输入参数。如果输入参数在函数内被修改了，很有可能造成潜在的bug，而且使用者不知道调用函数后居然会修改函数参数。如果不可避免地要修改，一定要在注释中说明。 尽量不要使用输出参数替代返回值。使用输出参数说明这个函数不只做了一件事情，而且使用者使用的时候可能还会感到困惑。 函数体： 保持一定的函数体结构；如上函数一般结构。 相关操作尽量放在一起； 尽量减少代码嵌套； 尽量保证函数只有一个return。 【规则 5-1】 一个函数仅完成一件功能。 说明 ：一个函数实现多个功能给开发、使用、维护都带来很大的困难。 将没有关联或者关联很弱的语句放到同一函数中，会导致函数职责不明确，难以理解，难以测试和改动。 【规则 5-2】 请保持函数的一般结构， public 函数应首先校验参数的合理性。 说明： 函数一般结构如下： /// <summary> /// 函数注释 /// </summary> 函数作用域 返回值 函数名(参数1， 参数2...) { // 检查函数入参 // 主体逻辑 // 函数返回 } 相关操作尽量放在一起，尽量保证函数只有一个 return 。 【规则 5-3】 函数名用大写字母开头的单词组合而成，且应当使用 “动词”或者“动词＋名词”（动宾词组）的形式命名。 说明 ：函数名通常是指令性的,力求清晰、明了，通过函数名就能够判断函数的主要功能。函数名中不同意义字段之间不要用下划线连接，而要把每个字段的首字母大写以示区分。函数命名采用大小写字母结合的形式。 很多开发人员会采用一个比较宽泛的动词来为函数命名。为求函数名的准确， 关键还是靠单词的积累，多阅读优秀源码。下面是整理的一些常用动词，可以参考使用： add/remove increment/decrement open/close begin/end insert/delete show/hide create/destory lock/unlock start/stop get/put get/set **正例 **1： 函数命名采用大小写夹杂的动宾结构命名。如： int GetLastError(); // 推荐 int OpenFile(); // 推荐 **正例 **2： 属于同一类的一组函数可以使用共同前缀来标识。如： int NetGetError(); int NetOpen(); int NetClose(); int NetSend(); int NetReceive(); 反例 ： int getlasterror(); // 全小写，不推荐 int get_last_error(); //全小写，不推荐 int FileOpen(); // 非动宾结构，不推荐 【原则5-4】 保证尽可能少的参数。 说明： 毫无疑问，函数参数越多，函数的易用性就越差。 【原则 5-5】 尽量不要修改参数。 说明： 如果参数在函数内被修改了，很有可能造成潜在的bug，而且使用者不知道调用函数后居然会修改函数参数。如果不可避免地要修改，一定要在注释中说明。 【原则 5-6】 尽量不要使用参数代替返回值。 说明： 使用输出参数说明这个函数不只做了一件事情，而且使用者使用的时候可能还会感到困惑。 除非返回值已经被定义， 并且该参数需要返回的跟返回值不属于同一类。 正例 ： public static bool TryParse(string s, out DateTime result) { ... } 反例： public void TryParse(string s, out DateTime result) // 返回值是void { ... } public HardwareInfo QueryHardWareInfo(out string cpuName) // 返回值与out参数相关 { ... } 【规则 5-7】 避免函数过长，新增函数不超过 200 行（非空非注释行）。 说明 ：过长的函数往往意味着函数功能不单一，过于复杂。 函数的有效代码行数，即非空非注释行应当在[1，200]区间。 例外 ：某些实现算法的函数，由于算法的聚合性与功能的全面性，可能会超过 200 行。 【规则 5-8】 对于函数体，嵌套的层次不超过4层。 说明 ：仅对新增函数做要求，对已有的代码建议不增加嵌套层次。 函数的代码块嵌套深度指的是函数中的代码控制块（例如：if、for、while、switch等）之间互相包含的深度。每级嵌套都会增加阅读代码时的脑力消耗，因为需要在脑子里维护一个“栈”（比如，进入条件语句、进入循环……）。应该做进一步的功能分解，从而避免使代码的阅读者一次记住太多的上下文。 反例 ： for (condition) { if (condition) { while (condition) { if (condition) { if (condition) { … } } } } } 5.5.1 C++ 【规则 5-1-1】 如果参数是指针或引用，且仅作输入作用，则应在类型前加 const 。 说明 ：防止该指针指向的内容在函数体内被意外修改。 正例 ： int GetStrLen(const char* pcString_); int GetStrLen(const int& nValue_); 例外说明： 在实际编码时，为了避免只读形参被更改，但又不想增加代码编写的额外负担，可以使用下列方式，通过在函数内部声明一个常变量的方式，而不是函数形参直接用const。 void SetValue(int* pnData_) { const int* _pnValue = pnData _; int _nSum = (*_pnValue) * (*_pnValue); ... ... return; } 函数体的实现并不是随心所欲，而是有一定的规矩可循。不但要仔细检查入口参数的有效性和精心设计返回值，还要保证函数的功能单一，具有很高的功能内聚性，减少函数之间的耦合，方便调试和维护。 5.6 表达式与语句 表达式是语句的一部分，它们是不可分割的。表达式和语句虽然看起来比较简单，但使用时隐患比较多。本章归纳了正确使用表达式和 if、for、while、switch 等基本语句的一些规则与建议。在写表达式和语句的时候要注意运算符的优先级。 【规则 6-1】 一行仅声明一个变量。 说明 ：复杂的语句阅读起来，难于理解，并容易隐含错误。变量定义时，一行只定义一个变量。对于一些数学计算相关的除外。 正例 ： int quantity = 0; int customerNum = 0; int currentNum = 0; 反例 ： // 一行定义多个变量 int quantity, customerNum; 【规则6-2】 一个变量有且只有一个功能，不能把一个变量用作多种用途。 说明 ：一个变量只用来表示一个特定功能，不能把一个变量作多种用途，即同一变量取值不同时，其代表的意义也不同。 正例 ： void Init() { double length = 10; // 长度 SetLength(length); double area = 20; // 面积 SetArea(area); ... } 反例 ： void Init() { double length = 10; // 长度 SetLength(length); length = 20; // 面积 SetArea(length); ... } 【规则6-3】 能放在循环体外的变量声明、条件判断、函数调用和计算等，不要放在循环体内。 说明 ：如果变量是一个对象，每次进入作用域都要调用其构造函数，每次退出作用域都要调用其析构函数。见正例 1和反例 1。 下面两个示例中，反例 2 比**正例 **2 多执行了 loopNum-1 次逻辑判断。并且由于前者总要进行逻辑判断，使得编译器不能对循环进行优化处理，降低了效率。如果 loopNum 值大到一定程度，采用正例的写法，可以提高效率。 const int loopNum = 100000; **正例 **1: // 类似变量放到循环作用域外面声明要高效的多： Foo foo = new Foo(); for (int i = 0; i < loopNum; ++i) { foo.DoSomething(i); } **反例 **1: // 低效的实现 for (int i = 0; i < loopNum; ++i) { Foo foo = new Foo(); // 构造函数和析构函数只调用c_nNum 次 foo.DoSomething(i); } 正例 2: if (condition) { for (int i = 0; i < loopNum; i++) { DoSomething(); } } else { for (int i = 0; i < loopNum; i++) { DoOtherthing(); } } **反例 **2: for (int i = 0; i < loopNum; i++) { if (condition) { DoSomething(); } else { DoOtherthing(); } } 5.6.1 C++ 【规则 6-1-1】 不可将大布尔变量 BOOL 逻辑表达式直接与1进行比较。 说明 ：根据 BOOL 布尔类型的语义，零值为“假”（记为 FALSE），任何非零值都是“真”（记为 TRUE）。TRUE的值究竟是什么并没有统一的标准。例如 Visual C++ 将 TRUE 定义为 1，而 Visual Basic 则将TRUE定义为 -1。 注意： 对于 bool 变量，也使用下列正例的写法。 正例 ： BOOL _bFlag = TRUE; if (_bFlag) // 表示_bFlag为TRUE if (!_bFlag) // 表示_bFlag为FALSE bool _bRet = GetRet(); if (_bRet) // 表示_bRet为true if (!_bRet) // 表示_bRet为false 反例 ： // 设_bFlag 是BOOL布尔类型的变量 if (_bFlag == 1) 【规则 6-1-2】 在条件判断语句中，当整型变量与 0 比较时，不可模仿布尔变量的风格，应当将整型变量用“==”或“!=”直接与 0 比较。 正例 ： 假设整型变量的名字为_nValue，它与零值比较的标准，if语句如下： if (_nValue == 0) if (_nValue != 0) 反例 ： //不可模仿布尔变量的风格而写成下面示例。 会让人误解 nValue是布尔变量 if (_nValue) if (!_nValue) 【规则6-1-3】 禁用目前系统中大于、大于等于、小于、小于等于相关浮点数比较宏，仅仅保留约等于浮点数宏（由于计算机浮点数的表示和计算有一定的精度损失）。 说明： 仅保留：**DOUBLE_EQU、DOUBLE_EQU_ZERO、FLOAT_EQU、FLOAT_EQU_ZERO **四个宏或是系统中其他与这四个宏功能类似的宏或函数，且这四个宏仅限于约等于的情况，其他情况下：大于比较，使用>、大于等于比较，使用>=、小于比较，使用<、小于等于比较，使用<=。 具体原因以 DOUBLE_GE 说明：DOUBLE_GE(a, b)的定义包含两个语义a > b 或 a ≈ b，其中a ≈ b表示的是在一定的正负误差范围内，a,b两个数相等。比如本来希望通过DOUBLE_GE(a, b)来判定a >= b，但是可能会出现a实际比b稍小一点点(在误差范围内)，但是因为使用了宏 DOUBLE_GE，误认为满足条件 a >= b 的情况，导致后续各种代码异常。DOUBLE_GE_ZERO 也同样存在上述 DOUBLE_GE 问题。具体见下示例代码。 实际代码原本需要判断的Y_一定是大于等于 0 （处于一、二象限的情况），但是因为使用了 DOUBLE_GE_ZERO 宏定义，当 Y_的值是稍稍小于 0 的一个值时，因为宏中的等于判断对于待比较数进行了取绝对值操作，所以会出现误判的情况。实际修改时将 if (DOUBLE_GE_ZERO(Y_)) 修改为 if (Y_ >= 0)。 反例： //计算矢量与X轴正方向的角度 double _compute_angle(double X_, double Y_) { double _nRadius = sqrt(powersum2(X_, Y_)); if (_nRadius <= 0) return 0.0; ASSERT(_nRadius > 0.0); double _temp = X_ / _nRadius; __CUT(_temp, -1.0, 1.0); double _nAngle = acos(_temp); // 当Y为非负值，即在第一、第二象限时 if (DOUBLE_GE_ZERO(Y_)) //Error 此处改为if (Y_ >= 0)为正例 return _nAngle; // 当Y为负值，即在第三、第四象限时 return 2.0 * c_nPIE - _nAngle; } 备注: 特殊情况下,如若要使用以上禁用的宏,必须要邮件上报研发总监和软件部经理。 5.6.2 C# 【原则 6-2-1】 避免使用 ToUpper(), ToLower() 转换后比较字符串， 字符串比较请使用 String.Compare。 【原则 6-2-2】 超过5个字符串拼接， 请使用 StringBuilder。 说明 ：String 的值是不可变的，这就导致每次对String的操作都会生成新的 String 对象，不仅效率低下，而且浪费大量无用的内存空间。 【原则 6-2-3】 涉及到版本号比较， 避免使用字符串比较， 请使用类 System.Version。 说明 ：在版本号比较时， 不能通过字符串比较来得到哪个版本更新。 正例 ： Version oldVersion = Version.Parse(\"1.1.2\"); //通过读取配置获取 Version newVersion = Version.Parse(\"1.1.13\"); // 通过读取配置获取 if (newVersion > oldVersion) { // 更新操作 } 反例 ： string oldVersion = \"1.1.2\"; //通过读取配置获取 string newVersion = \"1.1.13\"; // 通过读取配置获取 if (newVersion > oldVersion) // 这里为false， 字符串比较逻辑 { // 更新操作 } 【规则 6-2-4】 三目运算符禁止嵌套使用。 说明： 三目运算符在阅读时就需要思考。 若嵌套使用， 增加了阅读难度。 反例： string fileRangeFromStr = isContinueMachine ? string.Format(\"第{0}行\", currentLineNo) : from <= 1 ? \"文件开始\" : string.Format(\"第{0}行\", from); 5.7 变量、常量与类型 【规则 7-1】 局部变量尽可能置于最小作用域内，并在声明变量时将其初始化。 说明 ：提倡在尽可能小的作用域中声明变量，离第一次使用越近越好。这使得代码易于阅读，易于定位变量的声明位置、变量类型和初始值。特别是，应使用初始化代替声明+赋值的方式。 5.7.1 C++ 【规则 7-1-1】 已经定义了枚举类型的变量，要直接使用枚举类型变量，而不要出现枚举类型变量与常数混用的情况。 enum dblz_t { DBLZ_NA = -1, DBLZ_Z1, DBLZ_Z2, DBLZ_Z1Z2, }; 正例 ： dblz_t _nSysDblzType = DBLZ_NA; void SetDblzMode(dblz_t nDblzType_) { if (_nSysDblzType == DBLZ_Z1) // good直接与枚举值比较 { ... } ... } 反例 ： void SetDblzMode(dblz_t nDblzType_) { if (_nSysDblzType == 0) //bad 不要直接与常数进行比较 { ... } ... } 【规则 7-1-2】 宏定义中如果包含表达式或变量，表达式和变量必须用小括号括起来。 说明 ：在宏定义中，对表达式和变量使用括号，可以避免可能发生的计算错误。不要在宏中使用表达式或者调用函数，使用 inline 函数代替函数宏。使用 const 代替常数宏。 正例 ： #define HANDLE(A, B) ((A) / (B)) 反例 ： #define HANDLE(A, B) (A / B) 5.8 断言和错误处理 断言是对某种不应该发生的条件进行检查,它可以快速发现并定位软件问题，同时对系统错误进行自动报警。断言可以对在系统中隐藏很深，用其它手段极难发现的问题进行定位，从而缩短软件问题定位时间，提高系统的可测性。在实际应用时，可根据具体情况灵活地设计断言。 错误处理需注意以下几点： 错误处理很重要，但不能搞乱代码逻辑 错误处理应该集中在同一层处理，并且错误处理的函数最好不包含其他的业务逻辑代码，只需要处理错误信息即可。 抛出异常时提供足够多的环境和说明，方便排查问题 异常抛出时最好将执行的类名，关键数据，环境信息等均抛出，此时自定义的异常类就派上用场了，通过统一的一层处理异常，可以方便快速地定位到问题。 【原则 8-1】 整个软件系统应该采用统一的断言，使用断言捕捉不应该发生的非法情况。不要混淆非法情况与错误情况之间的区别，后者是必然存在的并且是一定要作处理的。 说明：断言是用来处理不应该发生的错误情况的，通常用于捕获程序内部不可能发生的错误，而外部可能会产生的错误通常用异常处理方式，不能用断言来实现。 **正例 **1： /// <summary> /// 开始调机 /// </summary> /// <returns> /// 开始调机状态 /// </returns> private StartAdjustState ToStart() { [Code Snippet] if (isStarting) { Debug.Assert(false); return StartAdjustState.InvalidServoType; } [Code Snippet] } **正例 **2： /// <summary> /// 多媒体回调函数 /// </summary> public void Elasped(object sender, EventArgs e) { try { foreach (var services in servos) { Services.Elapsed(); } } catch (Exception ex) { Log.Error(\"Elasped Error! exception:\" + ex.ToString()); throw; } finally { // Code Snippet; } } **正例 **3： /// <summary> /// 开始调机 /// </summary> /// <returns> /// 开始调机状态 /// </returns> private StartAdjustState ToStart() { … if (isStarting) { Trace.WriteLine(\"伺服为启动状态\", \"Warning\"); return StartAdjustState.InvalidServoType; } … } 5.8.1 C++ 【规则 8-1-1】 正常执行的代码不允许在断言中。造成的后果是：Release 版下当断言不编译时，断言中的可执行部分代码也不会编译。 **反例 **1： //下面的代码Create动作在DEBUG下会执行，但是Release版下不会执行 ASSERT(m_pwndLog->Create(this, IDC_DIAGFORM_LOG)); ASSERT(m_pwndPlc->Create(this, IDC_DIAGFORM_PLC)); ASSERT(m_pwndIo->Create(this, IDC_DIAGFORM_IOLISTFORM)); **反例 **2： //下面的代码Create动作在DEBUG下会执行，但是Release版下不会执行 MatchedGroups::MatchedGroups() { Reset(); for (int _i = 0, _Size = _countof(m_nMG_ValidGroupData); _i < _Size; ++_i) ASSERT(m_nMG_ValidGroupData[_i][0] - G_GROUP_FIRST == G_GROUP_MOVE + _i); } 5.8.2 C# System.Diagnostics 命名空间提供 Debug 和 Trace 两个类，分别用于代码调试和代码跟踪。Debug.Assert(bool condition) 仅在 Debug 版本下有效，在 Release 版本下无效。可以用 Debugview 工具对 Release 版本中的 Trace 信息进行跟踪。 【原则 8-2-1】 优先考虑使用 System 命名空间中已有的异常，而不是自己创建新的异常类型。 说明 ：要使用最合理，最具针对性的异常。例如，对参数为空，应抛出System.ArgutmentNullException，而不是 System.ArgutmentException 【规则 8-2-2】 不要抛出异常基类 Exception 。 说明 ：Exception 是一个非常抽象的异常类，捕获这类异常通常会产生很多负面影响。通常情况下应该定义我们自己的异常类，并且需要区分系统（framework）抛出的异常和我们自己抛出的异常。 【原则 8-2-3】 自定义异常类型需以 Exception 结尾，并标记为 Serializable 。 【原则 8-2-4】 要捕获具体的异常，并记录日志。 说明：请尽可能的捕获具体异常（而非 Exception ， 除非故意忽略）；记录日志不要只记录 Exception.Message 的值，还需要记录 Exception.ToString() 。 特别说明： 上面给了断言和错误处理的原则，但是并不是每一个地方都需要进行相关断言处理，否则断言和异常处理太多，一是会影响代码的可阅读性，同时也会增加很多不必要的预防成本。可以把某些接口选定为安全区域的边界（模块或是 dll 提供的外部接口），对穿越安全区域边界的数据进行合法性校验，并当数据异常时做出错处理。模块外部传入的数据，必须对输入数据的合法性进行检测，一旦数据通过了合法性检测，进入模块内部，可以假定数据的正确性，此时不需要重复去做一些数据合法性检测。同理，对于一个模块输出给外部模块使用的数据，必须对输出数据的合法性进行检测，但是如果这个输出数据只在内部使用，可以只做一些有必要的检测。 在类的层次也可以采用这个方法，类的公用方法假定数据是不安全的，他们负责检查数据并进行处理，一旦公用方法接收了数据，那么类的私有方法就可以假定数据是安全的。 编制：胡凯烽 审核：陈豫 批准：郑之开 审批链接： http://172.16.1.166:85/workflow/request/ViewRequest.jsp?requestid=284024&_workflowid=564&_workflowtype=&isovertime=0"
  },
  "doc/研发管理制度规范/软件项目目录与文件管理规范-R1.html": {
    "href": "doc/研发管理制度规范/软件项目目录与文件管理规范-R1.html",
    "title": "软件项目目录与文件管理规范",
    "keywords": "软件项目目录与文件管理规范 版次：2022年3月10日 第1版 类型：程序文件 部门：软件部 上海维宏电子科技股份有限公司 版权所有 文件版本 修改前文件版本 主要修订内容和原有 修订人 R3.1 R3（郑之开 草稿版） 1. 规范文档格式。 2. 去除 SRS 模板，独立成文件。 3. 翻译注释为中文。 4. 修改 SRS 部分。 祁彩云 目的和范围 本制度就公司软件项目的文件管理和目录结构做出规定和建议。 对于采用 MSF 作为开发流程的项目来说，本制度为强制性的。 对于其它项目，应尽可能参照本制度执行。 用词说明 为了便于在执行本标准条文时区别对待，对要求严格程度不同的用词说明如下： 1） 表示很严格，非这样做不可的用词： 正面词采用“必须”，反面词采用“严禁”； 2） 表示严格，在正常情况下均应这样做的用词： 正面词采用“应”，反面词采用“不应”或“不得”； 3） 表示允许稍有选择，在条件许可时首先应这样做的用词： 正面词采用“宜”，反面词采用“不宜”； 4） 表示有选择，在一定条件下可以这样做的用词，采用“可”。 条文中指明应按其他有关标准、规范执行的写法为：“应符合……规定”或“应按……执行”。 术语和定义 为了确保对术语的一致性理解，此处定义本文档用到的术语： MSF： Microsoft Solution Framework 的缩写，是微软产品研发的方法论，2022年起公司借鉴其方法论开展研发管理工作。 仓库：repository，研发过程中的文档、代码、测试用例等文档都必须放到仓库中。 资产类文档：研发过程中的文档、代码、测试用例等文档都称为资产类文档。 参考文献 github project structure best practices GitHub Repository Structure Best Practices 主要参考的 git 代码库： C# language : 这个库里没有代码，记录了 C# 语言规范、提案、会议纪要。 一般性规定 应尽早建立并使用仓库管理资产。对于 MSF 项目，早在展望阶段，就应该建立并使用仓库。 一个 MSF 项目应只有一个仓库。如果需要增设更多仓库，必须向软件部提出申请。 仓库必须采用 git 作为版本管理工具。 资产类文档必须存放到仓库中。 注：如果本规范不合适你的项目，请向软件部提出申请。经过软件部书面答复后，方可变更。 目录结构 仓库必须符合本节要求的目录结构。 原则： 宜采用浅的目录结构，或者称为扁平的目录结构。 可选文件和目录，应等到需要的时候再去建立。 目录和文件名应尽可能采用英文。 请注意，目录和文件名的大小写必须符合规定。这是因为考虑到 linux 平台的可移植性。 git 服务器端的目录和文件结构： <project-name>/ ; project root dir +-- doc/ +-- srs/ +-- design/ +-- pm/ +-- risk.md +-- roles.md +-- stakeholder.md +-- src/ +-- test/ +-- .editorconfig ; or `.clang-format` +-- .gitattributes +-- .gitignore +-- README.md +-- <project-name>.sln 解释 <project-name>/ - 项目根目录。 doc/ - 文档目录，包括srs及其它文件。 doc/srs/ - SRS文件 doc/design/ - 设计方案文件 pm/ -项目文件目录，包括项目风险文件、利益相关人和项目结构文件。 src/ - 源代代码文件夹。 test/ - 测试用例文件夹。 .gitignore - 忽略文件配置清单。将会影响到如 git add 和 git clean 这样的命令。可以用 gitignore.io 生成一个干净有用的.gitignore文件。 .gitattributes - 用来定义文件的属性（如：更改文件在差异中的外观）。 .editorconfig|.clang-format - 代码格式化文件。 README.md - 项目简介文件。很重要！ <project-name>.sln - VS解决方案文件，或者类似作用的build脚本。也许有多个类似文件。 可选目录 <project-name>/ +-- sample/ +-- tool/ sample/ - 提供样例代码，以便新人快速入门，一般小型的库有这个目录。 tool/ - 工具类文件夹，一般包括自动构建、持续集成之类的任务脚本等，大多是批处理文件。 README.md文件 这是一个非常重要的文件。其存在的价值在于，让新加入项目的同事，能够通过阅读本文件对整个项目有个概况性了解。是否很好地实现了这个价值，是判断README.md文件的合格与否的关键标准。 依据MSF在展望历程的关键输出文档 远景/范围文件 ，其内容如下： 远景/范围文件 - 问题陈述 - 远景/使命 - 高层需求，SMART原则 - 用户特征 - 设计策略：架构&技术 - 定义验收标准 可以发现这些内容对于概括性了解整个项目很重要，因此这些内容就应作为README.md 的主体而存在。README.md 的主体结构如下： # <project-name> ## 概述 ## 远景/使命 ## 高层需求 ## 用户分类 ## 设计策略 ## 验收标准 可以再加上其它内容，比如： 如何编译 版本说明 项目文件目录 项目文件目录为 pm 。用于存放MSF各个历程的项目管理相关文件。包括： stakeholder.md 利益关系人文件(干系人) roles.md MSF团队角色文件 risk.md 风险评估文件 SRS 文件 原则 SRS 文档存放在 /doc/srs/ 目录下，采用源代码方式管理。 SRS 不是一个大文件，而是按照 SRS 标准中规定的结构拆分为三个章节，【引言】和【总体描述】分别为一个或多个文件，【详细描述】部分按照功能分类后独立成更小的文件，然后经过 docfx 工具拼起来。 SRS 必须使用 markdown(.md) 格式，不得采用 WORD(.doc), EXCEL(.xls) 等格式。 SRS 的图片等资源文件，须放在文档同级目录的./images/或./media/目录下， 也可统一存放在 /doc/srs/res/ 目录下。 在 markdown 格式的文件里，不应编制大型表格。原因是这种大型表格编写和维护困难，并且难以进行版本比对。 SRS 编写细节请参照相关标准及编写指导书，具体在【附录】章节，特别注意，第三章有多种写法，其具体格式不做要求，关键描述用户可以感知到的集合及非功能性规格。 目录 SRS 是多个子文件拼接起来的大文档，各个子文件的目录结构大致如下，该部分不做强制要求，符合目录结构 尽量扁平 的原则即可： +-- srs/ +--introduction.md +--overallDESC.md +--FunctionName/ +--FunctionName.md 解释 introduction.md - 引言部分，可以是一个或拆分为多个.md文件。 overallDESC.md - 总体描述部分，可以是一个或拆分为多个.md文件。 FunctionName/ - 详细描述部分的分类文件夹，不是必须，根据功能粒度自行选择创建。 FunctionName.md - srs的功能分类下的子功能文件，文件名称只需要描述功能或子功能名称即可。 附录 1 ） 微盘路径：软件部学习资料共享->需求分析参考书 SRS 标准 -《9385——2008 计算机软件需求规格说明书规范》 2 ） 微盘路径：软件部学习资料共享->MSF实践参考 SRS 编写指导 -《产品需求规格说明书（SRS）-编写指导-1.4》 introduction.md -SRS【引言】章节大纲 overallDESC.md - SRS【总体描述】章节大纲 README-XXXMSF项目样例.md (TODO) roles-XXXMSF项目样例.md (TODO) stakeholder-XXXMSF项目样例.md (TODO) risk-XXXMSF项目样例.md (TODO) ​ 编制： 审核： 批准： 审批链接："
  },
  "doc/研发管理制度规范/金属切削产品部运维工作流程-R1.html": {
    "href": "doc/研发管理制度规范/金属切削产品部运维工作流程-R1.html",
    "title": "金属切削产品部运维工作流程",
    "keywords": "金属切削产品部运维工作流程 版次：2021年8月12日 第1版 类型：程序文件 部门：金属切削产品部 上层文件：TFS 工具使用指导书-R10 上海维宏电子科技股份有限公司 版权所有 <现结合金属切削产品部情况， 归纳总结适合本部门的运维工作流程。流程中涉及的沟通渠道，除特殊指明，否则皆默认为 RTX> 文件版本 修改前文件版本 主要修订内容 修订人 修订日期 R1 无 初版发布。 汤飞碧 2021.08.12 1 适用范围 此文档适用于金属切削产品部所有基于 TFS 的开发工作，包括但不限于外部申请（客户或技术员反馈）的工作项和内部要求（公司内部要求） 的工作项。 此文档不适用于： 1） 工作项的衍生 BUG； 2） 项目。 2 职责 副经理：负责确认是否执行 OA 需求单。 开发科科长：负责审批发布内容、变更申请。 测试科科长：负责审批测试软件外发申请。 应用科科长： 负责安排应用工程师。 开发科组长：负责安排开发工程师。 测试科组长：负责安排测试工程师。 开发工程师 1） 功能规格编写人员：负责编写功能规格； 2） 方案设计人员：负责设计开发方案； 3） 方案审核人员：负责审核开发方案的合理性和可行性； 4） 代码实现人员（工作项负责人，以下简称负责人）：负责按照开发方案进行代码编程并自测，发行软件，负责工作项的进度； 5） 代码审核人员：负责审核代码。 测试工程师： 1） 用例设计人员：负责根据开发方案编写测试用例； 2） 测试执行人员：负责按照测试用例执行测试动作， 编写测试执行表； 3） 测试审核人员：负责审核测试用例与测试执行表。 应用工程师：负责分析用户需求并将其转化成产品需求， 提交工作项。 助理：负责外发测试版软件，交付正式版软件。 3 评估需求 应用科科长分配 OA 需求单； 应用工程师应在收到 OA 需求单当日分析需求； 评估完成后，提交副经理确认； 副经理确认后， 应用工程师提交工作项。 说明： 若应用工程师当日无法完成需求评估，需在应用群中提交延期申请。 所有附件统一归档至“运维管理-测试软件”目录下。 4 提交工作项 提交人提交工作项后， 通知开发科科长/组长、测试科科长/组长、全体应用工程师及助理。 助理更新《运维工作一览表》。 5 部署 开发科组长指定开发人员并及时更新 TFS，通知内容含： 1） 人员安排： XXX（功能规格编写、方案设计、方案审核、代码实现、代码审核） 2） 截止日期： YYY 测试科组长指定测试人员并及时更新 TFS， 通知内容含： 1） 人员安排： XXX（用例设计、测试执行、测试审核） 2） 截止日期： YYY 3） 测试输出： 测试规格书/测试点、测试执行记录表 说明： 部署时，被通知人员包含相关开发/测试/应用工程师及助理。 6 开发测试 6.1 功能规格编写 功能规格编写人员根据需求内容编写《功能规格》。 编写完成后，功能规格编写人员发起评审，评审团队需包含开发、测试、应用三方以及产品经理。 评审通过后，开发工程师将《功能规格》归档到“运维管理-测试软件”目录下。 说明： 新功能及重点功能需要编写《功能规格》。 6.2 方案设计 负责人根据《功能规格》编写《开发方案》，并提交方案审核人审核。 审核人员需在 TFS 提交“方案审核说明”，只需记录最后一次审核结论。 审核通过后，负责人将文档归档到“运维管理-测试软件”目录下，并通知代码实现人员和用例设计人员。 说明： “方案审核说明”格式要求，见《工作项开发记录（模板）》。 6.3 测试需求分析与用例设计 用例设计人员根据《功能规格》编写《测试规格书》。 用例设计人员将标注“待审核”字样的文档提交至“运维管理-测试软件”目录下并通知测试审核人审核。 测试审核人员需在 TFS 提交“测试审核说明”。 审核通过后，用例设计人员将最终版《测试规格书》上传至工作项附件中，并通知代码实现人员、测试执行人员。 说明： 若无《功能规格》，用例设计人员需根据需求内容编写《测试规格书》。 “测试审核说明” 格式要求，见《工作项测试记录（模板）》。 6.4 代码实现 代码实现人员在编码结束后， 根据《测试规格书》进行自测，编写《开发自测表》，并将文档上传至工作项附件中。 自测通过后，代码实现人员通知代码审核人审核。 代码审核人员需在 TFS 上提交“代码审核说明”，只需记录最后一次审核结论。 代码审核通过后，代码实现人员将测试软件放到“运维管理-测试软件”目录下，在 TFS 上提交“开发说明”，并通知测试执行人员。 说明： 代码实现人员必须按审核意见进行修改，若不修改则需做出解释并与审核人达成共识。 相关开发记录格式要求，见《工作项开发记录（模板）》。 每一次提测， 代码实现人员均需在 TFS 上提交“开发说明”。 6.5 测试执行 测试执行人员对照《测试规格书》按优先级逐条进行测试执行，并对应记录结论，形成《测试执行记录表》。每完成一次测试， 测试执行人员需在 TFS 上提交测试执行结果，并在测试结束时确保《测试执行记录表》提交至工作项附件。 测试结束，测试执行人员通知测试审核人审核。 测试审核人员在 TFS 提交“测试审核说明”。 审核通过后，测试执行人员通知代码实现人员。 说明： 相关测试记录格式要求，见《工作项测试记录（模板）》。 6.6 软件发布 工作项执行人员确保完成 TFS 更新（包含：开发/测试/审核工期、实际开始/结束时间、预计/实际提交测试版时间、一测开始时间、回归次数、发行版本数）。 负责人更新《软件发布记录表》，截图提交开发科科长审核，并通知全体组员。 负责人更新《功能规格书》与《三级功能规格表》，提交开发科科长审核与产品经理审批，并通知全体组员。 负责人通知助理将正式版软件放到服务器的 NcStudio 目录下。 负责人将使用说明文档放到指定目录下。 说明： 《软件发布记录表》审核要求： ① 发布记录表内容完整、正确； ② TFS 填写完整（除文档外）。 当涉及级别为“严重”的 BUG 工作项时，需对相关软件进行注销，更新《软件注销记录》并通知全体组员。 链接为测试方的 BUG，若不处理或暂缓处理，必须由开发科组长确认； 如果测试工程师不认可此结果，可提出异议，最终以应用工程师意见为准。 当没有发行正式版软件时，除软件归档步骤，其它步骤照常执行。 7 验收与交付 助理审核以下内容： 1） 软件发布记录表（包括：软件类型、版本、用户、工作项 ID、文档名称）填写是否正确。 2） 相关路径下是否已更新软件、文档（包括：开发方案、使用说明文档、测试规格书、测试执行记录表、功能规格表、发布记录表、产品平台客户软件一览表）。 3） 工作项（包括：状态栏、实际工期、测试投入栏、审核记录、缺陷分析、衍生 BUG）是否已更新。 4） 软件发布数量是否符合。 审核通过后，助理关闭任务工作项，并更新《运维工作一览表》。 助理外发邮件通知技术员，并同步更新维宏云盘。 说明： BUG 工作项，由测试工程师关闭。 8 异常情况处理 8.1 需求变更 应用工程师同开发/测试工程师线下确认需求变更（包括原始需求变更、解决方案变更）。 应用工程师更新 TFS （包括内容与截止时间）并通知工作项相关人员及开发/测试组长。 说明： 若开发工程师同技术员确认需求变更，则应及时在 TFS “详细信息”处（非“历史记录”），注明变更后的内容，并通知工作项相关人员。 8.2 截止时间变更 发现有超期风险，负责人需提前同测试/应用工程师沟通并商定新的截止时间。 沟通完成后，负责人提交变更申请，格式如下： ID： 28331； 标题：浙江高光-NK300CX-定制预估加工时间功能； 原截止时间： 2019.12.10； 新截止时间： 2019.12.17； 变更原因： XXX； 计划安排： YYY。 开发科长审批通过后，助理更新 TFS 和《运维工作一览表》。 说明： 无法确认新的截止时间，则应申请变更，提交预估的截止时间，且该次不计入变更次数。如： ID： 28099 标题：广东科拓-NK260\\NK280-修改全部清零功能等功能定制-黄六考 原截止时间： 2019.11.30 新截止时间（估）： NK280B 升级磨刀机结束日期（12.20） +5 天 变更原因： XXX。 8.3 测试软件外发 发生测试软件外发需求时，负责人通过邮件提交“测试版软件外发申请”，填写内容包括：“基础信息、申请理由、修改内容及风险点说明”，邮件发送至测试人员；同时，负责人将测试软件上传至指定目录下，并填写《测试版软件外发记录表》。 测试人员在邮件中补充风险点说明，并提交测试科长审批。 审批通过后，助理外发测试版软件。 9 流程图 9.1 总流程图 9.2 开发测试流程图 10 附录 10.1 相关文件 文档模板： \\\\file01.weihong.com\\02.各部门受限\\02.产品 I 部\\02.部门管理\\02.模板\\01.运维管理 《功能规格》归档目录： \\\\172.16.10.88\\02.各部门受限\\02.产品 I 部\\07.运维管理\\01.功能规格 《开发方案》归档目录： \\\\file01.weihong.com\\02.各部门受限\\02.产品 I 部\\07.运维管理\\03.开发方案 所有运维过程文件、测试软件目录： \\\\file01.weihong.com\\02.各部门受限\\02.产品 I 部\\07.运维管理\\02.测试软件 《工作项开发记录（模板）》： \\\\file01.weihong.com\\02.各部门受限\\02.产品 I 部\\03.研发科\\01.制度规范 《工作项测试记录（模板）》： \\\\file01.weihong.com\\02.各部门受限\\02.产品 I 部\\04.测试科\\00.制度规范_测试体系 2.0 《使用说明书》归档目录： \\\\file01.weihong.com\\02.各部门受限\\02.产品 I 部\\07.运维管理\\04.使用说明书 10.2 相关记录文件 《运维工作一览表》（外网）：微盘\\产品Ⅰ部-（内部资料室）\\2.计划 软件发布路径、《软件发布记录表》、《软件注销记录》： \\\\file01.weihong.com\\06.NcStudio\\金属切削产品部\\1. 发布记录表（不同步到云盘） 《功能规格表》： \\\\172.16.10.88\\02.各部门受限\\02.产品 I 部\\07.运维管理\\01.功能规格 《测试版软件外发记录表》、外发测试软件目录： \\\\file01.weihong.com\\02.各部门受限\\02.产品I 部\\07.运维管理\\02.测试软件\\01.测试外发"
  },
  "doc/研发管理制度规范/需求台账.html": {
    "href": "doc/研发管理制度规范/需求台账.html",
    "title": "需求台账",
    "keywords": "需求台账 目的 本制度在于通过对传统研发活动（非 MSF）建立需求台账，对产品线和平台的“传统研发活动”的需求管理进行管控，以帮助团队顺利迁移到 MSF 研发模型。 范围 缺陷（BUG）不在本制度范围内。 MSF 需求管理不在本制度范围内。 背景 我们研发团队每天每周的需求不少，呈现出一种零零碎碎持续不断的状态，对应地，我们的研发团队也长期处于零零碎碎持续不断研发的局面，团队主要精力也都是在应付这些零碎需求（还有它们产生的 BUG），这其实是不太正常的！虽然从客户那里来的需求的确可能是零碎的、持续的，但是健康的研发活动应该是有一定预见性的、有计划的、主要处于有规律的研发活动周期的，对当下的我们而言，就是应该主要处于 MSF 研发模型的工作流控制内的。 但是眼下， MSF 刚刚推广，大量的研发活动还是处于传统研发模式。不幸的是我们认识到，如果对这些的传统模式研发活动加以管控，我们的团队并不能自觉地迁移到 MSF 模型中去。因此本制度的目的就在于对传统研发活动施加适当控制，以便尽快地完成整个公司的研发活动向 MSF 模型迁移。我们希望通过一段时间的努力，形成这样的局面： 大量的细碎需求，变成了可以通过修改配置和脚本的二次开发，从而在本名单中剔除。 产品侧在商务上的密切配合，完善产品规格，避免研发资源的浪费。 通过对这些需求的管控，尽早形成符合 MSF 要求的数字资产，从而方便今后将这些资产合并到 MSF 研发模型中。 把主要的研发活动都转移到 MSF 团队，类别的意思就是“从零碎不断的研发”到“有计划的批量研发”。 要求 每个产品线有且有一个此表 。各个产品线和平台，都要建立此台账。各个产品线（平台）有且只有一份此台账。 全面收录，无遗漏 。各个产品线的非 MSF 项目的需求活动都必须登录在这个表中。（MSF 项目的需求，则必须进入 SRS ，并按照 MSF 流程进行审核） 需求备案制 。此制度体现了需求管理备案制的思想，备案并不意味着审核，具体地说：1) 产品线必须履行全面备案职责，2) 总监们自主决定是否对特定需求发起适宜的管理活动。 实现为微文档 。建议使用“微文档”实现这个表，以便于大家共享，而且让总监们直接填写此表。 产品侧意见要在研发侧之前收集 。 关于表的具体说明 表格分为四个模块：功能规格、项目管理、产品侧意见和观点、研发测意见与观点，还有一个可选模块：评审意见。具体条目如下： 需求名称 此列是该需求的名称。 产品名称 此列请填写一个产品线登记在册的规范产品名称。（以此推进产品线规范地管理产品族！） 三级规格 此列请填写该需求对应的一二三级规格名称。这说明我们是以三级规格的颗粒度来的进行需求管理的。如果用户提出的功能需求的颗粒度太粗，比如：某用户提出了一个比较复杂的功能，它是一个二级规格，且需要细化为一系列的三级规格才能实现这完整的功能。那么，这时我们就要在表格中每行对应一个三级规格地填写，而不是把整个二级规格写到一行。另一方面，如果用户的需求过细，这里我们就填写其对应的三级规格名称。 提出时间 此列请填写首次提出该需求的时间。团队从这个时间开始思考并调研是否去实现这个功能需求，而不是已经做出了决定要实现它的时间。 进度状态 填写者需要从下列多个状态中选一个： 需求调研 市场侧审核 无需方案直接编码 方案初版 方案一审 方案二审 方案三审 依方案编码 测试验真中 需求结案 需求取消 产品侧意见于观点-产品线 产品线的产品侧人员，包括：应用工程师、产品经理、产品部经理，从市场和产品类别角度给出自己的详细意见和观点。之所以提出“详细”，是因为没有其它文档记录这些信息，所以要详细些。 产品侧意见于观点-产品总监 产品总监从市场和产品类别角度给出详细评审意见和观点。同上。 研发侧意见于观点-产品线 产品线的研发侧人员，包括：架构师、软件工程师、测试工程师、产品线总工，从技术角度给出意见和观点。之所以这里没有提出“详细”，是因为可能有《设计方案》已经阐述了详细信息，那么这里记录要点即可；但是，文档中没有的信息，例如研发总监的评审意见，还是要写详细的。 研发侧意见于观点-研发总监 产品总监从技术角度给出的详细评审意见和观点。因为在此刻评审意见没有其它技术文档来记录，所以还是要写详细的。"
  },
  "README.html": {
    "href": "README.html",
    "title": "docfx_build",
    "keywords": "docfx_build 各文档整合，docfx生成"
  }
}